
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>tfe: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/GGPrompts/tfe/command.go (0.0%)</option>
				
				<option value="file1">github.com/GGPrompts/tfe/context_menu.go (0.0%)</option>
				
				<option value="file2">github.com/GGPrompts/tfe/dialog.go (0.0%)</option>
				
				<option value="file3">github.com/GGPrompts/tfe/editor.go (0.0%)</option>
				
				<option value="file4">github.com/GGPrompts/tfe/favorites.go (63.9%)</option>
				
				<option value="file5">github.com/GGPrompts/tfe/file_operations.go (20.5%)</option>
				
				<option value="file6">github.com/GGPrompts/tfe/fuzzy_search.go (0.0%)</option>
				
				<option value="file7">github.com/GGPrompts/tfe/helpers.go (76.2%)</option>
				
				<option value="file8">github.com/GGPrompts/tfe/main.go (0.0%)</option>
				
				<option value="file9">github.com/GGPrompts/tfe/model.go (0.0%)</option>
				
				<option value="file10">github.com/GGPrompts/tfe/prompt_parser.go (0.0%)</option>
				
				<option value="file11">github.com/GGPrompts/tfe/render_file_list.go (0.0%)</option>
				
				<option value="file12">github.com/GGPrompts/tfe/render_preview.go (0.0%)</option>
				
				<option value="file13">github.com/GGPrompts/tfe/trash.go (77.0%)</option>
				
				<option value="file14">github.com/GGPrompts/tfe/types.go (0.0%)</option>
				
				<option value="file15">github.com/GGPrompts/tfe/update.go (0.0%)</option>
				
				<option value="file16">github.com/GGPrompts/tfe/update_keyboard.go (0.0%)</option>
				
				<option value="file17">github.com/GGPrompts/tfe/update_mouse.go (0.0%)</option>
				
				<option value="file18">github.com/GGPrompts/tfe/view.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

// Module: command.go
// Purpose: Command prompt functionality for executing shell commands
// Responsibilities:
// - Execute shell commands in the current directory context
// - Handle command completion and results
// - Manage command history (optional)

import (
        "fmt"
        "os"
        "os/exec"
        "strings"

        tea "github.com/charmbracelet/bubbletea"
)

// commandFinishedMsg is sent when a command execution completes
type commandFinishedMsg struct {
        err error
}

// runCommand executes a shell command in the specified directory
// It suspends the TFE UI, runs the command, then resumes
// Similar to Midnight Commander's "pause after run" feature:
// 1. Echo the command that was typed
// 2. Execute the command and show output
// 3. Wait for user to press a key before returning
func runCommand(command, dir string) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                // Build a shell script that:
                // 1. Echoes the command being run
                // 2. Executes the command
                // 3. Prompts user to press any key to continue
                // Note: Use bash instead of sh for better read support
                script := fmt.Sprintf(`
echo "$ %s"
cd %s || exit 1
%s
echo ""
echo "Press any key to continue..."
read -n 1 -s -r
`, shellQuote(command), shellQuote(dir), command)

                // Create the command using bash for better compatibility with read -n
                c := exec.Command("bash", "-c", script)
                c.Stdin = os.Stdin
                c.Stdout = os.Stdout
                c.Stderr = os.Stderr

                // Execute the command and restore the terminal
                return tea.Sequence(
                        tea.ClearScreen,
                        tea.ExecProcess(c, func(err error) tea.Msg </span><span class="cov0" title="0">{
                                return commandFinishedMsg{err: err}
                        }</span>),
                )()
        }
}

// addToHistory adds a command to the history, avoiding duplicates
func (m *model) addToHistory(command string) <span class="cov0" title="0">{
        if command == "" </span><span class="cov0" title="0">{
                return
        }</span>

        // Remove duplicate if it exists
        <span class="cov0" title="0">for i, cmd := range m.commandHistory </span><span class="cov0" title="0">{
                if cmd == command </span><span class="cov0" title="0">{
                        m.commandHistory = append(m.commandHistory[:i], m.commandHistory[i+1:]...)
                        break</span>
                }
        }

        // Add to end of history
        <span class="cov0" title="0">m.commandHistory = append(m.commandHistory, command)

        // Limit history to 100 commands
        if len(m.commandHistory) &gt; 100 </span><span class="cov0" title="0">{
                m.commandHistory = m.commandHistory[1:]
        }</span>

        // Reset history position
        <span class="cov0" title="0">m.historyPos = len(m.commandHistory)</span>
}

// getPreviousCommand navigates backward in command history
func (m *model) getPreviousCommand() string <span class="cov0" title="0">{
        if len(m.commandHistory) == 0 </span><span class="cov0" title="0">{
                return m.commandInput
        }</span>

        <span class="cov0" title="0">if m.historyPos &gt; 0 </span><span class="cov0" title="0">{
                m.historyPos--
        }</span>

        <span class="cov0" title="0">if m.historyPos &lt; len(m.commandHistory) </span><span class="cov0" title="0">{
                return m.commandHistory[m.historyPos]
        }</span>

        <span class="cov0" title="0">return ""</span>
}

// getNextCommand navigates forward in command history
func (m *model) getNextCommand() string <span class="cov0" title="0">{
        if len(m.commandHistory) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">if m.historyPos &lt; len(m.commandHistory)-1 </span><span class="cov0" title="0">{
                m.historyPos++
                return m.commandHistory[m.historyPos]
        }</span>

        // At the end of history, return empty string
        <span class="cov0" title="0">m.historyPos = len(m.commandHistory)
        return ""</span>
}

// runScript executes a script file safely without command injection
// Similar to runCommand but for executing script files directly
func runScript(scriptPath string) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                // Create a wrapper script that:
                // 1. Shows the script being executed
                // 2. Runs the script
                // 3. Pauses for user input
                wrapperScript := `
echo "$ bash $0"
echo ""
bash "$0"
exitCode=$?
echo ""
echo "Exit code: $exitCode"
echo "Press any key to continue..."
read -n 1 -s -r
exit $exitCode
`
                // Execute bash with the wrapper script and pass scriptPath as $0
                c := exec.Command("bash", "-c", wrapperScript, scriptPath)
                c.Stdin = os.Stdin
                c.Stdout = os.Stdout
                c.Stderr = os.Stderr

                // Execute the command and restore the terminal
                return tea.Sequence(
                        tea.ClearScreen,
                        tea.ExecProcess(c, func(err error) tea.Msg </span><span class="cov0" title="0">{
                                return commandFinishedMsg{err: err}
                        }</span>),
                )()
        }
}

// shellQuote quotes a string for safe use in shell commands
// Simple version that escapes single quotes
func shellQuote(s string) string <span class="cov0" title="0">{
        // Replace single quotes with '\'' (end quote, escaped quote, start quote)
        s = strings.ReplaceAll(s, "'", "'\\''")
        return "'" + s + "'"
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

// Module: context_menu.go
// Purpose: Right-click context menu functionality
// Responsibilities:
// - Menu item definitions
// - Menu action execution
// - Menu rendering

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "github.com/charmbracelet/lipgloss"
        tea "github.com/charmbracelet/bubbletea"
)

// contextMenuItem represents an item in the context menu
type contextMenuItem struct {
        label  string
        action string
}

// writeCDTarget writes the target directory to a file so the shell can cd after TFE exits
func writeCDTarget(path string) error <span class="cov0" title="0">{
        homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">targetFile := filepath.Join(homeDir, ".tfe_cd_target")
        return os.WriteFile(targetFile, []byte(path), 0644)</span>
}

// getContextMenuItems returns the list of menu items for the current file
func (m model) getContextMenuItems() []contextMenuItem <span class="cov0" title="0">{
        if m.contextMenuFile == nil </span><span class="cov0" title="0">{
                return []contextMenuItem{}
        }</span>

        <span class="cov0" title="0">items := []contextMenuItem{}

        // Special menu for trash view
        if m.showTrashOnly </span><span class="cov0" title="0">{
                items = append(items, contextMenuItem{"♻️  Restore", "restore"})
                items = append(items, contextMenuItem{"🗑️  Delete Permanently", "permanent_delete"})
                items = append(items, contextMenuItem{"─────────", "separator"})
                items = append(items, contextMenuItem{"🧹 Empty Trash", "empty_trash"})
                return items
        }</span>

        <span class="cov0" title="0">if m.contextMenuFile.isDir </span><span class="cov0" title="0">{
                // Directory menu items
                items = append(items, contextMenuItem{"📂 Open", "open"})
                items = append(items, contextMenuItem{"📂 Quick CD", "quickcd"})
                items = append(items, contextMenuItem{"📁 New Folder...", "newfolder"})
                items = append(items, contextMenuItem{"📄 New File...", "newfile"})
                items = append(items, contextMenuItem{"📋 Copy Path", "copypath"})

                // Add separator and TUI tools if available
                hasTools := false
                if editorAvailable("lazygit") </span><span class="cov0" title="0">{
                        if !hasTools </span><span class="cov0" title="0">{
                                items = append(items, contextMenuItem{"─────────", "separator"})
                                hasTools = true
                        }</span>
                        <span class="cov0" title="0">items = append(items, contextMenuItem{"🌿 Git (lazygit)", "lazygit"})</span>
                }
                <span class="cov0" title="0">if editorAvailable("lazydocker") </span><span class="cov0" title="0">{
                        if !hasTools </span><span class="cov0" title="0">{
                                items = append(items, contextMenuItem{"─────────", "separator"})
                                hasTools = true
                        }</span>
                        <span class="cov0" title="0">items = append(items, contextMenuItem{"🐋 Docker (lazydocker)", "lazydocker"})</span>
                }
                <span class="cov0" title="0">if editorAvailable("lnav") </span><span class="cov0" title="0">{
                        if !hasTools </span><span class="cov0" title="0">{
                                items = append(items, contextMenuItem{"─────────", "separator"})
                                hasTools = true
                        }</span>
                        <span class="cov0" title="0">items = append(items, contextMenuItem{"📜 Logs (lnav)", "lnav"})</span>
                }
                <span class="cov0" title="0">if editorAvailable("htop") </span><span class="cov0" title="0">{
                        if !hasTools </span><span class="cov0" title="0">{
                                items = append(items, contextMenuItem{"─────────", "separator"})
                                hasTools = true
                        }</span>
                        <span class="cov0" title="0">items = append(items, contextMenuItem{"📊 Processes (htop)", "htop"})</span>
                }

                // Add separator and favorites
                <span class="cov0" title="0">items = append(items, contextMenuItem{"─────────", "separator"})
                items = append(items, contextMenuItem{"🗑️  Delete", "delete"})
                if m.isFavorite(m.contextMenuFile.path) </span><span class="cov0" title="0">{
                        items = append(items, contextMenuItem{"⭐ Unfavorite", "togglefav"})
                }</span> else<span class="cov0" title="0"> {
                        items = append(items, contextMenuItem{"☆ Add Favorite", "togglefav"})
                }</span>
        } else<span class="cov0" title="0"> {
                // File menu items
                items = append(items, contextMenuItem{"👁  Preview", "preview"})

                // Add "Open in Browser" for images and HTML files
                if isBrowserFile(m.contextMenuFile.path) </span><span class="cov0" title="0">{
                        items = append(items, contextMenuItem{"🌐 Open in Browser", "browser"})
                }</span>

                <span class="cov0" title="0">items = append(items, contextMenuItem{"✏  Edit", "edit"})

                // Add "Run Script" for executable files
                if isExecutableFile(*m.contextMenuFile) </span><span class="cov0" title="0">{
                        items = append(items, contextMenuItem{"▶️  Run Script", "runscript"})
                }</span>

                <span class="cov0" title="0">items = append(items, contextMenuItem{"📋 Copy Path", "copypath"})
                items = append(items, contextMenuItem{"🗑️  Delete", "delete"})
                if m.isFavorite(m.contextMenuFile.path) </span><span class="cov0" title="0">{
                        items = append(items, contextMenuItem{"⭐ Unfavorite", "togglefav"})
                }</span> else<span class="cov0" title="0"> {
                        items = append(items, contextMenuItem{"☆ Add Favorite", "togglefav"})
                }</span>
        }

        <span class="cov0" title="0">return items</span>
}

// executeContextMenuAction executes the action for the currently selected menu item
func (m model) executeContextMenuAction() (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        if m.contextMenuFile == nil </span><span class="cov0" title="0">{
                m.contextMenuOpen = false
                return m, nil
        }</span>

        <span class="cov0" title="0">items := m.getContextMenuItems()
        if m.contextMenuCursor &gt;= len(items) </span><span class="cov0" title="0">{
                m.contextMenuOpen = false
                return m, nil
        }</span>

        <span class="cov0" title="0">action := items[m.contextMenuCursor].action

        // Close menu
        m.contextMenuOpen = false

        // Execute action
        switch action </span>{
        case "open":<span class="cov0" title="0">
                // Navigate into directory
                if m.contextMenuFile.isDir </span><span class="cov0" title="0">{
                        m.currentPath = m.contextMenuFile.path
                        m.cursor = 0
                        m.loadFiles()
                }</span>
                <span class="cov0" title="0">return m, tea.ClearScreen</span>

        case "quickcd":<span class="cov0" title="0">
                // Quick CD: write directory to file and exit TFE so shell can cd
                if m.contextMenuFile.isDir </span><span class="cov0" title="0">{
                        if err := writeCDTarget(m.contextMenuFile.path); err != nil </span><span class="cov0" title="0">{
                                m.setStatusMessage(fmt.Sprintf("Failed to save directory for quick CD: %s", err), true)
                                return m, tea.ClearScreen
                        }</span>
                        <span class="cov0" title="0">return m, tea.Quit</span>
                }
                <span class="cov0" title="0">return m, tea.ClearScreen</span>

        case "preview":<span class="cov0" title="0">
                // Preview file
                if !m.contextMenuFile.isDir </span><span class="cov0" title="0">{
                        m.loadPreview(m.contextMenuFile.path)
                        m.viewMode = viewFullPreview
                        m.calculateLayout() // Update widths for full-screen
                        m.populatePreviewCache() // Repopulate cache with correct width
                        // Disable mouse to allow text selection
                        return m, tea.Batch(tea.ClearScreen, func() tea.Msg </span><span class="cov0" title="0">{ return tea.DisableMouse() }</span>)
                }
                <span class="cov0" title="0">return m, tea.ClearScreen</span>

        case "browser":<span class="cov0" title="0">
                // Open in browser (images/HTML)
                if !m.contextMenuFile.isDir </span><span class="cov0" title="0">{
                        return m, openInBrowser(m.contextMenuFile.path)
                }</span>
                <span class="cov0" title="0">return m, tea.ClearScreen</span>

        case "edit":<span class="cov0" title="0">
                // Edit file
                if !m.contextMenuFile.isDir </span><span class="cov0" title="0">{
                        editor := getAvailableEditor()
                        if editor == "" </span><span class="cov0" title="0">{
                                m.setStatusMessage("No editor available (tried micro, nano, vim, vi)", true)
                                return m, tea.ClearScreen
                        }</span>
                        <span class="cov0" title="0">if editorAvailable("micro") </span><span class="cov0" title="0">{
                                editor = "micro"
                        }</span>
                        <span class="cov0" title="0">return m, openEditor(editor, m.contextMenuFile.path)</span>
                }
                <span class="cov0" title="0">return m, tea.ClearScreen</span>

        case "runscript":<span class="cov0" title="0">
                // Run executable script
                if !m.contextMenuFile.isDir &amp;&amp; isExecutableFile(*m.contextMenuFile) </span><span class="cov0" title="0">{
                        // Use bash to run the script safely (no command injection)
                        scriptPath := m.contextMenuFile.path
                        return m, runScript(scriptPath)
                }</span>
                <span class="cov0" title="0">return m, tea.ClearScreen</span>

        case "copypath":<span class="cov0" title="0">
                // Copy path to clipboard
                if err := copyToClipboard(m.contextMenuFile.path); err != nil </span><span class="cov0" title="0">{
                        m.setStatusMessage(fmt.Sprintf("Failed to copy to clipboard: %s", err), true)
                }</span> else<span class="cov0" title="0"> {
                        m.setStatusMessage("Path copied to clipboard", false)
                }</span>
                <span class="cov0" title="0">return m, tea.ClearScreen</span>

        case "togglefav":<span class="cov0" title="0">
                // Toggle favorite
                m.toggleFavorite(m.contextMenuFile.path)
                return m, tea.ClearScreen</span>

        case "separator":<span class="cov0" title="0">
                // Separator is not selectable - shouldn't happen but handle gracefully
                return m, tea.ClearScreen</span>

        case "lazygit":<span class="cov0" title="0">
                // Launch lazygit in the selected directory
                if m.contextMenuFile.isDir </span><span class="cov0" title="0">{
                        return m, openTUITool("lazygit", m.contextMenuFile.path)
                }</span>
                <span class="cov0" title="0">return m, tea.ClearScreen</span>

        case "lazydocker":<span class="cov0" title="0">
                // Launch lazydocker in the selected directory
                if m.contextMenuFile.isDir </span><span class="cov0" title="0">{
                        return m, openTUITool("lazydocker", m.contextMenuFile.path)
                }</span>
                <span class="cov0" title="0">return m, tea.ClearScreen</span>

        case "lnav":<span class="cov0" title="0">
                // Launch lnav in the selected directory
                if m.contextMenuFile.isDir </span><span class="cov0" title="0">{
                        return m, openTUITool("lnav", m.contextMenuFile.path)
                }</span>
                <span class="cov0" title="0">return m, tea.ClearScreen</span>

        case "htop":<span class="cov0" title="0">
                // Launch htop (doesn't need directory context but launch from directory anyway)
                if m.contextMenuFile.isDir </span><span class="cov0" title="0">{
                        return m, openTUITool("htop", m.contextMenuFile.path)
                }</span>
                <span class="cov0" title="0">return m, tea.ClearScreen</span>

        case "newfolder":<span class="cov0" title="0">
                // Create new folder in the selected directory
                if m.contextMenuFile.isDir </span><span class="cov0" title="0">{
                        // Navigate to the directory first
                        m.currentPath = m.contextMenuFile.path
                        m.cursor = 0
                        m.loadFiles()

                        // Show input dialog for folder name
                        m.dialog = dialogModel{
                                dialogType: dialogInput,
                                title:      "Create Directory",
                                message:    "Enter directory name:",
                                input:      "",
                        }
                        m.showDialog = true
                }</span>
                <span class="cov0" title="0">return m, tea.ClearScreen</span>

        case "newfile":<span class="cov0" title="0">
                // Create new file in the selected directory
                if m.contextMenuFile.isDir </span><span class="cov0" title="0">{
                        // Navigate to the directory first
                        m.currentPath = m.contextMenuFile.path
                        m.cursor = 0
                        m.loadFiles()

                        // Show input dialog for file name
                        m.dialog = dialogModel{
                                dialogType: dialogInput,
                                title:      "Create File",
                                message:    "Enter filename:",
                                input:      "",
                        }
                        m.showDialog = true
                }</span>
                <span class="cov0" title="0">return m, tea.ClearScreen</span>

        case "restore":<span class="cov0" title="0">
                // Restore item from trash
                if err := restoreFromTrash(m.contextMenuFile.path); err != nil </span><span class="cov0" title="0">{
                        m.setStatusMessage(fmt.Sprintf("Failed to restore: %s", err), true)
                }</span> else<span class="cov0" title="0"> {
                        m.setStatusMessage("Item restored successfully", false)
                        m.loadFiles() // Refresh trash view
                }</span>
                <span class="cov0" title="0">return m, tea.ClearScreen</span>

        case "permanent_delete":<span class="cov0" title="0">
                // Permanently delete item from trash
                m.dialog = dialogModel{
                        dialogType: dialogConfirm,
                        title:      "Permanently Delete",
                        message:    fmt.Sprintf("Permanently delete '%s'?\nThis CANNOT be undone!", m.contextMenuFile.name),
                }
                m.showDialog = true
                return m, tea.ClearScreen</span>

        case "empty_trash":<span class="cov0" title="0">
                // Empty entire trash
                m.dialog = dialogModel{
                        dialogType: dialogConfirm,
                        title:      "Empty Trash",
                        message:    "Permanently delete ALL items in trash?\nThis CANNOT be undone!",
                }
                m.showDialog = true
                return m, tea.ClearScreen</span>

        case "delete":<span class="cov0" title="0">
                // Delete the selected file or folder (move to trash)
                m.dialog = dialogModel{
                        dialogType: dialogConfirm,
                        title:      "Move to Trash",
                        message:    fmt.Sprintf("Move '%s' to trash?", m.contextMenuFile.name),
                }
                m.showDialog = true
                return m, tea.ClearScreen</span>
        }

        <span class="cov0" title="0">return m, tea.ClearScreen</span>
}

// renderContextMenu renders the context menu at the stored position
func (m model) renderContextMenu() string <span class="cov0" title="0">{
        if !m.contextMenuOpen || m.contextMenuFile == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">items := m.getContextMenuItems()
        if len(items) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Calculate menu dimensions - make it wider to ensure full coverage
        <span class="cov0" title="0">maxWidth := 0
        for _, item := range items </span><span class="cov0" title="0">{
                // Use visual width (accounting for emoji)
                width := visualWidth(item.label)
                if width &gt; maxWidth </span><span class="cov0" title="0">{
                        maxWidth = width
                }</span>
        }
        // Content width (without borders/padding)
        <span class="cov0" title="0">contentWidth := maxWidth + 4 // Add internal spacing

        // Build menu content with consistent width
        var menuLines []string
        for i, item := range items </span><span class="cov0" title="0">{
                var line string

                // Style separators differently
                if item.action == "separator" </span><span class="cov0" title="0">{
                        // Separator: dim color, not selectable
                        separatorStyle := lipgloss.NewStyle().
                                Background(lipgloss.Color("236")).
                                Foreground(lipgloss.Color("240")).
                                Width(contentWidth)
                        line = separatorStyle.Render(fmt.Sprintf("  %s  ", item.label))
                }</span> else<span class="cov0" title="0"> if i == m.contextMenuCursor </span><span class="cov0" title="0">{
                        // Highlighted selected item
                        selectedStyle := lipgloss.NewStyle().
                                Background(lipgloss.Color("39")).
                                Foreground(lipgloss.Color("0")).
                                Bold(true).
                                Width(contentWidth)
                        line = selectedStyle.Render(fmt.Sprintf("  %s  ", item.label))
                }</span> else<span class="cov0" title="0"> {
                        // Normal items also need a background to cover underlying text
                        normalStyle := lipgloss.NewStyle().
                                Background(lipgloss.Color("236")).
                                Foreground(lipgloss.Color("252")).
                                Width(contentWidth)
                        line = normalStyle.Render(fmt.Sprintf("  %s  ", item.label))
                }</span>
                <span class="cov0" title="0">menuLines = append(menuLines, line)</span>
        }

        // Create menu box - don't set width here, let it fit the content
        <span class="cov0" title="0">menuContent := strings.Join(menuLines, "\n")

        // Apply border and background
        menuStyle := lipgloss.NewStyle().
                BorderStyle(lipgloss.RoundedBorder()).
                BorderForeground(lipgloss.Color("39")).
                BorderBackground(lipgloss.Color("236")).  // Background for border area
                Background(lipgloss.Color("236"))         // Background for content area

        return menuStyle.Render(menuContent)</span>
}

// isExecutableFile checks if a file is executable (has execute permission or is a shell script)
func isExecutableFile(file fileItem) bool <span class="cov0" title="0">{
        // Check file extension for common script types
        ext := strings.ToLower(filepath.Ext(file.path))
        if ext == ".sh" || ext == ".bash" || ext == ".zsh" || ext == ".fish" </span><span class="cov0" title="0">{
                return true
        }</span>

        // Check if file has execute permission
        // The mode contains permission bits - check if any execute bit is set
        // 0111 = user, group, or other has execute permission
        <span class="cov0" title="0">if file.mode&amp;0111 != 0 </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "strings"

        "github.com/charmbracelet/lipgloss"
)

// renderDialog renders a dialog overlay centered on screen
func (m model) renderDialog() string <span class="cov0" title="0">{
        switch m.dialog.dialogType </span>{
        case dialogInput:<span class="cov0" title="0">
                return m.renderInputDialog()</span>
        case dialogConfirm:<span class="cov0" title="0">
                return m.renderConfirmDialog()</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}

// renderInputDialog renders a text input dialog
func (m model) renderInputDialog() string <span class="cov0" title="0">{
        // Calculate dialog dimensions
        width := 50
        if width &gt; m.width-4 </span><span class="cov0" title="0">{
                width = m.width - 4
        }</span>

        // Dialog styles
        <span class="cov0" title="0">borderStyle := lipgloss.NewStyle().
                Border(lipgloss.RoundedBorder()).
                BorderForeground(lipgloss.Color("39")).
                Padding(1, 2).
                Width(width)

        titleStyle := lipgloss.NewStyle().
                Bold(true).
                Foreground(lipgloss.Color("39")).
                Align(lipgloss.Center).
                Width(width)

        inputStyle := lipgloss.NewStyle().
                Foreground(lipgloss.Color("252")).
                Background(lipgloss.Color("235")).
                Padding(0, 1).
                Width(width - 4)

        hintStyle := lipgloss.NewStyle().
                Foreground(lipgloss.Color("240")).
                Align(lipgloss.Center).
                Width(width)

        // Build dialog content
        var content strings.Builder
        content.WriteString(titleStyle.Render(m.dialog.title))
        content.WriteString("\n\n")
        if m.dialog.message != "" </span><span class="cov0" title="0">{
                content.WriteString(m.dialog.message)
                content.WriteString("\n\n")
        }</span>
        <span class="cov0" title="0">content.WriteString(inputStyle.Render(m.dialog.input + "█"))
        content.WriteString("\n\n")
        content.WriteString(hintStyle.Render("Enter: confirm | Esc: cancel"))

        return borderStyle.Render(content.String())</span>
}

// renderConfirmDialog renders a yes/no confirmation dialog
func (m model) renderConfirmDialog() string <span class="cov0" title="0">{
        // Calculate dialog dimensions
        width := 50
        if width &gt; m.width-4 </span><span class="cov0" title="0">{
                width = m.width - 4
        }</span>

        // Dialog styles
        <span class="cov0" title="0">borderStyle := lipgloss.NewStyle().
                Border(lipgloss.RoundedBorder()).
                BorderForeground(lipgloss.Color("196")). // Red for warnings
                Padding(1, 2).
                Width(width)

        titleStyle := lipgloss.NewStyle().
                Bold(true).
                Foreground(lipgloss.Color("196")).
                Align(lipgloss.Center).
                Width(width)

        messageStyle := lipgloss.NewStyle().
                Foreground(lipgloss.Color("252")).
                Width(width)

        hintStyle := lipgloss.NewStyle().
                Foreground(lipgloss.Color("240")).
                Align(lipgloss.Center).
                Width(width)

        // Build dialog content
        var content strings.Builder
        content.WriteString(titleStyle.Render(m.dialog.title))
        content.WriteString("\n\n")
        content.WriteString(messageStyle.Render(m.dialog.message))
        content.WriteString("\n\n")
        content.WriteString(hintStyle.Render("[Y]es / [N]o / [Esc]"))

        return borderStyle.Render(content.String())</span>
}

// getDialogPosition calculates centered position for dialog
func (m model) getDialogPosition() (int, int) <span class="cov0" title="0">{
        // Rough estimate: dialog is about 50 chars wide, 10 lines tall
        dialogWidth := 54  // 50 + border
        dialogHeight := 10 // Approximate

        x := (m.width - dialogWidth) / 2
        y := (m.height - dialogHeight) / 2

        if x &lt; 0 </span><span class="cov0" title="0">{
                x = 0
        }</span>
        <span class="cov0" title="0">if y &lt; 0 </span><span class="cov0" title="0">{
                y = 0
        }</span>

        <span class="cov0" title="0">return x, y</span>
}

// overlayDialog embeds the dialog into the base view at the centered position
// This approach works with Bubble Tea's diff-based rendering
func (m model) overlayDialog(baseView, dialogContent string) string <span class="cov0" title="0">{
        x, y := m.getDialogPosition()

        // Ensure dialog stays on screen with proper margins
        if x &lt; 1 </span><span class="cov0" title="0">{
                x = 1
        }</span>
        <span class="cov0" title="0">if y &lt; 1 </span><span class="cov0" title="0">{
                y = 1
        }</span>

        // Split both views into lines
        <span class="cov0" title="0">baseLines := strings.Split(baseView, "\n")
        dialogLines := strings.Split(strings.TrimSpace(dialogContent), "\n")

        // Ensure we have enough base lines
        for len(baseLines) &lt; m.height </span><span class="cov0" title="0">{
                baseLines = append(baseLines, "")
        }</span>

        // Overlay each dialog line onto the base view
        <span class="cov0" title="0">for i, dialogLine := range dialogLines </span><span class="cov0" title="0">{
                targetLine := y + i
                if targetLine &lt; 0 || targetLine &gt;= len(baseLines) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">baseLine := baseLines[targetLine]

                // We need to overlay dialogLine at visual column x
                // Use a string builder to construct the new line
                var newLine strings.Builder

                // Get the part of baseLine before position x
                // We need to handle ANSI codes properly
                visualPos := 0
                bytePos := 0
                inAnsi := false
                baseRunes := []rune(baseLine)

                // Scan through base line until we reach visual position x
                for bytePos &lt; len(baseRunes) &amp;&amp; visualPos &lt; x </span><span class="cov0" title="0">{
                        if baseRunes[bytePos] == '\033' </span><span class="cov0" title="0">{
                                inAnsi = true
                        }</span>

                        <span class="cov0" title="0">if inAnsi </span><span class="cov0" title="0">{
                                if baseRunes[bytePos] &gt;= 'A' &amp;&amp; baseRunes[bytePos] &lt;= 'Z' ||
                                        baseRunes[bytePos] &gt;= 'a' &amp;&amp; baseRunes[bytePos] &lt;= 'z' </span><span class="cov0" title="0">{
                                        inAnsi = false
                                }</span>
                        } else<span class="cov0" title="0"> {
                                visualPos++
                        }</span>
                        <span class="cov0" title="0">bytePos++</span>
                }

                // Add the left part of the base line (up to position x)
                <span class="cov0" title="0">if bytePos &gt; 0 &amp;&amp; bytePos &lt;= len(baseRunes) </span><span class="cov0" title="0">{
                        newLine.WriteString(string(baseRunes[:bytePos]))
                }</span>

                // Pad with spaces if needed to reach position x
                <span class="cov0" title="0">for visualPos &lt; x </span><span class="cov0" title="0">{
                        newLine.WriteRune(' ')
                        visualPos++
                }</span>

                // Add the dialog line
                <span class="cov0" title="0">newLine.WriteString(dialogLine)

                // Calculate where the dialog ends visually
                dialogWidth := visualWidth(dialogLine)
                endPos := x + dialogWidth

                // Preserve the rest of the base line after the dialog
                // Continue scanning from where we left off to find the visual end position
                for bytePos &lt; len(baseRunes) &amp;&amp; visualPos &lt; endPos </span><span class="cov0" title="0">{
                        if baseRunes[bytePos] == '\033' </span><span class="cov0" title="0">{
                                inAnsi = true
                        }</span>

                        <span class="cov0" title="0">if inAnsi </span><span class="cov0" title="0">{
                                if baseRunes[bytePos] &gt;= 'A' &amp;&amp; baseRunes[bytePos] &lt;= 'Z' ||
                                        baseRunes[bytePos] &gt;= 'a' &amp;&amp; baseRunes[bytePos] &lt;= 'z' </span><span class="cov0" title="0">{
                                        inAnsi = false
                                }</span>
                        } else<span class="cov0" title="0"> {
                                visualPos++
                        }</span>
                        <span class="cov0" title="0">bytePos++</span>
                }

                // Append the rest of the base line (everything after the dialog)
                <span class="cov0" title="0">if bytePos &lt; len(baseRunes) </span><span class="cov0" title="0">{
                        newLine.WriteString(string(baseRunes[bytePos:]))
                }</span>

                <span class="cov0" title="0">baseLines[targetLine] = newLine.String()</span>
        }

        <span class="cov0" title="0">return strings.Join(baseLines, "\n")</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "fmt"
        "os/exec"

        tea "github.com/charmbracelet/bubbletea"
)

// editorAvailable checks if an editor command is available
func editorAvailable(cmd string) bool <span class="cov0" title="0">{
        _, err := exec.LookPath(cmd)
        return err == nil
}</span>

// getAvailableEditor returns the first available editor
func getAvailableEditor() string <span class="cov0" title="0">{
        editors := []string{"micro", "nano", "vim", "vi"}
        for _, editor := range editors </span><span class="cov0" title="0">{
                if editorAvailable(editor) </span><span class="cov0" title="0">{
                        return editor
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

// openEditor opens a file in an external editor
func openEditor(editor, path string) tea.Cmd <span class="cov0" title="0">{
        c := exec.Command(editor, path)
        return tea.Sequence(
                tea.ClearScreen,
                tea.ExecProcess(c, func(err error) tea.Msg </span><span class="cov0" title="0">{
                        return editorFinishedMsg{err}
                }</span>),
        )
}

// openTUITool opens a TUI application in the specified directory
func openTUITool(tool, dir string) tea.Cmd <span class="cov0" title="0">{
        c := exec.Command(tool)
        c.Dir = dir // Set working directory
        return tea.Sequence(
                tea.ClearScreen,
                tea.ExecProcess(c, func(err error) tea.Msg </span><span class="cov0" title="0">{
                        return editorFinishedMsg{err}
                }</span>),
        )
}

// copyToClipboard copies text to the system clipboard
func copyToClipboard(text string) error <span class="cov0" title="0">{
        var cmd *exec.Cmd

        // Try different clipboard commands based on platform
        if editorAvailable("termux-clipboard-set") </span><span class="cov0" title="0">{
                // Termux (Android)
                cmd = exec.Command("termux-clipboard-set")
        }</span> else<span class="cov0" title="0"> if editorAvailable("xclip") </span><span class="cov0" title="0">{
                cmd = exec.Command("xclip", "-selection", "clipboard")
        }</span> else<span class="cov0" title="0"> if editorAvailable("xsel") </span><span class="cov0" title="0">{
                cmd = exec.Command("xsel", "--clipboard", "--input")
        }</span> else<span class="cov0" title="0"> if editorAvailable("pbcopy") </span><span class="cov0" title="0">{
                // macOS
                cmd = exec.Command("pbcopy")
        }</span> else<span class="cov0" title="0"> if editorAvailable("clip.exe") </span><span class="cov0" title="0">{
                // Windows/WSL
                cmd = exec.Command("clip.exe")
        }</span> else<span class="cov0" title="0"> {
                return fmt.Errorf("no clipboard utility found (install termux-api, xclip, xsel, or use WSL)")
        }</span>

        <span class="cov0" title="0">pipe, err := cmd.StdinPipe()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := cmd.Start(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if _, err := pipe.Write([]byte(text)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := pipe.Close(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return cmd.Wait()</span>
}

// isImageFile checks if a file is an image based on extension (case-insensitive)
func isImageFile(path string) bool <span class="cov0" title="0">{
        imageExts := []string{".png", ".jpg", ".jpeg", ".gif", ".bmp", ".svg", ".webp", ".ico", ".tiff", ".tif"}
        // Convert path to lowercase for case-insensitive comparison
        lowerPath := ""
        for _, ch := range path </span><span class="cov0" title="0">{
                if ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z' </span><span class="cov0" title="0">{
                        lowerPath += string(ch + 32)
                }</span> else<span class="cov0" title="0"> {
                        lowerPath += string(ch)
                }</span>
        }
        <span class="cov0" title="0">for _, ext := range imageExts </span><span class="cov0" title="0">{
                if len(lowerPath) &gt;= len(ext) &amp;&amp; lowerPath[len(lowerPath)-len(ext):] == ext </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// isHTMLFile checks if a file is an HTML file based on extension (case-insensitive)
func isHTMLFile(path string) bool <span class="cov0" title="0">{
        // Convert path to lowercase for case-insensitive comparison
        lowerPath := ""
        for _, ch := range path </span><span class="cov0" title="0">{
                if ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z' </span><span class="cov0" title="0">{
                        lowerPath += string(ch + 32)
                }</span> else<span class="cov0" title="0"> {
                        lowerPath += string(ch)
                }</span>
        }
        <span class="cov0" title="0">return len(lowerPath) &gt;= 5 &amp;&amp; (lowerPath[len(lowerPath)-5:] == ".html" || lowerPath[len(lowerPath)-4:] == ".htm")</span>
}

// isBrowserFile checks if a file should be opened in a browser
func isBrowserFile(path string) bool <span class="cov0" title="0">{
        return isImageFile(path) || isHTMLFile(path)
}</span>

// getAvailableBrowser returns the command to open files in the default browser
func getAvailableBrowser() string <span class="cov0" title="0">{
        // WSL - try wslview first (from wslu package), then use Windows commands
        if editorAvailable("wslview") </span><span class="cov0" title="0">{
                return "wslview"
        }</span>
        // Windows via WSL
        <span class="cov0" title="0">if editorAvailable("cmd.exe") </span><span class="cov0" title="0">{
                return "cmd.exe"
        }</span>
        // Linux - xdg-open is the standard
        <span class="cov0" title="0">if editorAvailable("xdg-open") </span><span class="cov0" title="0">{
                return "xdg-open"
        }</span>
        // macOS
        <span class="cov0" title="0">if editorAvailable("open") </span><span class="cov0" title="0">{
                return "open"
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// browserOpenedMsg is returned when a file is opened in browser
type browserOpenedMsg struct {
        success bool
        err     error
}

// openInBrowser opens a file in the default browser
func openInBrowser(path string) tea.Cmd <span class="cov0" title="0">{
        browser := getAvailableBrowser()
        if browser == "" </span><span class="cov0" title="0">{
                return func() tea.Msg </span><span class="cov0" title="0">{
                        return browserOpenedMsg{
                                success: false,
                                err:     fmt.Errorf("no browser command found (install xdg-open, wslview, or open)"),
                        }
                }</span>
        }

        <span class="cov0" title="0">return func() tea.Msg </span><span class="cov0" title="0">{
                var c *exec.Cmd
                if browser == "cmd.exe" </span><span class="cov0" title="0">{
                        // Windows via WSL - use cmd.exe /c start
                        c = exec.Command("cmd.exe", "/c", "start", path)
                }</span> else<span class="cov0" title="0"> {
                        // Linux/macOS/wslview
                        c = exec.Command(browser, path)
                }</span>

                // Start the browser without blocking (browsers run in background)
                <span class="cov0" title="0">err := c.Start()
                if err != nil </span><span class="cov0" title="0">{
                        return browserOpenedMsg{
                                success: false,
                                err:     err,
                        }
                }</span>

                // Success
                <span class="cov0" title="0">return browserOpenedMsg{
                        success: true,
                        err:     nil,
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

// Module: favorites.go
// Purpose: Favorites/bookmarks functionality for files and directories
// Responsibilities:
// - Loading and saving favorites from/to disk
// - Adding and removing favorites
// - Checking if a path is favorited

import (
        "encoding/json"
        "os"
        "path/filepath"
        "sort"
        "strings"
        "time"
)

// getFavoritesPath returns the path to the favorites file
func getFavoritesPath() string <span class="cov8" title="1">{
        home, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov8" title="1">configDir := filepath.Join(home, ".config", "tfe")
        // Create config directory if it doesn't exist
        os.MkdirAll(configDir, 0755)

        return filepath.Join(configDir, "favorites.json")</span>
}

// loadFavorites loads favorites from disk
func loadFavorites() map[string]bool <span class="cov8" title="1">{
        favorites := make(map[string]bool)

        path := getFavoritesPath()
        if path == "" </span><span class="cov0" title="0">{
                return favorites
        }</span>

        <span class="cov8" title="1">data, err := os.ReadFile(path)
        if err != nil </span><span class="cov8" title="1">{
                // File doesn't exist yet or can't be read - return empty map
                return favorites
        }</span>

        // Unmarshal JSON array of paths
        <span class="cov8" title="1">var paths []string
        if err := json.Unmarshal(data, &amp;paths); err != nil </span><span class="cov8" title="1">{
                return favorites
        }</span>

        // Convert to map for faster lookups
        <span class="cov8" title="1">for _, p := range paths </span><span class="cov8" title="1">{
                favorites[p] = true
        }</span>

        <span class="cov8" title="1">return favorites</span>
}

// saveFavorites saves favorites to disk
func saveFavorites(favorites map[string]bool) error <span class="cov8" title="1">{
        path := getFavoritesPath()
        if path == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Convert map to array for JSON
        <span class="cov8" title="1">paths := make([]string, 0, len(favorites))
        for p := range favorites </span><span class="cov8" title="1">{
                paths = append(paths, p)
        }</span>

        // Marshal to JSON
        <span class="cov8" title="1">data, err := json.MarshalIndent(paths, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Write to file
        <span class="cov8" title="1">return os.WriteFile(path, data, 0644)</span>
}

// toggleFavorite adds or removes a path from favorites
func (m *model) toggleFavorite(path string) <span class="cov8" title="1">{
        if m.favorites[path] </span><span class="cov8" title="1">{
                // Remove from favorites
                delete(m.favorites, path)
        }</span> else<span class="cov8" title="1"> {
                // Add to favorites
                m.favorites[path] = true
        }</span>

        // Save to disk
        <span class="cov8" title="1">saveFavorites(m.favorites)</span>
}

// isFavorite checks if a path is favorited
func (m *model) isFavorite(path string) bool <span class="cov8" title="1">{
        return m.favorites[path]
}</span>

// directoryContainsPrompts checks if a directory contains any prompt files (recursively, up to 2 levels deep)
func directoryContainsPrompts(dirPath string) bool <span class="cov8" title="1">{
        return checkForPromptsRecursive(dirPath, 0, 2)
}</span>

// checkForPromptsRecursive recursively checks for prompt files up to maxDepth levels
func checkForPromptsRecursive(dirPath string, currentDepth, maxDepth int) bool <span class="cov8" title="1">{
        if currentDepth &gt; maxDepth </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">entries, err := os.ReadDir(dirPath)
        if err != nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">for _, entry := range entries </span><span class="cov8" title="1">{
                // Skip hidden files/folders (except important ones)
                if strings.HasPrefix(entry.Name(), ".") </span><span class="cov8" title="1">{
                        importantFolders := []string{".claude", ".prompts"}
                        isImportant := false
                        for _, folder := range importantFolders </span><span class="cov8" title="1">{
                                if entry.Name() == folder </span><span class="cov8" title="1">{
                                        isImportant = true
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if !isImportant </span><span class="cov8" title="1">{
                                continue</span>
                        }
                }

                <span class="cov8" title="1">fullPath := filepath.Join(dirPath, entry.Name())

                if entry.IsDir() </span><span class="cov8" title="1">{
                        // Recursively check subdirectories
                        if checkForPromptsRecursive(fullPath, currentDepth+1, maxDepth) </span><span class="cov8" title="1">{
                                return true
                        }</span>
                } else<span class="cov8" title="1"> {
                        // Check if this file is a prompt file
                        item := fileItem{
                                name:  entry.Name(),
                                path:  fullPath,
                                isDir: false,
                        }
                        if isPromptFile(item) </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
        }

        <span class="cov8" title="1">return false</span>
}

// getFilteredFiles returns files filtered by current filter mode
// Search filtering takes precedence over favorites and prompts filtering
func (m *model) getFilteredFiles() []fileItem <span class="cov8" title="1">{
        // If search is active, use filtered indices
        if len(m.filteredIndices) &gt; 0 </span><span class="cov0" title="0">{
                filtered := make([]fileItem, 0, len(m.filteredIndices))
                for _, idx := range m.filteredIndices </span><span class="cov0" title="0">{
                        if idx &lt; len(m.files) </span><span class="cov0" title="0">{
                                filtered = append(filtered, m.files[idx])
                        }</span>
                }
                <span class="cov0" title="0">return filtered</span>
        }

        // Apply prompts filtering (show only .yaml, .md, .txt files)
        <span class="cov8" title="1">if m.showPromptsOnly </span><span class="cov0" title="0">{
                filtered := make([]fileItem, 0)

                // Add global prompts section at the top (if not already in ~/.prompts/)
                homeDir, err := os.UserHomeDir()
                if err == nil </span><span class="cov0" title="0">{
                        globalPromptsDir := filepath.Join(homeDir, ".prompts")
                        // Only show if we're not already in ~/.prompts/
                        if m.currentPath != globalPromptsDir &amp;&amp; !strings.HasPrefix(m.currentPath, globalPromptsDir+string(filepath.Separator)) </span><span class="cov0" title="0">{
                                // Check if ~/.prompts/ exists
                                if info, err := os.Stat(globalPromptsDir); err == nil &amp;&amp; info.IsDir() </span><span class="cov0" title="0">{
                                        // Create a virtual folder item for ~/.prompts/
                                        globalPromptsItem := fileItem{
                                                name:    "🌐 ~/.prompts/ (Global Prompts)",
                                                path:    globalPromptsDir,
                                                isDir:   true,
                                                size:    info.Size(),
                                                modTime: info.ModTime(),
                                                mode:    info.Mode(),
                                        }
                                        filtered = append(filtered, globalPromptsItem)
                                }</span> else<span class="cov0" title="0"> {
                                        // ~/.prompts doesn't exist - show helper to create it
                                        helperItem := fileItem{
                                                name:    "💡 Setup: Create ~/.prompts/ for global prompts (press Enter)",
                                                path:    globalPromptsDir, // Use the path we want to create
                                                isDir:   true,
                                                size:    0,
                                                modTime: time.Now(),
                                                mode:    0755,
                                        }
                                        filtered = append(filtered, helperItem)
                                }</span>
                        }
                }

                <span class="cov0" title="0">for _, item := range m.files </span><span class="cov0" title="0">{
                        if item.isDir </span><span class="cov0" title="0">{
                                // Always include ".." for navigation
                                if item.name == ".." </span><span class="cov0" title="0">{
                                        filtered = append(filtered, item)
                                        continue</span>
                                }

                                // Always include important dev folders
                                <span class="cov0" title="0">importantFolders := []string{".claude", ".prompts", ".config"}
                                isImportant := false
                                for _, folder := range importantFolders </span><span class="cov0" title="0">{
                                        if item.name == folder </span><span class="cov0" title="0">{
                                                isImportant = true
                                                break</span>
                                        }
                                }
                                <span class="cov0" title="0">if isImportant </span><span class="cov0" title="0">{
                                        filtered = append(filtered, item)
                                        continue</span>
                                }

                                // Include directory if it contains prompt files
                                <span class="cov0" title="0">if directoryContainsPrompts(item.path) </span><span class="cov0" title="0">{
                                        filtered = append(filtered, item)
                                }</span>
                        } else<span class="cov0" title="0"> if isPromptFile(item) </span><span class="cov0" title="0">{
                                filtered = append(filtered, item)
                        }</span>
                }
                <span class="cov0" title="0">return filtered</span>
        }

        // Otherwise, apply favorites filtering
        <span class="cov8" title="1">if !m.showFavoritesOnly </span><span class="cov8" title="1">{
                return m.files
        }</span>

        // Show ALL favorites from anywhere in filesystem
        <span class="cov8" title="1">filtered := make([]fileItem, 0)

        // Don't include ".." when viewing favorites from multiple locations
        // (it doesn't make sense since favorites can be from anywhere)

        // Collect all favorite paths into a slice for sorting
        favPaths := make([]string, 0, len(m.favorites))
        for favPath := range m.favorites </span><span class="cov8" title="1">{
                favPaths = append(favPaths, favPath)
        }</span>

        // Sort paths alphabetically for consistent ordering
        <span class="cov8" title="1">sort.Strings(favPaths)

        // Add all favorited paths as fileItems in sorted order
        for _, favPath := range favPaths </span><span class="cov8" title="1">{
                // Get file info for this favorite
                info, err := os.Stat(favPath)
                if err != nil </span><span class="cov0" title="0">{
                        // File no longer exists, skip it
                        continue</span>
                }

                // Create fileItem from the favorite path
                <span class="cov8" title="1">item := fileItem{
                        name:    filepath.Base(favPath),
                        path:    favPath,
                        isDir:   info.IsDir(),
                        size:    info.Size(),
                        modTime: info.ModTime(),
                        mode:    info.Mode(),
                }
                filtered = append(filtered, item)</span>
        }

        <span class="cov8" title="1">return filtered</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package main

import (
        "bytes"
        "fmt"
        "os"
        "path/filepath"
        "sort"
        "strings"
        "time"

        "github.com/alecthomas/chroma/v2"
        "github.com/alecthomas/chroma/v2/formatters"
        "github.com/alecthomas/chroma/v2/lexers"
        "github.com/alecthomas/chroma/v2/styles"
        tea "github.com/charmbracelet/bubbletea"
        "github.com/charmbracelet/glamour"
)

// isClaudeContextFile checks if a file/folder is automatically loaded by Claude Code
func isClaudeContextFile(name string) bool <span class="cov8" title="1">{
        // Files that Claude Code automatically loads into context
        claudeFiles := []string{
                "CLAUDE.md",
                "CLAUDE.local.md",
                ".claude",
        }

        for _, cf := range claudeFiles </span><span class="cov8" title="1">{
                if name == cf </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

// isAgentsFile checks if a file is AGENTS.md (agent configuration/documentation)
func isAgentsFile(name string) bool <span class="cov8" title="1">{
        return name == "AGENTS.md"
}</span>

// isPromptsFolder checks if a folder is the .prompts directory
func isPromptsFolder(name string) bool <span class="cov8" title="1">{
        return name == ".prompts"
}</span>

// isGlobalPromptsVirtualFolder checks if this is the virtual "🌐 ~/.prompts/" folder
func isGlobalPromptsVirtualFolder(name string) bool <span class="cov8" title="1">{
        return strings.HasPrefix(name, "🌐 ~/.prompts/")
}</span>

// isClaudePromptsSubfolder checks if a folder is a .claude subfolder (commands, agents, skills)
func isClaudePromptsSubfolder(name string) bool <span class="cov8" title="1">{
        return name == "commands" || name == "agents" || name == "skills"
}</span>

// isDirEmpty checks if a directory is empty (no files or subdirectories)
func isDirEmpty(path string) bool <span class="cov8" title="1">{
        entries, err := os.ReadDir(path)
        if err != nil </span><span class="cov8" title="1">{
                return false // Can't read, assume not empty
        }</span>
        <span class="cov8" title="1">return len(entries) == 0</span>
}

// getDirItemCount returns the number of items in a directory
func getDirItemCount(path string) int <span class="cov8" title="1">{
        entries, err := os.ReadDir(path)
        if err != nil </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return len(entries)</span>
}

// getFileIcon returns the appropriate emoji icon based on file type
func getFileIcon(item fileItem) string <span class="cov8" title="1">{
        if item.isDir </span><span class="cov8" title="1">{
                if item.name == ".." </span><span class="cov8" title="1">{
                        return "⬆️" // Up arrow for parent dir
                }</span>
                // Virtual global prompts folder - no icon since name already has 🌐
                <span class="cov8" title="1">if isGlobalPromptsVirtualFolder(item.name) </span><span class="cov8" title="1">{
                        return "" // Name already contains 🌐 emoji
                }</span>
                // Special folder icons
                <span class="cov8" title="1">switch item.name </span>{
                case ".claude":<span class="cov8" title="1">
                        return "🤖"</span> // Robot for Claude config
                case ".git":<span class="cov8" title="1">
                        return "📦"</span> // Package for git
                case ".vscode":<span class="cov0" title="0">
                        return "💻"</span> // Laptop for VS Code
                case ".github":<span class="cov0" title="0">
                        return "🐙"</span> // Octopus for GitHub
                case ".docker":<span class="cov0" title="0">
                        return "🐳"</span> // Whale for Docker
                case ".prompts":<span class="cov8" title="1">
                        return "📝"</span> // Memo for prompts library
                case "node_modules":<span class="cov0" title="0">
                        return "📚"</span> // Books for dependencies
                case "docs", "documentation":<span class="cov0" title="0">
                        return "📖"</span> // Open book
                case "src", "source":<span class="cov0" title="0">
                        return "📂"</span> // Open folder
                case "test", "tests", "__tests__":<span class="cov0" title="0">
                        return "🧪"</span> // Test tube
                case "build", "dist", "out":<span class="cov0" title="0">
                        return "📦"</span> // Package
                case "public", "static", "assets":<span class="cov0" title="0">
                        return "🌐"</span> // Globe
                case "config", "configs", ".config":<span class="cov0" title="0">
                        return "⚙️ "</span> // Gear
                case "scripts":<span class="cov0" title="0">
                        return "📜"</span> // Scroll
                default:<span class="cov8" title="1">
                        // Check if folder is empty
                        if isDirEmpty(item.path) </span><span class="cov0" title="0">{
                                return "📂" // Open/empty folder
                        }</span>
                        <span class="cov8" title="1">return "📁"</span> // Regular closed folder (has content)
                }
        }

        // Get file extension
        <span class="cov8" title="1">ext := strings.ToLower(filepath.Ext(item.name))

        // Map extensions to emoji icons
        iconMap := map[string]string{
                // Programming languages
                ".go":   "🐹", // Gopher
                ".py":   "🐍", // Python snake
                ".js":   "🟨", // JavaScript yellow
                ".ts":   "🔷", // TypeScript blue diamond
                ".jsx":  "⚛️ ", // React atom
                ".tsx":  "⚛️ ", // React atom
                ".rs":   "🦀", // Rust crab
                ".c":    "©️ ", // C copyright symbol
                ".cpp":  "➕", // C++ plus
                ".h":    "📋", // Header clipboard
                ".java": "☕", // Java coffee
                ".rb":   "💎", // Ruby gem
                ".php":  "🐘", // PHP elephant
                ".sh":   "🐚", // Shell
                ".bash": "🐚", // Shell
                ".lua":  "🌙", // Lua moon
                ".r":    "📊", // R statistics

                // Web
                ".html": "🌐", // HTML globe
                ".css":  "🎨", // CSS art palette
                ".scss": "🎨", // SCSS art palette
                ".sass": "🎨", // Sass art palette
                ".vue":  "💚", // Vue green heart
                ".svelte": "🧡", // Svelte orange heart

                // Data/Config
                ".json": "📊", // JSON chart
                ".yaml": "📄", // YAML document
                ".yml":  "📄", // YAML document
                ".toml": "📄", // TOML document
                ".xml":  "📰", // XML newspaper
                ".csv":  "📈", // CSV chart
                ".sql":  "🗄️ ", // SQL database

                // Documents
                ".md":  "📝", // Markdown memo
                ".txt": "📄", // Text document
                ".pdf": "📕", // PDF red book
                ".doc": "📘", // DOC blue book
                ".docx": "📘", // DOCX blue book

                // Archives
                ".zip": "🗜️ ", // ZIP compression
                ".tar": "📦", // TAR package
                ".gz":  "🗜️ ", // GZ compression
                ".7z":  "🗜️ ", // 7Z compression
                ".rar": "🗜️ ", // RAR compression

                // Images
                ".png": "🖼️ ", // PNG frame
                ".jpg": "🖼️ ", // JPG frame
                ".jpeg": "🖼️ ", // JPEG frame
                ".gif": "🎞️ ", // GIF film
                ".svg": "🎨", // SVG palette
                ".ico": "🖼️ ", // ICO frame
                ".webp": "🖼️ ", // WebP frame

                // Audio/Video
                ".mp3": "🎵", // MP3 music
                ".mp4": "🎬", // MP4 movie
                ".wav": "🎵", // WAV music
                ".avi": "🎬", // AVI movie
                ".mkv": "🎬", // MKV movie

                // System/Config
                ".env":  "🔐", // ENV lock
                ".ini":  "⚙️ ", // INI gear
                ".conf": "⚙️ ", // CONF gear
                ".cfg":  "⚙️ ", // CFG gear
                ".lock": "🔒", // LOCK locked

                // Build/Package
                ".gradle": "🐘", // Gradle elephant
                ".maven":  "📦", // Maven package
                ".npm":    "📦", // NPM package
        }

        // Check for icon mapping
        if icon, ok := iconMap[ext]; ok </span><span class="cov8" title="1">{
                return icon
        }</span>

        // Check for special files without extension
        <span class="cov8" title="1">switch item.name </span>{
        case "CLAUDE.md", "CLAUDE.local.md":<span class="cov0" title="0">
                return "🤖"</span> // Claude AI
        case "Makefile", "makefile", "GNUmakefile":<span class="cov8" title="1">
                return "🔨"</span> // Build hammer
        case "Dockerfile":<span class="cov8" title="1">
                return "🐳"</span> // Docker whale
        case "docker-compose.yml", "docker-compose.yaml":<span class="cov0" title="0">
                return "🐳"</span> // Docker whale
        case "LICENSE", "LICENSE.txt", "LICENSE.md":<span class="cov0" title="0">
                return "📜"</span> // License scroll
        case "README", "README.md", "README.txt":<span class="cov0" title="0">
                return "📖"</span> // README book
        case ".gitignore", ".gitattributes", ".gitmodules":<span class="cov0" title="0">
                return "🔀"</span> // Git branch
        case "package.json":<span class="cov0" title="0">
                return "📦"</span> // NPM package
        case "package-lock.json":<span class="cov0" title="0">
                return "🔒"</span> // Lock
        case "tsconfig.json":<span class="cov0" title="0">
                return "🔷"</span> // TypeScript
        case "go.mod", "go.sum":<span class="cov0" title="0">
                return "🐹"</span> // Go gopher
        case "Cargo.toml", "Cargo.lock":<span class="cov0" title="0">
                return "🦀"</span> // Rust crab
        case "requirements.txt":<span class="cov0" title="0">
                return "🐍"</span> // Python
        case "Gemfile", "Gemfile.lock":<span class="cov0" title="0">
                return "💎"</span> // Ruby gem
        }

        // Default file marker
        <span class="cov8" title="1">return "📄"</span> // Generic document
}

// formatFileSize returns a human-readable file size
func formatFileSize(size int64) string <span class="cov8" title="1">{
        const unit = 1024
        if size &lt; unit </span><span class="cov8" title="1">{
                return fmt.Sprintf("%dB", size)
        }</span>
        <span class="cov8" title="1">div, exp := int64(unit), 0
        for n := size / unit; n &gt;= unit; n /= unit </span><span class="cov8" title="1">{
                div *= unit
                exp++
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%.1f%cB", float64(size)/float64(div), "KMGTPE"[exp])</span>
}

// formatModTime returns a relative time string
func formatModTime(t time.Time) string <span class="cov8" title="1">{
        now := time.Now()
        diff := now.Sub(t)

        if diff &lt; time.Minute </span><span class="cov8" title="1">{
                return "just now"
        }</span> else<span class="cov8" title="1"> if diff &lt; time.Hour </span><span class="cov8" title="1">{
                mins := int(diff.Minutes())
                if mins == 1 </span><span class="cov8" title="1">{
                        return "1m ago"
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("%dm ago", mins)</span>
        } else<span class="cov8" title="1"> if diff &lt; 24*time.Hour </span><span class="cov8" title="1">{
                hours := int(diff.Hours())
                if hours == 1 </span><span class="cov8" title="1">{
                        return "1h ago"
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("%dh ago", hours)</span>
        } else<span class="cov8" title="1"> if diff &lt; 7*24*time.Hour </span><span class="cov8" title="1">{
                days := int(diff.Hours() / 24)
                if days == 1 </span><span class="cov8" title="1">{
                        return "1d ago"
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("%dd ago", days)</span>
        } else<span class="cov8" title="1"> if diff &lt; 30*24*time.Hour </span><span class="cov8" title="1">{
                weeks := int(diff.Hours() / 24 / 7)
                if weeks == 1 </span><span class="cov8" title="1">{
                        return "1w ago"
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("%dw ago", weeks)</span>
        } else<span class="cov8" title="1"> if diff &lt; 365*24*time.Hour </span><span class="cov8" title="1">{
                months := int(diff.Hours() / 24 / 30)
                if months == 1 </span><span class="cov8" title="1">{
                        return "1mo ago"
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("%dmo ago", months)</span>
        }
        <span class="cov8" title="1">years := int(diff.Hours() / 24 / 365)
        if years == 1 </span><span class="cov8" title="1">{
                return "1y ago"
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%dy ago", years)</span>
}

// isMarkdownFile checks if a file is markdown
func isMarkdownFile(path string) bool <span class="cov0" title="0">{
        ext := strings.ToLower(filepath.Ext(path))
        return ext == ".md" || ext == ".markdown"
}</span>

// isBinaryFile checks if a file is likely binary
func isBinaryFile(path string) bool <span class="cov8" title="1">{
        // Read first 512 bytes to check for binary content
        f, err := os.Open(path)
        if err != nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">defer f.Close()

        buf := make([]byte, 512)
        n, err := f.Read(buf)
        if err != nil </span><span class="cov8" title="1">{
                return false
        }</span>

        // Check for null bytes (common in binary files)
        <span class="cov8" title="1">for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                if buf[i] == 0 </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

// highlightCode applies syntax highlighting to code files using Chroma
// Returns highlighted content and success status
func highlightCode(content, filepath string) (string, bool) <span class="cov0" title="0">{
        var buf bytes.Buffer

        // Try to determine lexer from filename
        lexer := lexers.Match(filepath)
        if lexer == nil </span><span class="cov0" title="0">{
                // Fallback: analyze content
                lexer = lexers.Analyse(content)
        }</span>
        <span class="cov0" title="0">if lexer == nil </span><span class="cov0" title="0">{
                // Still nothing, use fallback plain text
                return "", false
        }</span>

        // Configure lexer
        <span class="cov0" title="0">lexer = chroma.Coalesce(lexer)

        // Use terminal256 formatter for better color support
        formatter := formatters.Get("terminal256")
        if formatter == nil </span><span class="cov0" title="0">{
                formatter = formatters.Fallback
        }</span>

        // Use monokai style (works well in dark terminals)
        // Alternative styles: dracula, vim, github, solarized-dark
        <span class="cov0" title="0">style := styles.Get("monokai")
        if style == nil </span><span class="cov0" title="0">{
                style = styles.Fallback
        }</span>

        // Tokenize and format
        <span class="cov0" title="0">iterator, err := lexer.Tokenise(nil, content)
        if err != nil </span><span class="cov0" title="0">{
                return "", false
        }</span>

        <span class="cov0" title="0">err = formatter.Format(&amp;buf, style, iterator)
        if err != nil </span><span class="cov0" title="0">{
                return "", false
        }</span>

        <span class="cov0" title="0">return buf.String(), true</span>
}

// visualWidth calculates the visual width of a string, accounting for tabs and ANSI codes
// This is important for consistent scrollbar alignment and box borders
func visualWidth(s string) int <span class="cov0" title="0">{
        width := 0
        inAnsi := false

        for _, ch := range s </span><span class="cov0" title="0">{
                // Detect start of ANSI escape sequence
                if ch == '\033' </span><span class="cov0" title="0">{
                        inAnsi = true
                        continue</span>
                }

                // Skip characters inside ANSI sequences
                <span class="cov0" title="0">if inAnsi </span><span class="cov0" title="0">{
                        // ANSI sequences end with a letter (A-Z, a-z)
                        if (ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z') || (ch &gt;= 'a' &amp;&amp; ch &lt;= 'z') </span><span class="cov0" title="0">{
                                inAnsi = false
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                // Count visible characters
                <span class="cov0" title="0">if ch == '\t' </span><span class="cov0" title="0">{
                        // Tabs typically expand to next multiple of 8
                        width += 8 - (width % 8)
                }</span> else<span class="cov0" title="0"> {
                        // Regular characters count as 1
                        width++
                }</span>
        }
        <span class="cov0" title="0">return width</span>
}

// truncateToWidth truncates a string to fit within a target visual width
func truncateToWidth(s string, targetWidth int) string <span class="cov0" title="0">{
        width := 0
        result := ""

        for _, ch := range s </span><span class="cov0" title="0">{
                charWidth := 1
                if ch == '\t' </span><span class="cov0" title="0">{
                        charWidth = 8 - (width % 8)
                }</span>

                <span class="cov0" title="0">if width+charWidth &gt; targetWidth </span><span class="cov0" title="0">{
                        // Can't fit this character
                        if targetWidth-width &gt;= 3 </span><span class="cov0" title="0">{
                                return result + "..."
                        }</span>
                        <span class="cov0" title="0">return result</span>
                }

                <span class="cov0" title="0">width += charWidth
                result += string(ch)</span>
        }

        <span class="cov0" title="0">return result</span>
}

// getFileType returns a descriptive file type string based on file extension
func getFileType(item fileItem) string <span class="cov0" title="0">{
        if item.isDir </span><span class="cov0" title="0">{
                return "Folder"
        }</span>

        // Get file extension
        <span class="cov0" title="0">ext := strings.ToLower(filepath.Ext(item.name))

        // Map extensions to descriptive types
        typeMap := map[string]string{
                // Programming languages
                ".go":     "Go Source",
                ".py":     "Python",
                ".js":     "JavaScript",
                ".ts":     "TypeScript",
                ".jsx":    "React (JSX)",
                ".tsx":    "React (TSX)",
                ".rs":     "Rust",
                ".c":      "C Source",
                ".cpp":    "C++",
                ".cc":     "C++",
                ".cxx":    "C++",
                ".h":      "C Header",
                ".hpp":    "C++ Header",
                ".java":   "Java",
                ".rb":     "Ruby",
                ".php":    "PHP",
                ".sh":     "Shell Script",
                ".bash":   "Bash Script",
                ".zsh":    "ZSH Script",
                ".fish":   "Fish Script",
                ".lua":    "Lua",
                ".r":      "R Script",
                ".swift":  "Swift",
                ".kt":     "Kotlin",
                ".scala":  "Scala",
                ".cs":     "C#",
                ".vb":     "Visual Basic",
                ".pl":     "Perl",

                // Web
                ".html":   "HTML",
                ".htm":    "HTML",
                ".css":    "CSS",
                ".scss":   "SCSS",
                ".sass":   "Sass",
                ".less":   "Less",
                ".vue":    "Vue Component",
                ".svelte": "Svelte",

                // Data/Config
                ".json":  "JSON",
                ".yaml":  "YAML",
                ".yml":   "YAML",
                ".toml":  "TOML",
                ".xml":   "XML",
                ".csv":   "CSV",
                ".sql":   "SQL",
                ".env":   "Environment",
                ".ini":   "INI Config",
                ".conf":  "Config",
                ".cfg":   "Config",
                ".properties": "Properties",

                // Documents
                ".md":       "Markdown",
                ".markdown": "Markdown",
                ".txt":      "Text",
                ".pdf":      "PDF Document",
                ".doc":      "Word Doc",
                ".docx":     "Word Doc",
                ".rtf":      "Rich Text",
                ".odt":      "OpenDocument",

                // Archives
                ".zip":  "ZIP Archive",
                ".tar":  "TAR Archive",
                ".gz":   "GZip Archive",
                ".bz2":  "BZip2 Archive",
                ".xz":   "XZ Archive",
                ".7z":   "7-Zip Archive",
                ".rar":  "RAR Archive",
                ".tgz":  "TAR.GZ Archive",

                // Images
                ".png":  "PNG Image",
                ".jpg":  "JPEG Image",
                ".jpeg": "JPEG Image",
                ".gif":  "GIF Image",
                ".svg":  "SVG Image",
                ".ico":  "Icon",
                ".webp": "WebP Image",
                ".bmp":  "Bitmap Image",
                ".tiff": "TIFF Image",
                ".tif":  "TIFF Image",

                // Audio/Video
                ".mp3":  "MP3 Audio",
                ".mp4":  "MP4 Video",
                ".wav":  "WAV Audio",
                ".flac": "FLAC Audio",
                ".ogg":  "OGG Audio",
                ".avi":  "AVI Video",
                ".mkv":  "MKV Video",
                ".mov":  "MOV Video",
                ".wmv":  "WMV Video",

                // System/Build
                ".exe":    "Executable",
                ".dll":    "DLL Library",
                ".so":     "Shared Library",
                ".dylib":  "Dynamic Library",
                ".a":      "Static Library",
                ".o":      "Object File",
                ".lock":   "Lock File",
                ".log":    "Log File",
                ".tmp":    "Temporary",
                ".bak":    "Backup",
                ".swp":    "Swap File",

                // Build/Package files
                ".gradle": "Gradle",
                ".maven":  "Maven",
                ".npm":    "NPM",
                ".mod":    "Go Module",
                ".sum":    "Go Checksum",
                ".gem":    "Ruby Gem",
                ".whl":    "Python Wheel",
                ".deb":    "Debian Package",
                ".rpm":    "RPM Package",
        }

        // Check for extension mapping
        if fileType, ok := typeMap[ext]; ok </span><span class="cov0" title="0">{
                return fileType
        }</span>

        // Check for special files without extension or specific names
        <span class="cov0" title="0">switch item.name </span>{
        case "Makefile", "makefile", "GNUmakefile":<span class="cov0" title="0">
                return "Makefile"</span>
        case "Dockerfile":<span class="cov0" title="0">
                return "Dockerfile"</span>
        case "docker-compose.yml", "docker-compose.yaml":<span class="cov0" title="0">
                return "Docker Compose"</span>
        case "LICENSE", "LICENSE.txt", "LICENSE.md":<span class="cov0" title="0">
                return "License"</span>
        case "README", "README.md", "README.txt":<span class="cov0" title="0">
                return "ReadMe"</span>
        case ".gitignore":<span class="cov0" title="0">
                return "Git Ignore"</span>
        case ".gitattributes":<span class="cov0" title="0">
                return "Git Attributes"</span>
        case ".gitmodules":<span class="cov0" title="0">
                return "Git Modules"</span>
        case "package.json":<span class="cov0" title="0">
                return "NPM Package"</span>
        case "package-lock.json":<span class="cov0" title="0">
                return "NPM Lock"</span>
        case "tsconfig.json":<span class="cov0" title="0">
                return "TS Config"</span>
        case "go.mod":<span class="cov0" title="0">
                return "Go Module"</span>
        case "go.sum":<span class="cov0" title="0">
                return "Go Checksum"</span>
        case "Cargo.toml":<span class="cov0" title="0">
                return "Cargo Config"</span>
        case "Cargo.lock":<span class="cov0" title="0">
                return "Cargo Lock"</span>
        case "requirements.txt":<span class="cov0" title="0">
                return "Python Deps"</span>
        case "Gemfile":<span class="cov0" title="0">
                return "Ruby Gemfile"</span>
        case "Gemfile.lock":<span class="cov0" title="0">
                return "Ruby Lock"</span>
        case "CLAUDE.md", "CLAUDE.local.md":<span class="cov0" title="0">
                return "Claude Context"</span>
        }

        // If extension exists but not mapped, return it
        <span class="cov0" title="0">if ext != "" </span><span class="cov0" title="0">{
                return strings.TrimPrefix(ext, ".") + " File"
        }</span>

        // No extension - return generic "File"
        <span class="cov0" title="0">return "File"</span>
}

// loadSubdirFiles loads files from a specific directory (for tree view expansion)
func (m *model) loadSubdirFiles(dirPath string) []fileItem <span class="cov0" title="0">{
        entries, err := os.ReadDir(dirPath)
        if err != nil </span><span class="cov0" title="0">{
                return []fileItem{}
        }</span>

        <span class="cov0" title="0">var dirs, files []fileItem

        for _, entry := range entries </span><span class="cov0" title="0">{
                // Skip hidden files unless showHidden is true
                if !m.showHidden &amp;&amp; strings.HasPrefix(entry.Name(), ".") </span><span class="cov0" title="0">{
                        // Exception: Always show important development folders
                        importantFolders := []string{".claude", ".git", ".vscode", ".github", ".config", ".docker", ".prompts"}
                        isImportantFolder := false
                        for _, folder := range importantFolders </span><span class="cov0" title="0">{
                                if entry.Name() == folder </span><span class="cov0" title="0">{
                                        isImportantFolder = true
                                        break</span>
                                }
                        }

                        // Exception: If we're inside these folders, show all files
                        <span class="cov0" title="0">inImportantFolder := strings.Contains(dirPath, "/.claude") ||
                                strings.Contains(dirPath, "/.git") ||
                                strings.Contains(dirPath, "/.vscode") ||
                                strings.Contains(dirPath, "/.github") ||
                                strings.Contains(dirPath, "/.config") ||
                                strings.Contains(dirPath, "/.docker") ||
                                strings.Contains(dirPath, "/.prompts")

                        if !isImportantFolder &amp;&amp; !inImportantFolder </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }

                <span class="cov0" title="0">info, err := entry.Info()
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">item := fileItem{
                        name:    entry.Name(),
                        path:    filepath.Join(dirPath, entry.Name()),
                        isDir:   entry.IsDir(),
                        size:    info.Size(),
                        modTime: info.ModTime(),
                        mode:    info.Mode(),
                }

                if entry.IsDir() </span><span class="cov0" title="0">{
                        dirs = append(dirs, item)
                }</span> else<span class="cov0" title="0"> {
                        files = append(files, item)
                }</span>
        }

        // Sort alphabetically
        <span class="cov0" title="0">sort.Slice(dirs, func(i, j int) bool </span><span class="cov0" title="0">{
                return strings.ToLower(dirs[i].name) &lt; strings.ToLower(dirs[j].name)
        }</span>)
        <span class="cov0" title="0">sort.Slice(files, func(i, j int) bool </span><span class="cov0" title="0">{
                return strings.ToLower(files[i].name) &lt; strings.ToLower(files[j].name)
        }</span>)

        <span class="cov0" title="0">result := append(dirs, files...)
        return result</span>
}

// loadFiles loads the files from the current directory
func (m *model) loadFiles() <span class="cov0" title="0">{
        // Special handling for trash view
        if m.showTrashOnly </span><span class="cov0" title="0">{
                trashItems, err := getTrashItems()
                if err != nil </span><span class="cov0" title="0">{
                        m.files = []fileItem{}
                        m.setStatusMessage(fmt.Sprintf("Error loading trash: %v", err), true)
                        return
                }</span>

                // Convert trash items to file items for display
                <span class="cov0" title="0">m.files = convertTrashItemsToFileItems(trashItems)
                m.trashItems = trashItems // Cache for later use
                return</span>
        }

        <span class="cov0" title="0">entries, err := os.ReadDir(m.currentPath)
        if err != nil </span><span class="cov0" title="0">{
                m.files = []fileItem{}
                return
        }</span>

        // Reset files slice
        <span class="cov0" title="0">m.files = []fileItem{}

        // Add parent directory if not at root
        if m.currentPath != "/" </span><span class="cov0" title="0">{
                m.files = append(m.files, fileItem{
                        name:  "..",
                        path:  filepath.Dir(m.currentPath),
                        isDir: true,
                })
        }</span>

        // Add directories first, then files
        <span class="cov0" title="0">var dirs, files []fileItem

        for _, entry := range entries </span><span class="cov0" title="0">{
                // Skip hidden files starting with . (unless showHidden is true)
                if !m.showHidden &amp;&amp; strings.HasPrefix(entry.Name(), ".") </span><span class="cov0" title="0">{
                        // Exception: Always show important development folders
                        importantFolders := []string{".claude", ".git", ".vscode", ".github", ".config", ".docker", ".prompts"}
                        isImportantFolder := false
                        for _, folder := range importantFolders </span><span class="cov0" title="0">{
                                if entry.Name() == folder </span><span class="cov0" title="0">{
                                        isImportantFolder = true
                                        break</span>
                                }
                        }

                        // Exception: If we're inside these folders, show all files
                        <span class="cov0" title="0">inImportantFolder := strings.Contains(m.currentPath, "/.claude") ||
                                strings.Contains(m.currentPath, "/.git") ||
                                strings.Contains(m.currentPath, "/.vscode") ||
                                strings.Contains(m.currentPath, "/.github") ||
                                strings.Contains(m.currentPath, "/.config") ||
                                strings.Contains(m.currentPath, "/.docker") ||
                                strings.Contains(m.currentPath, "/.prompts")

                        if !isImportantFolder &amp;&amp; !inImportantFolder </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }

                <span class="cov0" title="0">info, err := entry.Info()
                if err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip files we can't stat
                }

                <span class="cov0" title="0">item := fileItem{
                        name:    entry.Name(),
                        path:    filepath.Join(m.currentPath, entry.Name()),
                        isDir:   entry.IsDir(),
                        size:    info.Size(),
                        modTime: info.ModTime(),
                        mode:    info.Mode(),
                }

                if entry.IsDir() </span><span class="cov0" title="0">{
                        dirs = append(dirs, item)
                }</span> else<span class="cov0" title="0"> {
                        files = append(files, item)
                }</span>
        }

        // Sort alphabetically
        <span class="cov0" title="0">sort.Slice(dirs, func(i, j int) bool </span><span class="cov0" title="0">{
                return strings.ToLower(dirs[i].name) &lt; strings.ToLower(dirs[j].name)
        }</span>)
        <span class="cov0" title="0">sort.Slice(files, func(i, j int) bool </span><span class="cov0" title="0">{
                return strings.ToLower(files[i].name) &lt; strings.ToLower(files[j].name)
        }</span>)

        <span class="cov0" title="0">m.files = append(m.files, dirs...)
        m.files = append(m.files, files...)

        // Reset cursor if out of bounds
        if m.cursor &gt;= len(m.files) </span><span class="cov0" title="0">{
                m.cursor = 0
        }</span>

        // Apply sorting based on sortBy and sortAsc settings
        <span class="cov0" title="0">m.sortFiles()</span>
}

// sortFiles sorts the file list based on sortBy and sortAsc settings
// Always keeps ".." parent directory at the top
// When sorting by name: keeps folders grouped before files (traditional behavior)
// When sorting by other criteria: mixes folders and files
func (m *model) sortFiles() <span class="cov0" title="0">{
        if len(m.files) &lt;= 1 </span><span class="cov0" title="0">{
                return
        }</span>

        // Separate parent directory (..) from other files
        <span class="cov0" title="0">var parentDir *fileItem
        var otherFiles []fileItem

        for i := range m.files </span><span class="cov0" title="0">{
                if m.files[i].name == ".." </span><span class="cov0" title="0">{
                        parentDir = &amp;m.files[i]
                }</span> else<span class="cov0" title="0"> {
                        otherFiles = append(otherFiles, m.files[i])
                }</span>
        }

        // When sorting by name, keep folders grouped before files (traditional behavior)
        <span class="cov0" title="0">if m.sortBy == "name" </span><span class="cov0" title="0">{
                var dirs, files []fileItem

                // Separate directories from files
                for _, item := range otherFiles </span><span class="cov0" title="0">{
                        if item.isDir </span><span class="cov0" title="0">{
                                dirs = append(dirs, item)
                        }</span> else<span class="cov0" title="0"> {
                                files = append(files, item)
                        }</span>
                }

                // Sort directories alphabetically
                <span class="cov0" title="0">sort.Slice(dirs, func(i, j int) bool </span><span class="cov0" title="0">{
                        less := strings.ToLower(dirs[i].name) &lt; strings.ToLower(dirs[j].name)
                        if !m.sortAsc </span><span class="cov0" title="0">{
                                less = !less
                        }</span>
                        <span class="cov0" title="0">return less</span>
                })

                // Sort files alphabetically
                <span class="cov0" title="0">sort.Slice(files, func(i, j int) bool </span><span class="cov0" title="0">{
                        less := strings.ToLower(files[i].name) &lt; strings.ToLower(files[j].name)
                        if !m.sortAsc </span><span class="cov0" title="0">{
                                less = !less
                        }</span>
                        <span class="cov0" title="0">return less</span>
                })

                // Reconstruct: parent dir, then folders, then files
                <span class="cov0" title="0">m.files = make([]fileItem, 0, len(m.files))
                if parentDir != nil </span><span class="cov0" title="0">{
                        m.files = append(m.files, *parentDir)
                }</span>
                <span class="cov0" title="0">m.files = append(m.files, dirs...)
                m.files = append(m.files, files...)
                return</span>
        }

        // For other sort criteria (size, modified, type): mix folders and files
        <span class="cov0" title="0">sort.Slice(otherFiles, func(i, j int) bool </span><span class="cov0" title="0">{
                a, b := otherFiles[i], otherFiles[j]

                // Determine sort result based on sortBy
                var less bool
                switch m.sortBy </span>{
                case "size":<span class="cov0" title="0">
                        // For directories, compare by item count
                        // For files, compare by size
                        aSize := a.size
                        bSize := b.size
                        if a.isDir </span><span class="cov0" title="0">{
                                aSize = int64(getDirItemCount(a.path))
                        }</span>
                        <span class="cov0" title="0">if b.isDir </span><span class="cov0" title="0">{
                                bSize = int64(getDirItemCount(b.path))
                        }</span>
                        <span class="cov0" title="0">if aSize == bSize </span><span class="cov0" title="0">{
                                // If same size, sort by name as secondary
                                less = strings.ToLower(a.name) &lt; strings.ToLower(b.name)
                        }</span> else<span class="cov0" title="0"> {
                                less = aSize &lt; bSize
                        }</span>

                case "modified":<span class="cov0" title="0">
                        if a.modTime.Equal(b.modTime) </span><span class="cov0" title="0">{
                                // If same time, sort by name as secondary
                                less = strings.ToLower(a.name) &lt; strings.ToLower(b.name)
                        }</span> else<span class="cov0" title="0"> {
                                less = a.modTime.Before(b.modTime)
                        }</span>

                case "type":<span class="cov0" title="0">
                        aType := getFileType(a)
                        bType := getFileType(b)
                        if aType == bType </span><span class="cov0" title="0">{
                                // If same type, sort by name as secondary
                                less = strings.ToLower(a.name) &lt; strings.ToLower(b.name)
                        }</span> else<span class="cov0" title="0"> {
                                less = aType &lt; bType
                        }</span>

                default:<span class="cov0" title="0">
                        // Fallback to name sorting
                        less = strings.ToLower(a.name) &lt; strings.ToLower(b.name)</span>
                }

                // Apply sort direction (ascending vs descending)
                <span class="cov0" title="0">if !m.sortAsc </span><span class="cov0" title="0">{
                        less = !less
                }</span>

                <span class="cov0" title="0">return less</span>
        })

        // Reconstruct files slice with parent directory at top (if present)
        <span class="cov0" title="0">m.files = make([]fileItem, 0, len(m.files))
        if parentDir != nil </span><span class="cov0" title="0">{
                m.files = append(m.files, *parentDir)
        }</span>
        <span class="cov0" title="0">m.files = append(m.files, otherFiles...)</span>
}

// loadPreview loads the content of a file for preview
func (m *model) loadPreview(path string) <span class="cov0" title="0">{
        m.preview.filePath = path
        m.preview.fileName = filepath.Base(path)
        m.preview.scrollPos = 0
        m.preview.loaded = false
        m.preview.isBinary = false
        m.preview.tooLarge = false
        m.preview.isMarkdown = false
        m.preview.isSyntaxHighlighted = false
        m.preview.isPrompt = false
        m.preview.promptTemplate = nil
        // Invalidate cache when loading new file
        m.preview.cacheValid = false
        m.preview.cachedWrappedLines = nil
        m.preview.cachedRenderedContent = ""
        m.preview.cachedLineCount = 0

        // Get file info
        info, err := os.Stat(path)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">m.preview.fileSize = info.Size()

        // Check if file is too large (&gt;1MB)
        const maxSize = 1024 * 1024 // 1MB
        if info.Size() &gt; maxSize </span><span class="cov0" title="0">{
                m.preview.tooLarge = true
                m.preview.content = []string{
                        "File too large to preview",
                        fmt.Sprintf("Size: %s", formatFileSize(info.Size())),
                        "",
                        "Press 'E' to edit in external editor",
                }
                m.preview.loaded = true
                return
        }</span>

        // Check if binary
        <span class="cov0" title="0">if isBinaryFile(path) </span><span class="cov0" title="0">{
                m.preview.isBinary = true
                m.preview.content = []string{
                        "Binary file detected",
                        fmt.Sprintf("Size: %s", formatFileSize(info.Size())),
                        "",
                        "Cannot preview binary files",
                }
                m.preview.loaded = true
                return
        }</span>

        // Read file content
        <span class="cov0" title="0">content, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                m.preview.content = []string{
                        fmt.Sprintf("Error reading file: %v", err),
                }
                m.preview.loaded = true
                return
        }</span>

        // Check if this is a prompt file and parse it
        <span class="cov0" title="0">fileItem := fileItem{
                name:  filepath.Base(path),
                path:  path,
                isDir: false,
        }
        if isPromptFile(fileItem) </span><span class="cov0" title="0">{
                tmpl, err := parsePromptFile(path)
                if err == nil </span><span class="cov0" title="0">{
                        // Successfully parsed as prompt
                        m.preview.isPrompt = true
                        m.preview.promptTemplate = tmpl

                        // Get context variables
                        contextVars := getContextVariables(m)

                        // Render the template with variables substituted
                        rendered := renderPromptTemplate(tmpl, contextVars)

                        // Split into lines for display
                        lines := strings.Split(rendered, "\n")
                        m.preview.content = lines
                        m.preview.loaded = true

                        // Create input fields for prompt variables
                        // Only activate fields when in prompts mode (F11)
                        if m.showPromptsOnly </span><span class="cov0" title="0">{
                                m.promptInputFields = createInputFields(tmpl, m)
                                m.inputFieldsActive = len(m.promptInputFields) &gt; 0
                                m.focusedInputField = 0 // Focus first field by default
                        }</span> else<span class="cov0" title="0"> {
                                // Not in prompts mode - clear fields
                                m.promptInputFields = nil
                                m.inputFieldsActive = false
                                m.focusedInputField = 0
                        }</span>

                        // Populate cache for better scroll performance
                        <span class="cov0" title="0">m.populatePreviewCache()
                        return</span>
                }
                // If parsing failed, fall through to regular preview
        }

        // Check if markdown and render with Glamour
        <span class="cov0" title="0">if isMarkdownFile(path) </span><span class="cov0" title="0">{
                m.preview.isMarkdown = true
                // Use Glamour to render markdown with appropriate width
                // We'll set width in the render function based on available space
                // For now, just store the raw content and mark as markdown
                lines := strings.Split(string(content), "\n")
                m.preview.content = lines
                m.preview.loaded = true

                // DON'T populate cache here - let caller do it after setting view mode
                // This prevents rendering with wrong width (e.g., m.rightWidth=0 in single-pane)
                // Caller should call populatePreviewCache() after setting viewMode correctly
                return
        }</span>

        // Try syntax highlighting for code files
        <span class="cov0" title="0">highlighted, ok := highlightCode(string(content), path)
        var lines []string

        if ok </span><span class="cov0" title="0">{
                // Syntax highlighting succeeded
                lines = strings.Split(highlighted, "\n")
                m.preview.isSyntaxHighlighted = true
        }</span> else<span class="cov0" title="0"> {
                // Fallback to plain text
                lines = strings.Split(string(content), "\n")
                m.preview.isSyntaxHighlighted = false
        }</span>

        // Limit number of lines
        <span class="cov0" title="0">if len(lines) &gt; m.preview.maxPreview </span><span class="cov0" title="0">{
                lines = lines[:m.preview.maxPreview]
                lines = append(lines, "", fmt.Sprintf("... (truncated after %d lines)", m.preview.maxPreview))
        }</span>

        <span class="cov0" title="0">m.preview.content = lines
        m.preview.loaded = true

        // Populate cache for better scroll performance
        m.populatePreviewCache()</span>
}

// populatePreviewCache pre-computes and caches wrapped/rendered content for better scroll performance
func (m *model) populatePreviewCache() <span class="cov0" title="0">{
        if !m.preview.loaded </span><span class="cov0" title="0">{
                return
        }</span>

        // Calculate available width
        <span class="cov0" title="0">var availableWidth int
        if m.preview.isMarkdown </span><span class="cov0" title="0">{
                // Markdown never shows line numbers/scrollbar, so use wider width
                if m.viewMode == viewFullPreview </span><span class="cov0" title="0">{
                        availableWidth = m.width - 4 // Just padding
                }</span> else<span class="cov0" title="0"> {
                        availableWidth = m.rightWidth - 4 // Just padding in dual-pane
                }</span>
        } else<span class="cov0" title="0"> {
                // Regular text files show line numbers and scrollbar
                if m.viewMode == viewFullPreview </span><span class="cov0" title="0">{
                        availableWidth = m.width - 10 // line nums (6) + scrollbar (2) + padding (2)
                }</span> else<span class="cov0" title="0"> {
                        availableWidth = m.rightWidth - 17 // line nums (8) + scrollbar (2) + borders (4) + padding (3)
                }</span>
        }
        <span class="cov0" title="0">if availableWidth &lt; 20 </span><span class="cov0" title="0">{
                availableWidth = 20
        }</span>

        // Cache markdown rendering
        <span class="cov0" title="0">if m.preview.isMarkdown </span><span class="cov0" title="0">{
                // Safety: skip Glamour for very large markdown files (can cause hangs with complex content)
                // For files &gt; 2000 lines, treat as plain text to avoid performance issues
                const maxMarkdownLines = 2000
                if len(m.preview.content) &gt; maxMarkdownLines </span><span class="cov0" title="0">{
                        // Too large for Glamour - treat as plain text
                        m.preview.isMarkdown = false
                        // Fall through to regular text wrapping below
                }</span> else<span class="cov0" title="0"> {
                        markdownContent := strings.Join(m.preview.content, "\n")

                        // Render with 5-second timeout to prevent hangs
                        rendered, err := renderMarkdownWithTimeout(markdownContent, availableWidth, 5*time.Second)

                        if err == nil </span><span class="cov0" title="0">{
                                // Store rendered content even if empty (Glamour might return empty for some valid markdown)
                                m.preview.cachedRenderedContent = rendered
                                renderedLines := strings.Split(strings.TrimRight(rendered, "\n"), "\n")
                                m.preview.cachedLineCount = len(renderedLines)
                                m.preview.cachedWidth = availableWidth
                                m.preview.cacheValid = true
                                return
                        }</span> else<span class="cov0" title="0"> {
                                // Glamour render failed (error or timeout) - treat as plain text
                                m.preview.isMarkdown = false
                                // Log the error for debugging (appears in status message)
                                if strings.Contains(err.Error(), "timeout") </span><span class="cov0" title="0">{
                                        m.setStatusMessage("Markdown rendering timed out, showing as plain text", true)
                                }</span>
                        }
                        // Fall through to regular text wrapping
                }
        }

        // Cache wrapped text lines
        <span class="cov0" title="0">var wrappedLines []string
        for _, line := range m.preview.content </span><span class="cov0" title="0">{
                wrapped := wrapLine(line, availableWidth)
                wrappedLines = append(wrappedLines, wrapped...)
        }</span>
        <span class="cov0" title="0">m.preview.cachedWrappedLines = wrappedLines
        m.preview.cachedLineCount = len(wrappedLines)
        m.preview.cachedWidth = availableWidth
        m.preview.cacheValid = true</span>
}

// renderMarkdownWithTimeout renders markdown with a timeout to prevent hangs
// Returns rendered content and any error (including timeout)
func renderMarkdownWithTimeout(content string, width int, timeout time.Duration) (string, error) <span class="cov8" title="1">{
        type renderResult struct {
                rendered string
                err      error
        }

        // Use buffered channel to prevent goroutine leak
        resultChan := make(chan renderResult, 1)

        go func() </span><span class="cov8" title="1">{
                // Recover from panics in glamour rendering
                defer func() </span><span class="cov8" title="1">{
                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                resultChan &lt;- renderResult{
                                        rendered: "",
                                        err:      fmt.Errorf("markdown rendering panicked: %v", r),
                                }
                        }</span>
                }()

                // Render markdown
                <span class="cov8" title="1">renderer, err := glamour.NewTermRenderer(
                        glamour.WithStandardStyle("auto"),
                        glamour.WithWordWrap(width),
                )
                if err != nil </span><span class="cov0" title="0">{
                        resultChan &lt;- renderResult{rendered: "", err: err}
                        return
                }</span>

                <span class="cov8" title="1">rendered, err := renderer.Render(content)
                resultChan &lt;- renderResult{rendered: rendered, err: err}</span>
        }()

        // Wait for result or timeout
        <span class="cov8" title="1">select </span>{
        case result := &lt;-resultChan:<span class="cov8" title="1">
                return result.rendered, result.err</span>
        case &lt;-time.After(timeout):<span class="cov8" title="1">
                return "", fmt.Errorf("markdown rendering timeout after %v", timeout)</span>
        }
}

// renderMarkdownAsync renders markdown in a background goroutine
func renderMarkdownAsync(m *model) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                // Populate cache (includes Glamour rendering)
                m.populatePreviewCache()
                return markdownRenderedMsg{}
        }</span>
}

// setStatusMessage sets a temporary status message with auto-dismiss
func (m *model) setStatusMessage(message string, isError bool) <span class="cov0" title="0">{
        m.statusMessage = message
        m.statusIsError = isError
        m.statusTime = time.Now()
}</span>

// createDirectory creates a new directory in the current path
func (m *model) createDirectory(name string) error <span class="cov0" title="0">{
        // Validate name (no /, \, special chars)
        if strings.ContainsAny(name, "/\\:*?\"&lt;&gt;|") </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid characters in directory name")
        }</span>
        <span class="cov0" title="0">if name == "" || name == "." || name == ".." </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid directory name")
        }</span>

        // Create directory in current path
        <span class="cov0" title="0">path := filepath.Join(m.currentPath, name)
        if err := os.Mkdir(path, 0755); err != nil </span><span class="cov0" title="0">{
                if os.IsExist(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("directory already exists")
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// deleteFileOrDir deletes a file or directory
func (m *model) deleteFileOrDir(path string, isDir bool) error <span class="cov0" title="0">{
        // Check if exists
        if _, err := os.Stat(path); err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("file not found")
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        // Move to trash instead of permanent delete for safety
        <span class="cov0" title="0">if err := moveToTrash(path); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to move to trash: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// permanentDeleteFileOrDir permanently deletes a file without moving to trash
// Used for emptying trash or when explicitly requested
func (m *model) permanentDeleteFileOrDir(path string, isDir bool) error <span class="cov0" title="0">{
        // Check if exists
        info, err := os.Stat(path)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("file not found")
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">if isDir </span><span class="cov0" title="0">{
                // For directories, use RemoveAll to handle non-empty directories
                return os.RemoveAll(path)
        }</span>

        // Delete file
        // Check if file is writable
        <span class="cov0" title="0">if info.Mode()&amp;0200 == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("file is read-only")
        }</span>

        <span class="cov0" title="0">return os.Remove(path)</span>
}

// filterFilesBySearch returns indices of files matching the search query
// Case-insensitive substring matching on file names
func (m *model) filterFilesBySearch(query string) []int <span class="cov0" title="0">{
        if query == "" </span><span class="cov0" title="0">{
                // Empty query - return all indices
                indices := make([]int, len(m.files))
                for i := range indices </span><span class="cov0" title="0">{
                        indices[i] = i
                }</span>
                <span class="cov0" title="0">return indices</span>
        }

        <span class="cov0" title="0">queryLower := strings.ToLower(query)
        var matchingIndices []int

        for i, file := range m.files </span><span class="cov0" title="0">{
                // Skip parent directory (..) - always show it
                if file.name == ".." </span><span class="cov0" title="0">{
                        matchingIndices = append(matchingIndices, i)
                        continue</span>
                }

                // Case-insensitive substring match
                <span class="cov0" title="0">if strings.Contains(strings.ToLower(file.name), queryLower) </span><span class="cov0" title="0">{
                        matchingIndices = append(matchingIndices, i)
                }</span>
        }

        <span class="cov0" title="0">return matchingIndices</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package main

// Module: fuzzy_search.go
// Purpose: Fuzzy file search functionality using go-fzf
// Responsibilities:
// - Building file lists for fuzzy search
// - Launching fuzzy finder interface
// - Processing search results

import (
        "path/filepath"
        "strings"

        fzf "github.com/koki-develop/go-fzf"
        tea "github.com/charmbracelet/bubbletea"
)

// launchFuzzySearch creates a fuzzy search interface for all files in current directory
func (m *model) launchFuzzySearch() tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                // Build list of all files (recursively walk directory)
                items := m.buildFuzzySearchItems()

                if len(items) == 0 </span><span class="cov0" title="0">{
                        return fuzzySearchResultMsg{
                                selected: "",
                                err:      nil,
                        }
                }</span>

                // Create display names (relative paths from current directory)
                <span class="cov0" title="0">displayNames := make([]string, len(items))
                for i, item := range items </span><span class="cov0" title="0">{
                        // Remove the current path prefix to show relative paths
                        relPath := strings.TrimPrefix(item.path, m.currentPath)
                        relPath = strings.TrimPrefix(relPath, "/")
                        if relPath == "" </span><span class="cov0" title="0">{
                                relPath = item.name
                        }</span>
                        // Add folder indicator
                        <span class="cov0" title="0">if item.isDir </span><span class="cov0" title="0">{
                                relPath += "/"
                        }</span>
                        <span class="cov0" title="0">displayNames[i] = relPath</span>
                }

                // Create fuzzy finder with optimized settings for speed
                <span class="cov0" title="0">f, err := fzf.New(
                        fzf.WithLimit(8), // Reduced to 8 results for faster rendering
                )
                if err != nil </span><span class="cov0" title="0">{
                        return fuzzySearchResultMsg{
                                selected: "",
                                err:      err,
                        }
                }</span>

                // Find selected item
                <span class="cov0" title="0">idxs, err := f.Find(displayNames, func(i int) string </span><span class="cov0" title="0">{ return displayNames[i] }</span>)
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return fuzzySearchResultMsg{
                                selected: "",
                                err:      err,
                        }
                }</span>

                // Get selected file path
                <span class="cov0" title="0">var selected string
                if len(idxs) &gt; 0 </span><span class="cov0" title="0">{
                        selected = items[idxs[0]].path
                }</span>

                <span class="cov0" title="0">return fuzzySearchResultMsg{
                        selected: selected,
                        err:      nil,
                }</span>
        }
}

// buildFuzzySearchItems recursively builds a list of all files for fuzzy search
func (m *model) buildFuzzySearchItems() []fileItem <span class="cov0" title="0">{
        var items []fileItem
        const maxItems = 200 // Reduced limit for faster searching

        // Start with current directory files (skip "..")
        for _, f := range m.files </span><span class="cov0" title="0">{
                if f.name != ".." </span><span class="cov0" title="0">{
                        items = append(items, f)
                        if len(items) &gt;= maxItems </span><span class="cov0" title="0">{
                                return items
                        }</span>
                }
        }

        // Only recurse into subdirectories if we haven't hit the limit
        // and only go 1 level deep
        <span class="cov0" title="0">if len(items) &lt; maxItems </span><span class="cov0" title="0">{
                m.addSubdirFiles(m.currentPath, 0, 1, &amp;items, maxItems)
        }</span>

        <span class="cov0" title="0">return items</span>
}

// addSubdirFiles recursively adds files from subdirectories
func (m *model) addSubdirFiles(dirPath string, currentDepth, maxDepth int, items *[]fileItem, maxItems int) <span class="cov0" title="0">{
        if currentDepth &gt;= maxDepth || len(*items) &gt;= maxItems </span><span class="cov0" title="0">{
                return
        }</span>

        // Get files in this directory using loadSubdirFiles pattern
        <span class="cov0" title="0">files := m.loadSubdirFiles(dirPath)

        // Process each file
        for _, file := range files </span><span class="cov0" title="0">{
                // Check if we've hit the limit
                if len(*items) &gt;= maxItems </span><span class="cov0" title="0">{
                        return
                }</span>

                // Add file to items
                <span class="cov0" title="0">*items = append(*items, file)

                // If it's a directory, recurse into it
                if file.isDir </span><span class="cov0" title="0">{
                        m.addSubdirFiles(file.path, currentDepth+1, maxDepth, items, maxItems)
                }</span>
        }
}

// navigateToFuzzyResult navigates to the selected file from fuzzy search
func (m *model) navigateToFuzzyResult(selectedPath string) <span class="cov0" title="0">{
        if selectedPath == "" </span><span class="cov0" title="0">{
                return
        }</span>

        // Get directory and filename
        <span class="cov0" title="0">dir := filepath.Dir(selectedPath)
        filename := filepath.Base(selectedPath)

        // If the file is in a different directory, navigate there
        if dir != m.currentPath </span><span class="cov0" title="0">{
                m.currentPath = dir
                m.loadFiles()
        }</span>

        // Find the file in the current file list and move cursor to it
        <span class="cov0" title="0">for i, file := range m.files </span><span class="cov0" title="0">{
                if strings.EqualFold(file.name, filename) </span><span class="cov0" title="0">{
                        m.cursor = i

                        // Load preview if not a directory
                        if !file.isDir &amp;&amp; m.viewMode == viewDualPane </span><span class="cov0" title="0">{
                                m.loadPreview(file.path)
                                m.populatePreviewCache()
                        }</span>
                        <span class="cov0" title="0">break</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package main

import (
        "os"
        "path/filepath"
        "strings"
)

// Module: helpers.go
// Purpose: Helper functions for the model
// Responsibilities:
// - Getting currently selected file across different display modes
// - Utility functions for cursor management
// - Path formatting utilities

// getCurrentFile returns the currently selected file based on cursor position
// This handles the complexity of tree view with expanded folders
func (m model) getCurrentFile() *fileItem <span class="cov8" title="1">{
        if len(m.files) == 0 || m.cursor &lt; 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        // In tree view, we need to map cursor to the flattened tree
        <span class="cov8" title="1">if m.displayMode == modeTree </span><span class="cov0" title="0">{
                files := m.getFilteredFiles()
                treeItems := m.buildTreeItems(files, 0, []bool{})
                if m.cursor &lt; len(treeItems) </span><span class="cov0" title="0">{
                        return &amp;treeItems[m.cursor].file
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        // In other views, use filtered files
        <span class="cov8" title="1">files := m.getFilteredFiles()
        if m.cursor &lt; len(files) </span><span class="cov8" title="1">{
                return &amp;files[m.cursor]
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// getMaxCursor returns the maximum valid cursor position for the current display mode
func (m model) getMaxCursor() int <span class="cov8" title="1">{
        if m.displayMode == modeTree </span><span class="cov0" title="0">{
                files := m.getFilteredFiles()
                treeItems := m.buildTreeItems(files, 0, []bool{})
                return len(treeItems) - 1
        }</span>

        <span class="cov8" title="1">files := m.getFilteredFiles()
        return len(files) - 1</span>
}

// getDisplayPath returns a user-friendly path with home directory replaced by ~
func getDisplayPath(path string) string <span class="cov8" title="1">{
        homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return path
        }</span>

        // Replace home directory with ~
        <span class="cov8" title="1">if strings.HasPrefix(path, homeDir) </span><span class="cov8" title="1">{
                if path == homeDir </span><span class="cov8" title="1">{
                        return "~"
                }</span>
                <span class="cov8" title="1">return "~" + strings.TrimPrefix(path, homeDir)</span>
        }

        <span class="cov8" title="1">return path</span>
}

// isDualPaneCompatible checks if the current display mode supports dual-pane view
// Grid and Detail views need full width for their column layouts
func (m model) isDualPaneCompatible() bool <span class="cov8" title="1">{
        return m.displayMode == modeList || m.displayMode == modeTree
}</span>

// isPromptFile checks if a file is a prompt file (.prompty, .yaml, .md, .txt)
// Only files in special directories (.claude/, ~/.prompts/) are considered prompts
// Exception: .prompty files are always prompts (Microsoft Prompty format)
func isPromptFile(item fileItem) bool <span class="cov8" title="1">{
        if item.isDir </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">ext := strings.ToLower(filepath.Ext(item.name))

        // .prompty is always a prompt file (Microsoft Prompty format)
        if ext == ".prompty" </span><span class="cov8" title="1">{
                return true
        }</span>

        // For other extensions, only consider them prompts if in special directories
        <span class="cov8" title="1">if ext == ".md" || ext == ".yaml" || ext == ".yml" || ext == ".txt" </span><span class="cov8" title="1">{
                // Check if in .claude/ or any subfolder
                if strings.Contains(item.path, "/.claude/") || strings.HasSuffix(item.path, "/.claude") </span><span class="cov8" title="1">{
                        return true
                }</span>
                // Check if in ~/.prompts/ or any subfolder
                <span class="cov8" title="1">homeDir, _ := os.UserHomeDir()
                promptsDir := filepath.Join(homeDir, ".prompts")
                if strings.HasPrefix(item.path, promptsDir) </span><span class="cov8" title="1">{
                        return true
                }</span>
                // Check if path ends with .claude (for the .claude folder itself)
                <span class="cov8" title="1">if strings.Contains(item.path, "/.claude/") </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package main

import (
        "fmt"
        "os"
        "os/signal"
        "syscall"

        tea "github.com/charmbracelet/bubbletea"
)

func main() <span class="cov0" title="0">{
        // Ensure terminal cleanup on exit (defer runs even if panic/interrupt)
        defer cleanupTerminal()

        // Set up signal catching to handle Ctrl+C gracefully
        sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)

        p := tea.NewProgram(
                initialModel(),
                tea.WithAltScreen(),
                tea.WithMouseCellMotion(),
        )

        // Handle signals in a goroutine
        go func() </span><span class="cov0" title="0">{
                &lt;-sigChan
                p.Send(tea.KeyMsg{Type: tea.KeyCtrlC})
        }</span>()

        <span class="cov0" title="0">if _, err := p.Run(); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error: %v", err)
                os.Exit(1)
        }</span>
}

// cleanupTerminal resets terminal state to prevent formatting bleed
func cleanupTerminal() <span class="cov0" title="0">{
        // Exit alt screen (in case Bubbletea didn't clean up)
        fmt.Print("\033[?1049l")

        // Disable mouse tracking (in case it was left on)
        fmt.Print("\033[?1000l") // Disable X10 mouse
        fmt.Print("\033[?1002l") // Disable cell motion mouse tracking
        fmt.Print("\033[?1003l") // Disable all motion mouse tracking
        fmt.Print("\033[?1006l") // Disable SGR mouse mode

        // Reset all ANSI formatting
        fmt.Print("\033[0m")

        // Show cursor (in case it was hidden)
        fmt.Print("\033[?25h")

        // Reset scrolling region
        fmt.Print("\033[r")

        // Clear from cursor to end of screen (clean up any leftover artifacts)
        fmt.Print("\033[J")

        // Move cursor to start of line
        fmt.Print("\r")
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package main

import (
        "os"

        "github.com/charmbracelet/bubbles/spinner"
        "github.com/charmbracelet/lipgloss"
)

func initialModel() model <span class="cov0" title="0">{
        cwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                cwd = "."
        }</span>

        <span class="cov0" title="0">s := spinner.New()
        s.Spinner = spinner.Dot
        s.Style = lipgloss.NewStyle().Foreground(lipgloss.AdaptiveColor{Light: "#0087d7", Dark: "#5fd7ff"})

        m := model{
                currentPath:       cwd,
                cursor:            0,
                height:            24,
                width:             80,
                showHidden:        false,
                displayMode:       modeTree, // Tree view works better on narrow terminals
                gridColumns:       4,
                sortBy:            "name",
                sortAsc:           true,
                viewMode:          viewSinglePane,
                focusedPane:       leftPane,
                lastClickIndex:    -1,
                preview: previewModel{
                        maxPreview: 10000, // Max 10k lines
                },
                spinner:           s,
                loading:           false,
                favorites:         loadFavorites(),
                showFavoritesOnly: false,
                expandedDirs:      make(map[string]bool),
                commandFocused:    false, // Start in file browser mode, not command mode
        }

        m.loadFiles()
        m.calculateGridLayout()
        m.calculateLayout()
        return m</span>
}

// calculateGridLayout calculates how many columns fit in grid view
func (m *model) calculateGridLayout() <span class="cov0" title="0">{
        itemWidth := 15 // Estimated width per item (icon + name + padding)
        columns := m.width / itemWidth
        if columns &lt; 1 </span><span class="cov0" title="0">{
                columns = 1
        }</span>
        <span class="cov0" title="0">if columns &gt; 8 </span><span class="cov0" title="0">{
                columns = 8 // Max 8 columns for readability
        }</span>
        <span class="cov0" title="0">m.gridColumns = columns</span>
}

// calculateLayout calculates left and right pane widths for dual-pane mode
func (m *model) calculateLayout() <span class="cov0" title="0">{
        if m.viewMode == viewSinglePane || m.viewMode == viewFullPreview </span><span class="cov0" title="0">{
                m.leftWidth = m.width
                m.rightWidth = 0
        }</span> else<span class="cov0" title="0"> {
                // 40/60 split for dual-pane
                m.leftWidth = m.width * 40 / 100
                m.rightWidth = m.width - m.leftWidth - 1 // -1 for separator
                if m.leftWidth &lt; 20 </span><span class="cov0" title="0">{
                        m.leftWidth = 20
                }</span>
                <span class="cov0" title="0">if m.rightWidth &lt; 30 </span><span class="cov0" title="0">{
                        m.rightWidth = 30
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package main

// Module: prompt_parser.go
// Purpose: Prompt file parsing and template rendering
// Responsibilities:
// - Parse .prompty format (YAML frontmatter)
// - Parse simple YAML format
// - Parse plain text (.md, .txt)
// - Template variable substitution
// - Context variable providers

import (
        "fmt"
        "os"
        "path/filepath"
        "regexp"
        "strings"
        "time"

        "gopkg.in/yaml.v3"
)

// parsePromptFile parses a prompt file and returns a promptTemplate
// Supports three formats:
// 1. .prompty - Microsoft Prompty format (YAML frontmatter between --- markers)
// 2. .yaml/.yml - Simple YAML with 'template' field
// 3. .md/.txt - Plain text with {{variables}}
func parsePromptFile(path string) (*promptTemplate, error) <span class="cov0" title="0">{
        // Check file size before reading (defensive check)
        info, err := os.Stat(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to stat file: %w", err)
        }</span>

        // Limit prompt files to 1MB to prevent OOM
        <span class="cov0" title="0">const maxPromptSize = 1024 * 1024 // 1MB
        if info.Size() &gt; maxPromptSize </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("prompt file too large (%d bytes, max %d bytes)", info.Size(), maxPromptSize)
        }</span>

        // Read file content
        <span class="cov0" title="0">content, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read file: %w", err)
        }</span>

        <span class="cov0" title="0">contentStr := string(content)
        ext := strings.ToLower(filepath.Ext(path))
        filename := filepath.Base(path)

        // Determine source location
        source := determinePromptSource(path)

        var tmpl promptTemplate
        tmpl.source = source
        tmpl.raw = contentStr

        // Parse based on format
        switch ext </span>{
        case ".prompty":<span class="cov0" title="0">
                // Microsoft Prompty format: YAML frontmatter between --- markers
                if err := parsePromptyFormat(contentStr, &amp;tmpl); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

        case ".yaml", ".yml":<span class="cov0" title="0">
                // Simple YAML format
                if err := parseYAMLFormat(contentStr, &amp;tmpl); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

        case ".md", ".txt":<span class="cov0" title="0">
                // Plain text format - just the template
                tmpl.template = contentStr
                // Derive name from filename (remove extension)
                tmpl.name = strings.TrimSuffix(filename, ext)
                tmpl.description = ""</span>

        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported file format: %s", ext)</span>
        }

        // Extract variables from template
        <span class="cov0" title="0">tmpl.variables = extractVariables(tmpl.template)

        return &amp;tmpl, nil</span>
}

// parsePromptyFormat parses Microsoft Prompty format (YAML frontmatter between ---)
// Format:
// ---
// name: Prompt Name
// description: Description here
// inputs:
//   var1:
//     type: string
// ---
// system:
// Template content here with {{var1}}
func parsePromptyFormat(content string, tmpl *promptTemplate) error <span class="cov0" title="0">{
        // Split by --- markers
        parts := strings.SplitN(content, "---", 3)
        if len(parts) &lt; 3 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid .prompty format: missing --- markers")
        }</span>

        // Parse YAML frontmatter (parts[1])
        <span class="cov0" title="0">var metadata struct {
                Name        string                 `yaml:"name"`
                Description string                 `yaml:"description"`
                Inputs      map[string]interface{} `yaml:"inputs"`
        }

        if err := yaml.Unmarshal([]byte(parts[1]), &amp;metadata); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse YAML frontmatter: %w", err)
        }</span>

        <span class="cov0" title="0">tmpl.name = metadata.Name
        tmpl.description = metadata.Description

        // Template is everything after second ---
        tmpl.template = strings.TrimSpace(parts[2])

        return nil</span>
}

// parseYAMLFormat parses simple YAML format
// Format:
// name: Prompt Name
// description: Description here
// template: |
//   Template content here with {{variables}}
func parseYAMLFormat(content string, tmpl *promptTemplate) error <span class="cov0" title="0">{
        var data struct {
                Name        string `yaml:"name"`
                Description string `yaml:"description"`
                Template    string `yaml:"template"`
        }

        if err := yaml.Unmarshal([]byte(content), &amp;data); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse YAML: %w", err)
        }</span>

        <span class="cov0" title="0">tmpl.name = data.Name
        tmpl.description = data.Description
        tmpl.template = data.Template

        return nil</span>
}

// extractVariables finds all {{VARIABLE}} placeholders in template
func extractVariables(template string) []string <span class="cov0" title="0">{
        // Match {{variable}} pattern (case-insensitive)
        re := regexp.MustCompile(`\{\{([a-zA-Z0-9_]+)\}\}`)
        matches := re.FindAllStringSubmatch(template, -1)

        // Extract unique variable names
        varMap := make(map[string]bool)
        for _, match := range matches </span><span class="cov0" title="0">{
                if len(match) &gt; 1 </span><span class="cov0" title="0">{
                        varMap[match[1]] = true
                }</span>
        }

        // Convert to slice
        <span class="cov0" title="0">vars := make([]string, 0, len(varMap))
        for v := range varMap </span><span class="cov0" title="0">{
                vars = append(vars, v)
        }</span>

        <span class="cov0" title="0">return vars</span>
}

// renderPromptTemplate renders a template by substituting variables
// Variables are case-insensitive ({{file}}, {{FILE}}, {{File}} all match)
func renderPromptTemplate(tmpl *promptTemplate, vars map[string]string) string <span class="cov0" title="0">{
        result := tmpl.template

        // Replace each variable (case-insensitive)
        for varName, value := range vars </span><span class="cov0" title="0">{
                // Try all case variations
                patterns := []string{
                        fmt.Sprintf("{{%s}}", varName),
                        fmt.Sprintf("{{%s}}", strings.ToUpper(varName)),
                        fmt.Sprintf("{{%s}}", strings.ToLower(varName)),
                        fmt.Sprintf("{{%s}}", strings.Title(strings.ToLower(varName))),
                }

                for _, pattern := range patterns </span><span class="cov0" title="0">{
                        result = strings.ReplaceAll(result, pattern, value)
                }</span>
        }

        <span class="cov0" title="0">return result</span>
}

// getContextVariables returns a map of all context variables for rendering
func getContextVariables(m *model) map[string]string <span class="cov0" title="0">{
        vars := make(map[string]string)

        // Get current file info
        currentFile := m.getCurrentFile()
        if currentFile != nil </span><span class="cov0" title="0">{
                vars["file"] = currentFile.path
                vars["filename"] = currentFile.name
        }</span> else<span class="cov0" title="0"> {
                vars["file"] = ""
                vars["filename"] = ""
        }</span>

        // Project info
        <span class="cov0" title="0">vars["project"] = filepath.Base(m.currentPath)
        vars["path"] = m.currentPath

        // Date and time
        now := time.Now()
        vars["DATE"] = now.Format("2006-01-02") // YYYY-MM-DD
        vars["TIME"] = now.Format("15:04")      // HH:MM

        return vars</span>
}

// determinePromptSource determines the source location of a prompt file
func determinePromptSource(path string) string <span class="cov0" title="0">{
        absPath, err := filepath.Abs(path)
        if err != nil </span><span class="cov0" title="0">{
                return "local"
        }</span>

        // Check if in home directory ~/.prompts/
        <span class="cov0" title="0">homeDir, err := os.UserHomeDir()
        if err == nil </span><span class="cov0" title="0">{
                globalPromptsDir := filepath.Join(homeDir, ".prompts")
                if strings.HasPrefix(absPath, globalPromptsDir) </span><span class="cov0" title="0">{
                        return "global"
                }</span>
        }

        // Check if in .claude/commands/
        <span class="cov0" title="0">if strings.Contains(absPath, "/.claude/commands/") </span><span class="cov0" title="0">{
                return "command"
        }</span>

        // Check if in .claude/agents/
        <span class="cov0" title="0">if strings.Contains(absPath, "/.claude/agents/") </span><span class="cov0" title="0">{
                return "agent"
        }</span>

        // Check if in .claude/skills/
        <span class="cov0" title="0">if strings.Contains(absPath, "/.claude/skills/") </span><span class="cov0" title="0">{
                return "skill"
        }</span>

        // Default to local
        <span class="cov0" title="0">return "local"</span>
}

// detectFieldType classifies a variable name into a field type
// Rules:
// - File type: file, filepath, filename, path → fieldTypeFile
// - Long type: code, content, text, body, snippet → fieldTypeLong
// - Short type: everything else → fieldTypeShort
func detectFieldType(varName string) inputFieldType <span class="cov0" title="0">{
        nameLower := strings.ToLower(varName)

        // File-related variables
        fileKeywords := []string{"file", "filepath", "filename", "path"}
        for _, keyword := range fileKeywords </span><span class="cov0" title="0">{
                if strings.Contains(nameLower, keyword) </span><span class="cov0" title="0">{
                        return fieldTypeFile
                }</span>
        }

        // Long text variables
        <span class="cov0" title="0">longKeywords := []string{"code", "content", "text", "body", "snippet"}
        for _, keyword := range longKeywords </span><span class="cov0" title="0">{
                if strings.Contains(nameLower, keyword) </span><span class="cov0" title="0">{
                        return fieldTypeLong
                }</span>
        }

        // Default to short
        <span class="cov0" title="0">return fieldTypeShort</span>
}

// getFieldColor assigns a color code based on variable name and type
// Rules:
// - File variables: blue ("39")
// - Date/Time (auto-filled): green ("34")
// - Custom variables: yellow ("220")
func getFieldColor(varName string, fieldType inputFieldType) string <span class="cov0" title="0">{
        nameLower := strings.ToLower(varName)

        // Auto-filled date/time variables (green)
        if nameLower == "date" || nameLower == "time" </span><span class="cov0" title="0">{
                return "34" // Green
        }</span>

        // File variables (blue)
        <span class="cov0" title="0">if fieldType == fieldTypeFile </span><span class="cov0" title="0">{
                return "39" // Blue
        }</span>

        // Custom variables (yellow)
        <span class="cov0" title="0">return "220"</span> // Yellow
}

// getFilledVariables returns a map of variables filled from input fields
// Uses user-entered values if available, otherwise defaults to context values
func getFilledVariables(fields []promptInputField, m *model) map[string]string <span class="cov0" title="0">{
        vars := getContextVariables(m)

        // Override with user-entered values
        for _, field := range fields </span><span class="cov0" title="0">{
                if field.hasContent() </span><span class="cov0" title="0">{
                        // User entered a value - use it
                        vars[field.name] = field.value
                }</span> else<span class="cov0" title="0"> {
                        // No user value - use default (already in vars from getContextVariables)
                        // But ensure it's set even if not in context
                        if _, exists := vars[field.name]; !exists </span><span class="cov0" title="0">{
                                vars[field.name] = field.defaultValue
                        }</span>
                }
        }

        <span class="cov0" title="0">return vars</span>
}

// createInputFields creates input fields for a prompt template
// Auto-populates defaults from getContextVariables()
// DATE and TIME are auto-filled but still editable (user can override)
func createInputFields(tmpl *promptTemplate, m *model) []promptInputField <span class="cov0" title="0">{
        if tmpl == nil || len(tmpl.variables) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Get context variables for defaults
        <span class="cov0" title="0">contextVars := getContextVariables(m)

        fields := make([]promptInputField, 0)

        for _, varName := range tmpl.variables </span><span class="cov0" title="0">{
                // Detect field type
                fieldType := detectFieldType(varName)

                // Get default value from context (case-insensitive lookup)
                defaultValue := ""
                for ctxKey, ctxVal := range contextVars </span><span class="cov0" title="0">{
                        if strings.EqualFold(ctxKey, varName) </span><span class="cov0" title="0">{
                                defaultValue = ctxVal
                                break</span>
                        }
                }

                // Get color
                <span class="cov0" title="0">color := getFieldColor(varName, fieldType)

                // Calculate display width (will be updated when rendering)
                // For now, set a reasonable default
                displayWidth := 60

                // Create field
                field := promptInputField{
                        name:         varName,
                        value:        "",
                        defaultValue: defaultValue,
                        fieldType:    fieldType,
                        displayWidth: displayWidth,
                        color:        color,
                }

                fields = append(fields, field)</span>
        }

        <span class="cov0" title="0">return fields</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package main

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "github.com/charmbracelet/lipgloss"
)

// getVisibleRange calculates the start and end indices for visible items in the file list
func (m model) getVisibleRange(maxVisible int) (start, end int) <span class="cov0" title="0">{
        start = 0
        end = len(m.files)

        if len(m.files) &gt; maxVisible </span><span class="cov0" title="0">{
                start = m.cursor - maxVisible/2
                if start &lt; 0 </span><span class="cov0" title="0">{
                        start = 0
                }</span>
                <span class="cov0" title="0">end = start + maxVisible
                if end &gt; len(m.files) </span><span class="cov0" title="0">{
                        end = len(m.files)
                        start = end - maxVisible
                        if start &lt; 0 </span><span class="cov0" title="0">{
                                start = 0
                        }</span>
                }
        }
        <span class="cov0" title="0">return start, end</span>
}

// renderListView renders files in a vertical list (current default view)
func (m model) renderListView(maxVisible int) string <span class="cov0" title="0">{
        var s strings.Builder

        // Get filtered files (respects favorites filter)
        files := m.getFilteredFiles()

        // Calculate visible range (simple scrolling)
        start := 0
        end := len(files)
        if len(files) &gt; maxVisible </span><span class="cov0" title="0">{
                start = m.cursor - maxVisible/2
                if start &lt; 0 </span><span class="cov0" title="0">{
                        start = 0
                }</span>
                <span class="cov0" title="0">end = start + maxVisible
                if end &gt; len(files) </span><span class="cov0" title="0">{
                        end = len(files)
                        start = end - maxVisible
                        if start &lt; 0 </span><span class="cov0" title="0">{
                                start = 0
                        }</span>
                }
        }

        <span class="cov0" title="0">for i := start; i &lt; end; i++ </span><span class="cov0" title="0">{
                file := files[i]

                // Get icon based on file type
                icon := getFileIcon(file)
                style := fileStyle

                if file.isDir </span><span class="cov0" title="0">{
                        style = folderStyle
                }</span>

                // Override with orange color if it's a Claude context file
                <span class="cov0" title="0">if isClaudeContextFile(file.name) </span><span class="cov0" title="0">{
                        style = claudeContextStyle
                }</span>

                // Override with purple color if it's an AGENTS.md file
                <span class="cov0" title="0">if isAgentsFile(file.name) </span><span class="cov0" title="0">{
                        style = agentsStyle
                }</span>

                // Override with bright pink if it's the .prompts folder or global prompts virtual folder
                <span class="cov0" title="0">if isPromptsFolder(file.name) || isGlobalPromptsVirtualFolder(file.name) </span><span class="cov0" title="0">{
                        style = promptsFolderStyle
                }</span>

                // Override with bright pink if it's a .claude prompts subfolder (commands, agents, skills)
                <span class="cov0" title="0">if file.isDir &amp;&amp; isClaudePromptsSubfolder(file.name) </span><span class="cov0" title="0">{
                        style = promptsFolderStyle
                }</span>

                // Add star indicator for favorites
                <span class="cov0" title="0">favIndicator := ""
                if m.isFavorite(file.path) </span><span class="cov0" title="0">{
                        favIndicator = "⭐"
                }</span>

                // Truncate long filenames to prevent wrapping
                // In dual-pane mode, use narrower width to fit in left pane
                <span class="cov0" title="0">displayName := file.name
                maxNameLen := 40 // Default for single-pane
                if m.viewMode == viewDualPane </span><span class="cov0" title="0">{
                        // Account for left pane width, icon (2), spaces (2), and padding
                        maxNameLen = m.leftWidth - 10
                        if maxNameLen &lt; 20 </span><span class="cov0" title="0">{
                                maxNameLen = 20 // Minimum reasonable length
                        }</span>
                }
                <span class="cov0" title="0">if len(displayName) &gt; maxNameLen </span><span class="cov0" title="0">{
                        displayName = displayName[:maxNameLen-2] + ".."
                }</span>

                // Build the line
                <span class="cov0" title="0">line := fmt.Sprintf("  %s%s %s", icon, favIndicator, displayName)

                // Apply selection style
                if i == m.cursor </span><span class="cov0" title="0">{
                        line = selectedStyle.Render(line)
                }</span> else<span class="cov0" title="0"> {
                        line = style.Render(line)
                }</span>

                <span class="cov0" title="0">s.WriteString(line)
                s.WriteString("\033[0m") // Reset ANSI codes
                s.WriteString("\n")</span>
        }

        <span class="cov0" title="0">return strings.TrimRight(s.String(), "\n")</span>
}

// renderGridView renders files in a multi-column grid layout
func (m model) renderGridView(maxVisible int) string <span class="cov0" title="0">{
        var s strings.Builder

        // Get filtered files (respects favorites filter)
        files := m.getFilteredFiles()

        // Calculate how many rows we need
        totalItems := len(files)
        rows := (totalItems + m.gridColumns - 1) / m.gridColumns

        // Calculate visible range
        start := 0
        end := rows

        if rows &gt; maxVisible </span><span class="cov0" title="0">{
                cursorRow := m.cursor / m.gridColumns
                start = cursorRow - maxVisible/2
                if start &lt; 0 </span><span class="cov0" title="0">{
                        start = 0
                }</span>
                <span class="cov0" title="0">end = start + maxVisible
                if end &gt; rows </span><span class="cov0" title="0">{
                        end = rows
                        start = end - maxVisible
                        if start &lt; 0 </span><span class="cov0" title="0">{
                                start = 0
                        }</span>
                }
        }

        // Render rows
        <span class="cov0" title="0">for row := start; row &lt; end; row++ </span><span class="cov0" title="0">{
                for col := 0; col &lt; m.gridColumns; col++ </span><span class="cov0" title="0">{
                        idx := row*m.gridColumns + col
                        if idx &gt;= totalItems </span><span class="cov0" title="0">{
                                break</span>
                        }

                        <span class="cov0" title="0">file := files[idx]
                        icon := getFileIcon(file)

                        // Add star indicator for favorites
                        // Always reserve 2 characters for alignment to maintain consistent grid cell width
                        favIndicator := ""
                        if m.isFavorite(file.path) </span><span class="cov0" title="0">{
                                favIndicator = "⭐"
                        }</span> else<span class="cov0" title="0"> {
                                favIndicator = "  " // Two spaces to match emoji width
                        }</span>

                        // Truncate long names
                        <span class="cov0" title="0">displayName := file.name
                        maxNameLen := 12
                        if len(displayName) &gt; maxNameLen </span><span class="cov0" title="0">{
                                displayName = displayName[:maxNameLen-2] + ".."
                        }</span>

                        <span class="cov0" title="0">style := fileStyle
                        if file.isDir </span><span class="cov0" title="0">{
                                style = folderStyle
                        }</span>
                        <span class="cov0" title="0">if isClaudeContextFile(file.name) </span><span class="cov0" title="0">{
                                style = claudeContextStyle
                        }</span>
                        <span class="cov0" title="0">if isAgentsFile(file.name) </span><span class="cov0" title="0">{
                                style = agentsStyle
                        }</span>
                        <span class="cov0" title="0">if isPromptsFolder(file.name) || isGlobalPromptsVirtualFolder(file.name) </span><span class="cov0" title="0">{
                                style = promptsFolderStyle
                        }</span>
                        <span class="cov0" title="0">if file.isDir &amp;&amp; isClaudePromptsSubfolder(file.name) </span><span class="cov0" title="0">{
                                style = promptsFolderStyle
                        }</span>

                        // Build cell content (no space after favIndicator - it's already 2 chars)
                        <span class="cov0" title="0">cell := fmt.Sprintf("%s%s%-12s", icon, favIndicator, displayName)

                        // Apply selection style
                        if idx == m.cursor </span><span class="cov0" title="0">{
                                cell = selectedStyle.Render(cell)
                        }</span> else<span class="cov0" title="0"> {
                                cell = style.Render(cell)
                        }</span>

                        <span class="cov0" title="0">s.WriteString(cell)
                        s.WriteString("\033[0m") // Reset ANSI codes
                        s.WriteString("  ")</span>
                }
                <span class="cov0" title="0">s.WriteString("\n")</span>
        }

        <span class="cov0" title="0">return strings.TrimRight(s.String(), "\n")</span>
}

// renderDetailView renders files in a detailed table with columns
func (m model) renderDetailView(maxVisible int) string <span class="cov0" title="0">{
        var s strings.Builder

        // Get filtered files (respects favorites filter)
        files := m.getFilteredFiles()

        // Header with sort indicators
        headerStyle := lipgloss.NewStyle().
                Bold(true).
                Foreground(lipgloss.Color("87")). // Bright blue for header
                PaddingLeft(2)

        // Determine sort indicator (arrow)
        sortIndicator := ""
        if m.sortAsc </span><span class="cov0" title="0">{
                sortIndicator = " ↑" // Ascending
        }</span> else<span class="cov0" title="0"> {
                sortIndicator = " ↓" // Descending
        }</span>

        // Build header with sort indicators
        <span class="cov0" title="0">var header string
        if m.showFavoritesOnly </span><span class="cov0" title="0">{
                // Favorites mode: Name, Size, Modified, Location
                nameHeader := "Name"
                sizeHeader := "Size"
                modifiedHeader := "Modified"
                locationHeader := "Location"

                // Add indicator to active column
                switch m.sortBy </span>{
                case "name":<span class="cov0" title="0">
                        nameHeader += sortIndicator</span>
                case "size":<span class="cov0" title="0">
                        sizeHeader += sortIndicator</span>
                case "modified":<span class="cov0" title="0">
                        modifiedHeader += sortIndicator</span>
                }

                <span class="cov0" title="0">header = fmt.Sprintf("%-25s  %-10s  %-12s  %-25s", nameHeader, sizeHeader, modifiedHeader, locationHeader)</span>
        } else<span class="cov0" title="0"> {
                // Regular mode: Name, Size, Modified, Type
                nameHeader := "Name"
                sizeHeader := "Size"
                modifiedHeader := "Modified"
                typeHeader := "Type"

                // Add indicator to active column
                switch m.sortBy </span>{
                case "name":<span class="cov0" title="0">
                        nameHeader += sortIndicator</span>
                case "size":<span class="cov0" title="0">
                        sizeHeader += sortIndicator</span>
                case "modified":<span class="cov0" title="0">
                        modifiedHeader += sortIndicator</span>
                case "type":<span class="cov0" title="0">
                        typeHeader += sortIndicator</span>
                }

                <span class="cov0" title="0">header = fmt.Sprintf("%-30s  %-10s  %-12s  %-15s", nameHeader, sizeHeader, modifiedHeader, typeHeader)</span>
        }

        // Render header with sort indicators
        <span class="cov0" title="0">s.WriteString(headerStyle.Render(header))
        s.WriteString("\033[0m") // Reset ANSI codes
        s.WriteString("\n")

        // Calculate visible range
        start := 0
        end := len(files)

        if len(files) &gt; maxVisible-1 </span><span class="cov0" title="0">{ // -1 for header only (separator removed)
                start = m.cursor - (maxVisible-1)/2
                if start &lt; 0 </span><span class="cov0" title="0">{
                        start = 0
                }</span>
                <span class="cov0" title="0">end = start + maxVisible - 1
                if end &gt; len(files) </span><span class="cov0" title="0">{
                        end = len(files)
                        start = end - (maxVisible - 1)
                        if start &lt; 0 </span><span class="cov0" title="0">{
                                start = 0
                        }</span>
                }
        }

        // Render rows
        <span class="cov0" title="0">for i := start; i &lt; end; i++ </span><span class="cov0" title="0">{
                file := files[i]
                icon := getFileIcon(file)

                // Add star indicator for favorites
                favIndicator := ""
                if m.isFavorite(file.path) </span><span class="cov0" title="0">{
                        favIndicator = "⭐"
                }</span>

                // Truncate long names
                <span class="cov0" title="0">displayName := file.name
                maxNameLen := 25
                if len(displayName) &gt; maxNameLen </span><span class="cov0" title="0">{
                        displayName = displayName[:maxNameLen-2] + ".."
                }</span>

                <span class="cov0" title="0">name := fmt.Sprintf("%s%s %s", icon, favIndicator, displayName)
                size := "-"
                if file.isDir </span><span class="cov0" title="0">{
                        // Show item count for directories
                        if file.name == ".." </span><span class="cov0" title="0">{
                                size = "-"
                        }</span> else<span class="cov0" title="0"> {
                                count := getDirItemCount(file.path)
                                if count == 0 </span><span class="cov0" title="0">{
                                        size = "empty"
                                }</span> else<span class="cov0" title="0"> if count == 1 </span><span class="cov0" title="0">{
                                        size = "1 item"
                                }</span> else<span class="cov0" title="0"> {
                                        size = fmt.Sprintf("%d items", count)
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        size = formatFileSize(file.size)
                }</span>
                <span class="cov0" title="0">modified := formatModTime(file.modTime)

                // Show location instead of type when viewing favorites
                var line string
                if m.showFavoritesOnly </span><span class="cov0" title="0">{
                        // Get parent directory path for location
                        location := filepath.Dir(file.path)
                        // Shorten home directory to ~
                        homeDir, _ := os.UserHomeDir()
                        if homeDir != "" &amp;&amp; strings.HasPrefix(location, homeDir) </span><span class="cov0" title="0">{
                                location = "~" + strings.TrimPrefix(location, homeDir)
                        }</span>
                        // Truncate long paths
                        <span class="cov0" title="0">if len(location) &gt; 23 </span><span class="cov0" title="0">{
                                location = "..." + location[len(location)-20:]
                        }</span>
                        <span class="cov0" title="0">line = fmt.Sprintf("%-25s  %-10s  %-12s  %-25s", name, size, modified, location)</span>
                } else<span class="cov0" title="0"> {
                        fileType := getFileType(file)
                        line = fmt.Sprintf("%-30s  %-10s  %-12s  %-15s", name, size, modified, fileType)
                }</span>

                <span class="cov0" title="0">style := fileStyle
                if file.isDir </span><span class="cov0" title="0">{
                        style = folderStyle
                }</span>
                <span class="cov0" title="0">if isClaudeContextFile(file.name) </span><span class="cov0" title="0">{
                        style = claudeContextStyle
                }</span>
                <span class="cov0" title="0">if isAgentsFile(file.name) </span><span class="cov0" title="0">{
                        style = agentsStyle
                }</span>
                <span class="cov0" title="0">if isPromptsFolder(file.name) || isGlobalPromptsVirtualFolder(file.name) </span><span class="cov0" title="0">{
                        style = promptsFolderStyle
                }</span>
                <span class="cov0" title="0">if file.isDir &amp;&amp; isClaudePromptsSubfolder(file.name) </span><span class="cov0" title="0">{
                        style = promptsFolderStyle
                }</span>

                <span class="cov0" title="0">if i == m.cursor </span><span class="cov0" title="0">{
                        line = selectedStyle.Render(line)
                }</span> else<span class="cov0" title="0"> {
                        line = style.Render(line)
                }</span>

                <span class="cov0" title="0">s.WriteString("  ")
                s.WriteString(line)
                s.WriteString("\033[0m") // Reset ANSI codes
                s.WriteString("\n")</span>
        }

        <span class="cov0" title="0">return strings.TrimRight(s.String(), "\n")</span>
}

// buildTreeItems builds a flattened list of tree items including expanded directories
func (m model) buildTreeItems(files []fileItem, depth int, parentLasts []bool) []treeItem <span class="cov0" title="0">{
        items := make([]treeItem, 0)

        for i, file := range files </span><span class="cov0" title="0">{
                isLast := i == len(files)-1

                // Add current item
                item := treeItem{
                        file:        file,
                        depth:       depth,
                        isLast:      isLast,
                        parentLasts: append([]bool{}, parentLasts...), // Copy parent lasts
                }
                items = append(items, item)

                // If this is an expanded directory, recursively add its contents
                if file.isDir &amp;&amp; file.name != ".." &amp;&amp; m.expandedDirs[file.path] </span><span class="cov0" title="0">{
                        // Load subdirectory contents
                        subFiles := m.loadSubdirFiles(file.path)

                        // Apply prompts filtering if active
                        if m.showPromptsOnly </span><span class="cov0" title="0">{
                                filteredSubFiles := make([]fileItem, 0)
                                for _, subFile := range subFiles </span><span class="cov0" title="0">{
                                        if subFile.isDir </span><span class="cov0" title="0">{
                                                // Always include important dev folders
                                                importantFolders := []string{".claude", ".prompts", ".config"}
                                                isImportant := false
                                                for _, folder := range importantFolders </span><span class="cov0" title="0">{
                                                        if subFile.name == folder </span><span class="cov0" title="0">{
                                                                isImportant = true
                                                                break</span>
                                                        }
                                                }
                                                <span class="cov0" title="0">if isImportant </span><span class="cov0" title="0">{
                                                        filteredSubFiles = append(filteredSubFiles, subFile)
                                                        continue</span>
                                                }

                                                // Include directory if it contains prompt files
                                                <span class="cov0" title="0">if directoryContainsPrompts(subFile.path) </span><span class="cov0" title="0">{
                                                        filteredSubFiles = append(filteredSubFiles, subFile)
                                                }</span>
                                        } else<span class="cov0" title="0"> if isPromptFile(subFile) </span><span class="cov0" title="0">{
                                                // Only include prompt files
                                                filteredSubFiles = append(filteredSubFiles, subFile)
                                        }</span>
                                }
                                <span class="cov0" title="0">subFiles = filteredSubFiles</span>
                        }

                        <span class="cov0" title="0">if len(subFiles) &gt; 0 </span><span class="cov0" title="0">{
                                // Update parentLasts for children
                                newParentLasts := append(parentLasts, isLast)
                                subItems := m.buildTreeItems(subFiles, depth+1, newParentLasts)
                                items = append(items, subItems...)
                        }</span>
                }
        }

        <span class="cov0" title="0">return items</span>
}

// updateTreeItems rebuilds the tree items cache (called before rendering tree view)
func (m *model) updateTreeItems() <span class="cov0" title="0">{
        files := m.getFilteredFiles()
        m.treeItems = m.buildTreeItems(files, 0, []bool{})
}</span>

// renderTreeView renders files in a hierarchical tree structure with expandable folders
func (m model) renderTreeView(maxVisible int) string <span class="cov0" title="0">{
        var s strings.Builder

        // Use cached tree items (should be updated before rendering)
        treeItems := m.treeItems

        // Calculate visible range
        start := 0
        end := len(treeItems)
        if len(treeItems) &gt; maxVisible </span><span class="cov0" title="0">{
                start = m.cursor - maxVisible/2
                if start &lt; 0 </span><span class="cov0" title="0">{
                        start = 0
                }</span>
                <span class="cov0" title="0">end = start + maxVisible
                if end &gt; len(treeItems) </span><span class="cov0" title="0">{
                        end = len(treeItems)
                        start = end - maxVisible
                        if start &lt; 0 </span><span class="cov0" title="0">{
                                start = 0
                        }</span>
                }
        }

        <span class="cov0" title="0">for i := start; i &lt; end; i++ </span><span class="cov0" title="0">{
                item := treeItems[i]
                file := item.file

                // Build indentation with tree characters
                var indent strings.Builder
                indent.WriteString("  ") // Base padding

                // Draw vertical lines for parent levels
                for j := 0; j &lt; item.depth; j++ </span><span class="cov0" title="0">{
                        if j &lt; len(item.parentLasts) &amp;&amp; !item.parentLasts[j] </span><span class="cov0" title="0">{
                                indent.WriteString("│  ")
                        }</span> else<span class="cov0" title="0"> {
                                indent.WriteString("   ")
                        }</span>
                }

                // Draw tree connector
                <span class="cov0" title="0">var prefix string
                if file.name == ".." </span><span class="cov0" title="0">{
                        prefix = "↑  "
                }</span> else<span class="cov0" title="0"> if item.isLast </span><span class="cov0" title="0">{
                        prefix = "└─ "
                }</span> else<span class="cov0" title="0"> {
                        prefix = "├─ "
                }</span>

                // Add expansion indicator for directories
                <span class="cov0" title="0">expansionIndicator := ""
                if file.isDir &amp;&amp; file.name != ".." </span><span class="cov0" title="0">{
                        if m.expandedDirs[file.path] </span><span class="cov0" title="0">{
                                expansionIndicator = "▼ " // Expanded
                        }</span> else<span class="cov0" title="0"> {
                                expansionIndicator = "▶ " // Collapsed
                        }</span>
                }

                <span class="cov0" title="0">icon := getFileIcon(file)
                style := fileStyle

                if file.isDir </span><span class="cov0" title="0">{
                        style = folderStyle
                }</span>

                <span class="cov0" title="0">if isClaudeContextFile(file.name) </span><span class="cov0" title="0">{
                        style = claudeContextStyle
                }</span>

                <span class="cov0" title="0">if isAgentsFile(file.name) </span><span class="cov0" title="0">{
                        style = agentsStyle
                }</span>

                <span class="cov0" title="0">if isPromptsFolder(file.name) || isGlobalPromptsVirtualFolder(file.name) </span><span class="cov0" title="0">{
                        style = promptsFolderStyle
                }</span>

                <span class="cov0" title="0">if file.isDir &amp;&amp; isClaudePromptsSubfolder(file.name) </span><span class="cov0" title="0">{
                        style = promptsFolderStyle
                }</span>

                // Add star indicator for favorites
                <span class="cov0" title="0">favIndicator := ""
                if m.isFavorite(file.path) </span><span class="cov0" title="0">{
                        favIndicator = "⭐"
                }</span>

                // Truncate long filenames to prevent wrapping
                <span class="cov0" title="0">displayName := file.name

                // Calculate available width dynamically based on view mode
                var maxNameLen int
                if m.viewMode == viewDualPane </span><span class="cov0" title="0">{
                        // In dual-pane: use left pane width minus UI elements
                        // Account for: indent, tree chars, icon, favorite, padding
                        indentWidth := 2 + (item.depth * 3) + 3 + 2 + 2 + 5
                        maxNameLen = m.leftWidth - indentWidth
                }</span> else<span class="cov0" title="0"> {
                        // In single-pane: use full width minus UI elements
                        indentWidth := 2 + (item.depth * 3) + 3 + 2 + 2 + 5
                        maxNameLen = m.width - indentWidth
                }</span>

                // Set reasonable bounds
                <span class="cov0" title="0">if maxNameLen &lt; 20 </span><span class="cov0" title="0">{
                        maxNameLen = 20
                }</span>
                <span class="cov0" title="0">if maxNameLen &gt; 100 </span><span class="cov0" title="0">{
                        maxNameLen = 100 // Reasonable maximum
                }</span>

                <span class="cov0" title="0">if len(displayName) &gt; maxNameLen </span><span class="cov0" title="0">{
                        displayName = displayName[:maxNameLen-2] + ".."
                }</span>

                <span class="cov0" title="0">line := fmt.Sprintf("%s%s%s%s%s %s", indent.String(), prefix, expansionIndicator, icon, favIndicator, displayName)

                if i == m.cursor </span><span class="cov0" title="0">{
                        line = selectedStyle.Render(line)
                }</span> else<span class="cov0" title="0"> {
                        line = style.Render(line)
                }</span>

                <span class="cov0" title="0">s.WriteString(line)
                s.WriteString("\033[0m") // Reset ANSI codes
                s.WriteString("\n")</span>
        }

        <span class="cov0" title="0">return strings.TrimRight(s.String(), "\n")</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package main

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/charmbracelet/lipgloss"
)

// getWrappedLineCount calculates the total number of wrapped lines for the current preview
func (m model) getWrappedLineCount() int <span class="cov0" title="0">{
        if !m.preview.loaded </span><span class="cov0" title="0">{
                return 0
        }</span>

        // Calculate available width based on file type and view mode
        <span class="cov0" title="0">var availableWidth int
        var boxContentWidth int

        if m.viewMode == viewFullPreview </span><span class="cov0" title="0">{
                boxContentWidth = m.width - 6 // Box content width in full preview
        }</span> else<span class="cov0" title="0"> {
                boxContentWidth = m.rightWidth - 2 // Box content width in dual-pane
        }</span>

        <span class="cov0" title="0">if m.preview.isMarkdown </span><span class="cov0" title="0">{
                // Markdown: no line numbers or scrollbar, content uses full box width
                availableWidth = boxContentWidth
        }</span> else<span class="cov0" title="0"> {
                // Regular text: subtract line nums (6) + scrollbar (1) + space (1) = 8 chars
                availableWidth = boxContentWidth - 8
        }</span>

        <span class="cov0" title="0">if availableWidth &lt; 20 </span><span class="cov0" title="0">{
                availableWidth = 20
        }</span>

        // Use cached line count if available and width matches
        <span class="cov0" title="0">if m.preview.cacheValid &amp;&amp; m.preview.cachedLineCount &gt; 0 &amp;&amp; m.preview.cachedWidth == availableWidth </span><span class="cov0" title="0">{
                return m.preview.cachedLineCount
        }</span>

        // For markdown, we need to render it to count lines
        <span class="cov0" title="0">if m.preview.isMarkdown </span><span class="cov0" title="0">{
                markdownContent := strings.Join(m.preview.content, "\n")
                // Use cached rendering with timeout to prevent hangs
                // Note: renderMarkdownWithTimeout is in file_operations.go
                rendered, err := renderMarkdownWithTimeout(markdownContent, availableWidth, 5*time.Second)
                if err == nil </span><span class="cov0" title="0">{
                        renderedLines := strings.Split(strings.TrimRight(rendered, "\n"), "\n")
                        return len(renderedLines)
                }</span>
                // Fallback if glamour fails or times out
        }

        // For regular text, count wrapped lines
        <span class="cov0" title="0">totalLines := 0
        for _, line := range m.preview.content </span><span class="cov0" title="0">{
                wrapped := wrapLine(line, availableWidth)
                totalLines += len(wrapped)
        }</span>
        <span class="cov0" title="0">return totalLines</span>
}

// wrapLine wraps a line of text to fit within the specified width
func wrapLine(line string, width int) []string <span class="cov0" title="0">{
        if width &lt;= 0 </span><span class="cov0" title="0">{
                return []string{line}
        }</span>

        // Handle empty lines
        <span class="cov0" title="0">if len(line) == 0 </span><span class="cov0" title="0">{
                return []string{""}
        }</span>

        <span class="cov0" title="0">var wrapped []string
        currentLine := ""
        currentWidth := 0

        words := strings.Fields(line)
        if len(words) == 0 </span><span class="cov0" title="0">{
                // Line is only whitespace
                return []string{line}
        }</span>

        <span class="cov0" title="0">for i, word := range words </span><span class="cov0" title="0">{
                wordWidth := visualWidth(word)
                spaceWidth := 1

                // Check if this word fits on the current line
                if currentWidth == 0 </span><span class="cov0" title="0">{
                        // First word on line
                        if wordWidth &lt;= width </span><span class="cov0" title="0">{
                                currentLine = word
                                currentWidth = wordWidth
                        }</span> else<span class="cov0" title="0"> {
                                // Word is too long, force break it
                                wrapped = append(wrapped, word[:width])
                                currentLine = ""
                                currentWidth = 0
                        }</span>
                } else<span class="cov0" title="0"> if currentWidth+spaceWidth+wordWidth &lt;= width </span><span class="cov0" title="0">{
                        // Word fits on current line
                        currentLine += " " + word
                        currentWidth += spaceWidth + wordWidth
                }</span> else<span class="cov0" title="0"> {
                        // Word doesn't fit, start new line
                        wrapped = append(wrapped, currentLine)
                        if wordWidth &lt;= width </span><span class="cov0" title="0">{
                                currentLine = word
                                currentWidth = wordWidth
                        }</span> else<span class="cov0" title="0"> {
                                // Word is too long, force break it
                                wrapped = append(wrapped, word[:width])
                                currentLine = ""
                                currentWidth = 0
                        }</span>
                }

                // If this is the last word, add the current line
                <span class="cov0" title="0">if i == len(words)-1 &amp;&amp; currentLine != "" </span><span class="cov0" title="0">{
                        wrapped = append(wrapped, currentLine)
                }</span>
        }

        <span class="cov0" title="0">if len(wrapped) == 0 </span><span class="cov0" title="0">{
                return []string{line}
        }</span>

        <span class="cov0" title="0">return wrapped</span>
}

// renderPreview renders the preview pane content with scrollbar
func (m model) renderPreview(maxVisible int) string <span class="cov0" title="0">{
        var s strings.Builder

        if !m.preview.loaded </span><span class="cov0" title="0">{
                s.WriteString("No file loaded")
                return s.String()
        }</span>

        // If this is a prompt file, show metadata header
        <span class="cov0" title="0">if m.preview.isPrompt &amp;&amp; m.preview.promptTemplate != nil </span><span class="cov0" title="0">{
                return m.renderPromptPreview(maxVisible)
        }</span>

        // Calculate available width for content based on file type and view mode
        <span class="cov0" title="0">var availableWidth int
        var boxContentWidth int // Width of the box content area

        if m.viewMode == viewFullPreview </span><span class="cov0" title="0">{
                boxContentWidth = m.width - 6 // Box content width in full preview
        }</span> else<span class="cov0" title="0"> {
                boxContentWidth = m.rightWidth - 2 // Box content width in dual-pane (accounting for borders)
        }</span>

        <span class="cov0" title="0">if m.preview.isMarkdown </span><span class="cov0" title="0">{
                // Markdown: no line numbers or scrollbar, content uses full box width
                availableWidth = boxContentWidth
        }</span> else<span class="cov0" title="0"> {
                // Regular text: subtract line nums (6) + scrollbar (1) + space (1) = 8 chars
                availableWidth = boxContentWidth - 8
        }</span>

        <span class="cov0" title="0">if availableWidth &lt; 20 </span><span class="cov0" title="0">{
                availableWidth = 20 // Minimum width
        }</span>

        // If markdown, render with Glamour
        <span class="cov0" title="0">if m.preview.isMarkdown &amp;&amp; m.preview.cachedRenderedContent != "" </span><span class="cov0" title="0">{
                // Use cached Glamour-rendered content (no line numbers)
                if m.preview.cachedRenderedContent != "" </span><span class="cov0" title="0">{
                        renderedLines := strings.Split(strings.TrimRight(m.preview.cachedRenderedContent, "\n"), "\n")

                        // Calculate visible range based on scroll position
                        totalLines := len(renderedLines)
                        start := m.preview.scrollPos

                        if start &lt; 0 </span><span class="cov0" title="0">{
                                start = 0
                        }</span>
                        <span class="cov0" title="0">if start &gt;= totalLines </span><span class="cov0" title="0">{
                                start = max(0, totalLines-maxVisible)
                        }</span>

                        <span class="cov0" title="0">end := start + maxVisible
                        if end &gt; totalLines </span><span class="cov0" title="0">{
                                end = totalLines
                        }</span>

                        // Render visible lines without line numbers for markdown
                        <span class="cov0" title="0">for i := start; i &lt; end; i++ </span><span class="cov0" title="0">{
                                s.WriteString(renderedLines[i])
                                s.WriteString("\033[0m") // Reset ANSI codes to prevent bleed
                                s.WriteString("\n")
                        }</span>

                        <span class="cov0" title="0">return strings.TrimRight(s.String(), "\n")</span>
                }
                // If markdown flag is set but no rendered content, fall through to plain text rendering
                // This happens when Glamour fails or file is too large
        }

        // Wrap all lines first (use cache if available and width matches)
        <span class="cov0" title="0">var wrappedLines []string
        if m.preview.cacheValid &amp;&amp; len(m.preview.cachedWrappedLines) &gt; 0 &amp;&amp; m.preview.cachedWidth == availableWidth </span><span class="cov0" title="0">{
                // Use cached wrapped lines
                wrappedLines = m.preview.cachedWrappedLines
        }</span> else<span class="cov0" title="0"> {
                // Wrap lines (will be slow for large files without cache)
                for _, line := range m.preview.content </span><span class="cov0" title="0">{
                        wrapped := wrapLine(line, availableWidth)
                        wrappedLines = append(wrappedLines, wrapped...)
                }</span>
        }

        // Calculate visible range based on scroll position
        <span class="cov0" title="0">totalLines := len(wrappedLines)
        start := m.preview.scrollPos

        // Ensure start is within bounds
        if start &lt; 0 </span><span class="cov0" title="0">{
                start = 0
        }</span>
        <span class="cov0" title="0">if start &gt;= totalLines </span><span class="cov0" title="0">{
                start = max(0, totalLines-maxVisible)
        }</span>

        <span class="cov0" title="0">end := start + maxVisible
        if end &gt; totalLines </span><span class="cov0" title="0">{
                end = totalLines
        }</span>

        // Render lines with line numbers and scrollbar
        <span class="cov0" title="0">for i := start; i &lt; end; i++ </span><span class="cov0" title="0">{
                // Line number (5 chars)
                lineNum := fmt.Sprintf("%5d ", i+1)
                lineNumStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("241"))
                s.WriteString(lineNumStyle.Render(lineNum))

                // Scrollbar right after line number (replaces the │ separator)
                scrollbar := m.renderScrollbar(i-start, maxVisible, totalLines)
                s.WriteString(scrollbar)

                // Space after scrollbar
                s.WriteString(" ")

                // Content line
                s.WriteString(wrappedLines[i])
                s.WriteString("\033[0m") // Reset ANSI codes to prevent bleed
                s.WriteString("\n")
        }</span>

        <span class="cov0" title="0">return strings.TrimRight(s.String(), "\n")</span>
}

// highlightPromptVariables highlights {{variables}} in template text with assigned colors
func (m model) highlightPromptVariables(templateText string) string <span class="cov0" title="0">{
        if !m.inputFieldsActive || len(m.promptInputFields) == 0 </span><span class="cov0" title="0">{
                return templateText
        }</span>

        // Build a map of variable names to colors
        <span class="cov0" title="0">colorMap := make(map[string]string)
        for _, field := range m.promptInputFields </span><span class="cov0" title="0">{
                colorMap[field.name] = field.color
        }</span>

        // Auto-filled variables (DATE, TIME) should already be in fields with green color
        // But check template variables in case they exist but weren't added as fields
        <span class="cov0" title="0">if m.preview.promptTemplate != nil </span><span class="cov0" title="0">{
                for _, varName := range m.preview.promptTemplate.variables </span><span class="cov0" title="0">{
                        // Only add if not already in colorMap (from fields)
                        if _, exists := colorMap[varName]; !exists </span><span class="cov0" title="0">{
                                varLower := strings.ToLower(varName)
                                if varLower == "date" || varLower == "time" </span><span class="cov0" title="0">{
                                        colorMap[varName] = "34" // Green
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">result := templateText

        // Replace each {{variable}} with colored version
        // Try all case variations for each variable
        for varName, color := range colorMap </span><span class="cov0" title="0">{
                variations := []string{
                        varName,
                        strings.ToUpper(varName),
                        strings.ToLower(varName),
                        strings.Title(strings.ToLower(varName)),
                }

                for _, variant := range variations </span><span class="cov0" title="0">{
                        pattern := "{{" + variant + "}}"
                        // ANSI color: \033[38;5;&lt;color&gt;m for foreground
                        colored := fmt.Sprintf("\033[38;5;%sm{{%s}}\033[0m", color, variant)
                        result = strings.ReplaceAll(result, pattern, colored)
                }</span>
        }

        <span class="cov0" title="0">return result</span>
}

// renderInputFields renders the input fields section below the preview
func (m model) renderInputFields(availableWidth, availableHeight int) string <span class="cov0" title="0">{
        if !m.inputFieldsActive || len(m.promptInputFields) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">var s strings.Builder

        // Title for input fields section
        titleStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("39"))
        s.WriteString(titleStyle.Render("📝 Fillable Fields"))
        s.WriteString("\n")

        // Help text
        helpStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("242")).Italic(true)
        s.WriteString(helpStyle.Render("Tab: Navigate • Type: Edit • F3: File Picker • F5: Copy • 🕐 Auto-filled"))
        s.WriteString("\n\n")

        // Calculate how many fields we can show (reserve 3 lines: title + help + blank)
        headerLines := 3
        linesPerField := 2 // Label line + input line
        maxFields := (availableHeight - headerLines) / linesPerField
        if maxFields &lt; 1 </span><span class="cov0" title="0">{
                maxFields = 1
        }</span>

        // Render each field
        <span class="cov0" title="0">fieldsShown := 0
        for i, field := range m.promptInputFields </span><span class="cov0" title="0">{
                if fieldsShown &gt;= maxFields </span><span class="cov0" title="0">{
                        // Show "... X more fields" message
                        remainingCount := len(m.promptInputFields) - fieldsShown
                        moreStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("242")).Italic(true)
                        s.WriteString(moreStyle.Render(fmt.Sprintf("... %d more field(s) below", remainingCount)))
                        break</span>
                }

                // Field label (no indicator - it goes on the value line)
                <span class="cov0" title="0">labelStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(field.color))
                fieldTypeIndicator := ""

                // Check if this is an auto-filled field (DATE/TIME)
                fieldNameLower := strings.ToLower(field.name)
                isAutoFilled := fieldNameLower == "date" || fieldNameLower == "time"

                if isAutoFilled </span><span class="cov0" title="0">{
                        fieldTypeIndicator = " 🕐" // Clock icon for auto-filled time/date
                }</span> else<span class="cov0" title="0"> {
                        switch field.fieldType </span>{
                        case fieldTypeFile:<span class="cov0" title="0">
                                fieldTypeIndicator = " 📁"</span>
                        case fieldTypeLong:<span class="cov0" title="0">
                                fieldTypeIndicator = " 📝"</span>
                        }
                }

                <span class="cov0" title="0">s.WriteString("  ")
                s.WriteString(labelStyle.Render(field.name + fieldTypeIndicator + ":"))
                s.WriteString("\n")

                // Field value with focus indicator
                focusIndicator := "  "
                if i == m.focusedInputField </span><span class="cov0" title="0">{
                        focusIndicator = "▶ "
                }</span>

                <span class="cov0" title="0">displayValue := field.getDisplayValue()
                charCount := field.getCharCountDisplay()

                // Build the input display
                inputStyle := lipgloss.NewStyle()
                if i == m.focusedInputField </span><span class="cov0" title="0">{
                        // Focused field - highlighted background
                        inputStyle = inputStyle.Background(lipgloss.Color("235"))
                }</span>

                // Show [...] prefix for truncated long content
                <span class="cov0" title="0">valueDisplay := displayValue
                if field.hasContent() &amp;&amp; len(field.value) &gt; len(displayValue) </span><span class="cov0" title="0">{
                        // Truncated - add prefix
                        valueDisplay = "[...]" + displayValue + charCount
                }</span> else<span class="cov0" title="0"> if charCount != "" </span><span class="cov0" title="0">{
                        valueDisplay = displayValue + charCount
                }</span>

                // Dim style if showing default (not user-entered)
                <span class="cov0" title="0">if !field.hasContent() </span><span class="cov0" title="0">{
                        inputStyle = inputStyle.Foreground(lipgloss.Color("242"))
                        valueDisplay = displayValue + " (default)"
                }</span>

                <span class="cov0" title="0">s.WriteString(focusIndicator)
                s.WriteString(inputStyle.Render(valueDisplay))
                s.WriteString("\n")

                fieldsShown++</span>
        }

        <span class="cov0" title="0">return s.String()</span>
}

// renderPromptPreview renders a prompt file with metadata header
func (m model) renderPromptPreview(maxVisible int) string <span class="cov0" title="0">{
        var s strings.Builder
        tmpl := m.preview.promptTemplate

        // Build header lines
        var headerLines []string

        // Prompt name (if available)
        if tmpl.name != "" </span><span class="cov0" title="0">{
                nameStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("39"))
                headerLines = append(headerLines, nameStyle.Render("📝 "+tmpl.name))
                headerLines = append(headerLines, "") // Blank line
        }</span>

        // Description (if available)
        <span class="cov0" title="0">if tmpl.description != "" </span><span class="cov0" title="0">{
                descStyle := lipgloss.NewStyle().Italic(true).Foreground(lipgloss.Color("245"))
                headerLines = append(headerLines, descStyle.Render(tmpl.description))
                headerLines = append(headerLines, "") // Blank line
        }</span>

        // Source indicator
        <span class="cov0" title="0">sourceStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("242"))
        sourceIcon := ""
        sourceLabel := ""
        switch tmpl.source </span>{
        case "global":<span class="cov0" title="0">
                sourceIcon = "🌐"
                sourceLabel = "Global Prompt (~/.prompts/)"</span>
        case "command":<span class="cov0" title="0">
                sourceIcon = "⚙️"
                sourceLabel = "Project Command (.claude/commands/)"</span>
        case "agent":<span class="cov0" title="0">
                sourceIcon = "🤖"
                sourceLabel = "Project Agent (.claude/agents/)"</span>
        case "skill":<span class="cov0" title="0">
                sourceIcon = "🎯"
                sourceLabel = "Project Skill (.claude/skills/)"</span>
        case "local":<span class="cov0" title="0">
                sourceIcon = "📁"
                sourceLabel = "Local Prompt"</span>
        }
        <span class="cov0" title="0">headerLines = append(headerLines, sourceStyle.Render(sourceIcon+" "+sourceLabel))

        // Variables detected (if any)
        if len(tmpl.variables) &gt; 0 </span><span class="cov0" title="0">{
                varsStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("242"))
                varsLine := fmt.Sprintf("Variables: %s", strings.Join(tmpl.variables, ", "))
                headerLines = append(headerLines, varsStyle.Render(varsLine))
        }</span>

        // Separator line
        <span class="cov0" title="0">separatorStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("240"))
        headerLines = append(headerLines, separatorStyle.Render("─────────────────────────────────────"))
        headerLines = append(headerLines, "") // Blank line before content

        // Calculate how many lines the header takes
        headerHeight := len(headerLines)

        // Calculate available width
        var availableWidth int
        var boxContentWidth int

        if m.viewMode == viewFullPreview </span><span class="cov0" title="0">{
                boxContentWidth = m.width - 6
        }</span> else<span class="cov0" title="0"> {
                boxContentWidth = m.rightWidth - 2
        }</span>

        // Prompts don't show line numbers, so use full width
        <span class="cov0" title="0">availableWidth = boxContentWidth - 2 // Just padding

        if availableWidth &lt; 20 </span><span class="cov0" title="0">{
                availableWidth = 20
        }</span>

        // Determine content to display based on input fields state
        <span class="cov0" title="0">var contentLines []string
        var isMarkdownPrompt bool

        if m.inputFieldsActive </span><span class="cov0" title="0">{
                // Show template with highlighted variables (no Glamour - colors would conflict)
                highlightedTemplate := m.highlightPromptVariables(tmpl.template)
                contentLines = strings.Split(highlightedTemplate, "\n")
                isMarkdownPrompt = false // Don't apply Glamour when showing variable highlights
        }</span> else<span class="cov0" title="0"> {
                // Show substituted content - apply Glamour if markdown
                contentText := strings.Join(m.preview.content, "\n")

                // Check if this is a markdown file
                isMarkdownPrompt = m.preview.isMarkdown

                if isMarkdownPrompt </span><span class="cov0" title="0">{
                        // Render with Glamour for beautiful formatting (with timeout to prevent hangs)
                        rendered, err := renderMarkdownWithTimeout(contentText, availableWidth, 5*time.Second)
                        if err == nil </span><span class="cov0" title="0">{
                                // Successfully rendered with Glamour
                                contentLines = strings.Split(strings.TrimRight(rendered, "\n"), "\n")
                        }</span> else<span class="cov0" title="0"> {
                                // Glamour failed or timed out, fall back to plain text
                                contentLines = m.preview.content
                                isMarkdownPrompt = false
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Not markdown, use plain text
                        contentLines = m.preview.content
                }</span>
        }

        // Wrap content lines (only if not markdown - Glamour already wraps)
        <span class="cov0" title="0">var wrappedLines []string
        if isMarkdownPrompt </span><span class="cov0" title="0">{
                // Glamour already wrapped the text, use as-is
                wrappedLines = contentLines
        }</span> else<span class="cov0" title="0"> {
                // Plain text - wrap manually
                for _, line := range contentLines </span><span class="cov0" title="0">{
                        wrapped := wrapLine(line, availableWidth)
                        wrappedLines = append(wrappedLines, wrapped...)
                }</span>
        }

        // Calculate available height for content and input fields
        <span class="cov0" title="0">var contentHeight int
        var inputFieldsSection string

        if m.inputFieldsActive </span><span class="cov0" title="0">{
                // Reserve space for input fields (approximately 1/3 of available space)
                inputFieldsHeight := maxVisible / 3
                if inputFieldsHeight &lt; 8 </span><span class="cov0" title="0">{
                        inputFieldsHeight = 8 // Minimum for at least 2 fields
                }</span>
                <span class="cov0" title="0">contentHeight = maxVisible - headerHeight - inputFieldsHeight
                if contentHeight &lt; 5 </span><span class="cov0" title="0">{
                        contentHeight = 5
                }</span>

                // Render input fields section
                <span class="cov0" title="0">inputFieldsSection = m.renderInputFields(availableWidth, inputFieldsHeight)</span>
        } else<span class="cov0" title="0"> {
                // No input fields - use all available space for content
                contentHeight = maxVisible - headerHeight
                if contentHeight &lt; 5 </span><span class="cov0" title="0">{
                        contentHeight = 5
                }</span>
        }

        // Calculate visible range for content
        <span class="cov0" title="0">totalLines := len(wrappedLines)
        start := m.preview.scrollPos

        if start &lt; 0 </span><span class="cov0" title="0">{
                start = 0
        }</span>
        <span class="cov0" title="0">if start &gt;= totalLines </span><span class="cov0" title="0">{
                start = max(0, totalLines-contentHeight)
        }</span>

        <span class="cov0" title="0">end := start + contentHeight
        if end &gt; totalLines </span><span class="cov0" title="0">{
                end = totalLines
        }</span>

        // Render header
        <span class="cov0" title="0">for _, line := range headerLines </span><span class="cov0" title="0">{
                s.WriteString(line)
                s.WriteString("\033[0m") // Reset ANSI codes
                s.WriteString("\n")
        }</span>

        // Render content (no line numbers for prompts)
        <span class="cov0" title="0">for i := start; i &lt; end; i++ </span><span class="cov0" title="0">{
                s.WriteString(wrappedLines[i])
                s.WriteString("\033[0m") // Reset ANSI codes
                s.WriteString("\n")
        }</span>

        // Render input fields section if active
        <span class="cov0" title="0">if m.inputFieldsActive &amp;&amp; inputFieldsSection != "" </span><span class="cov0" title="0">{
                s.WriteString("\n")
                separatorStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("240"))
                s.WriteString(separatorStyle.Render("─────────────────────────────────────"))
                s.WriteString("\n")
                s.WriteString(inputFieldsSection)
        }</span>

        <span class="cov0" title="0">return strings.TrimRight(s.String(), "\n")</span>
}

// renderScrollbar renders a scrollbar indicator for the current line
// Now renders in place of the separator between line numbers and content
func (m model) renderScrollbar(lineIndex, visibleLines, totalLines int) string <span class="cov0" title="0">{
        // Calculate scrollbar position
        // The scrollbar thumb should represent the visible portion of the content
        scrollbarHeight := visibleLines
        thumbSize := max(1, (visibleLines*scrollbarHeight)/totalLines)
        thumbStart := (m.preview.scrollPos * scrollbarHeight) / totalLines

        scrollbarStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("240"))
        scrollbarThumbStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("39"))

        // Determine what to render for this line
        if lineIndex &gt;= thumbStart &amp;&amp; lineIndex &lt; thumbStart+thumbSize </span><span class="cov0" title="0">{
                // This line is part of the scrollbar thumb (bright blue)
                return scrollbarThumbStyle.Render("│")
        }</span> else<span class="cov0" title="0"> {
                // This line is part of the scrollbar track (dim gray)
                return scrollbarStyle.Render("│")
        }</span>
}

// max returns the maximum of two integers
func max(a, b int) int <span class="cov0" title="0">{
        if a &gt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}

// renderFullPreview renders the full-screen preview mode
func (m model) renderFullPreview() string <span class="cov0" title="0">{
        var s strings.Builder

        // Title bar with file name
        previewTitleStyle := lipgloss.NewStyle().
                Bold(true).
                Foreground(lipgloss.AdaptiveColor{Light: "#ffffff", Dark: "#ffffff"}).
                Background(lipgloss.AdaptiveColor{Light: "#0087d7", Dark: "#00d7ff"}).
                Width(m.width).
                Padding(0, 1)

        titleText := fmt.Sprintf("Preview: %s", m.preview.fileName)
        if m.preview.tooLarge || m.preview.isBinary </span><span class="cov0" title="0">{
                titleText += " [Cannot Preview]"
        }</span>
        <span class="cov0" title="0">if m.preview.isPrompt </span><span class="cov0" title="0">{
                titleText += " [Prompt Template]"
        }</span> else<span class="cov0" title="0"> if m.preview.isMarkdown </span><span class="cov0" title="0">{
                titleText += " [Markdown]"
        }</span>
        <span class="cov0" title="0">s.WriteString(previewTitleStyle.Render(titleText))
        s.WriteString("\033[0m") // Reset ANSI codes
        s.WriteString("\n")

        // File info line - update based on whether we're showing markdown or wrapped text
        var infoText string
        if m.preview.isMarkdown </span><span class="cov0" title="0">{
                infoText = fmt.Sprintf("Size: %s | Markdown Rendered",
                        formatFileSize(m.preview.fileSize))
        }</span> else<span class="cov0" title="0"> {
                infoText = fmt.Sprintf("Size: %s | Lines: %d (wrapped) | Scroll: %d",
                        formatFileSize(m.preview.fileSize),
                        len(m.preview.content),
                        m.preview.scrollPos+1)
        }</span>
        <span class="cov0" title="0">s.WriteString(pathStyle.Render(infoText))
        s.WriteString("\033[0m") // Reset ANSI codes
        s.WriteString("\n")

        // Content with border
        maxVisible := m.height - 6 // Reserve space for title, info, help (total box height INCLUDING borders)
        contentHeight := maxVisible - 2 // Content area accounting for borders
        previewContent := m.renderPreview(contentHeight)

        // Wrap preview in bordered box with fixed dimensions
        // Content is constrained to contentHeight lines to fit within the box
        previewBoxStyle := lipgloss.NewStyle().
                Width(m.width - 6).       // Leave margin for borders
                Height(contentHeight).    // Content area height (borders added by Lipgloss)
                Border(lipgloss.RoundedBorder()).
                BorderForeground(lipgloss.AdaptiveColor{
                        Light: "#00af87", // Teal for light
                        Dark:  "#5faf87",  // Light teal for dark
                })

        s.WriteString(previewBoxStyle.Render(previewContent))

        // Help text
        s.WriteString("\n")
        helpStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("241")).PaddingLeft(2)

        // Show different F5 text if viewing a prompt (with or without fillable fields)
        f5Text := "copy path"
        if m.preview.isPrompt || (m.inputFieldsActive &amp;&amp; len(m.promptInputFields) &gt; 0) </span><span class="cov0" title="0">{
                f5Text = "copy rendered prompt"
        }</span>
        <span class="cov0" title="0">helpText := fmt.Sprintf("↑/↓: scroll • PgUp/PgDown: page • F4: edit • F5: %s • Esc: close • F10: quit", f5Text)
        s.WriteString(helpStyle.Render(helpText))
        s.WriteString("\033[0m") // Reset ANSI codes

        return s.String()</span>
}

// renderDualPane renders the split-pane layout using Lipgloss layout utilities
func (m model) renderDualPane() string <span class="cov0" title="0">{
        var s strings.Builder

        // Title with mode indicator and GitHub link
        titleText := "(T)erminal (F)ile (E)xplorer [Dual-Pane]"
        if m.commandFocused </span><span class="cov0" title="0">{
                titleText += " [Command Mode]"
        }</span>

        // Create GitHub link (OSC 8 hyperlink format)
        <span class="cov0" title="0">githubURL := "https://github.com/GGPrompts/TFE"
        githubLink := fmt.Sprintf("\033]8;;%s\033\\%s\033]8;;\033\\", githubURL, githubURL)

        // Calculate spacing to right-align GitHub link
        githubText := githubURL // Display text
        availableWidth := m.width - len(titleText) - len(githubText) - 2
        if availableWidth &lt; 1 </span><span class="cov0" title="0">{
                availableWidth = 1
        }</span>
        <span class="cov0" title="0">spacing := strings.Repeat(" ", availableWidth)

        // Render title on left, GitHub link on right
        title := titleStyle.Render(titleText) + spacing + titleStyle.Render(githubLink)
        s.WriteString(title)
        s.WriteString("\033[0m") // Reset ANSI codes
        s.WriteString("\n")

        // Toolbar buttons
        // Home button - highlight with gray background when in home directory
        homeDir, _ := os.UserHomeDir()
        if homeDir != "" &amp;&amp; m.currentPath == homeDir </span><span class="cov0" title="0">{
                // Active: gray background (in home directory)
                homeButtonStyle := lipgloss.NewStyle().
                        Foreground(lipgloss.Color("39")).
                        Bold(true).
                        Background(lipgloss.Color("237"))
                s.WriteString(homeButtonStyle.Render("[🏠]"))
        }</span> else<span class="cov0" title="0"> {
                // Inactive: normal styling
                homeButtonStyle := lipgloss.NewStyle().
                        Foreground(lipgloss.Color("39")).
                        Bold(true)
                s.WriteString(homeButtonStyle.Render("[🏠]"))
        }</span>
        <span class="cov0" title="0">s.WriteString(" ")

        // Favorites filter toggle button
        starIcon := "⭐"
        if m.showFavoritesOnly </span><span class="cov0" title="0">{
                starIcon = "✨" // Different icon when filter is active
        }</span>
        <span class="cov0" title="0">favButtonStyle := lipgloss.NewStyle().
                Foreground(lipgloss.Color("39")).
                Bold(true)
        s.WriteString(favButtonStyle.Render("[" + starIcon + "]"))
        s.WriteString(" ")

        // Command mode toggle button with green &gt;_ and blue brackets
        if m.commandFocused </span><span class="cov0" title="0">{
                // Active: gray background
                bracketStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("39")).Bold(true).Background(lipgloss.Color("237"))
                termStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("46")).Bold(true).Background(lipgloss.Color("237"))
                s.WriteString(bracketStyle.Render("["))
                s.WriteString(termStyle.Render("&gt;_"))
                s.WriteString(bracketStyle.Render("]"))
        }</span> else<span class="cov0" title="0"> {
                // Inactive: normal styling
                bracketStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("39")).Bold(true)
                termStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("46")).Bold(true)
                s.WriteString(bracketStyle.Render("["))
                s.WriteString(termStyle.Render("&gt;_"))
                s.WriteString(bracketStyle.Render("]"))
        }</span>
        <span class="cov0" title="0">s.WriteString(" ")

        // Fuzzy search button
        searchButtonStyle := lipgloss.NewStyle().
                Foreground(lipgloss.Color("39")).
                Bold(true)
        s.WriteString(searchButtonStyle.Render("[🔍]"))
        s.WriteString(" ")

        // Prompts filter toggle button
        promptIcon := "📝"
        if m.showPromptsOnly </span><span class="cov0" title="0">{
                promptIcon = "✨📝" // Different icon when filter is active
        }</span>
        <span class="cov0" title="0">promptButtonStyle := lipgloss.NewStyle().
                Foreground(lipgloss.Color("39")).
                Bold(true)
        s.WriteString(promptButtonStyle.Render("[" + promptIcon + "]"))

        s.WriteString("\033[0m") // Reset ANSI codes
        s.WriteString("\n")

        // Command prompt with path (terminal-style)
        promptPrefix := lipgloss.NewStyle().Foreground(lipgloss.Color("39")).Bold(true).Render("$ ")
        pathPromptStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("39")).Bold(true)
        inputStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("252"))

        s.WriteString(promptPrefix)
        s.WriteString(pathPromptStyle.Render(getDisplayPath(m.currentPath)))
        s.WriteString(" ")
        s.WriteString(inputStyle.Render(m.commandInput))

        // Show cursor only when command mode is active
        if m.commandFocused </span><span class="cov0" title="0">{
                cursorStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("39")).Bold(true)
                s.WriteString(cursorStyle.Render("█"))
        }</span>
        // Explicitly reset styling after cursor to prevent ANSI code leakage
        <span class="cov0" title="0">s.WriteString("\033[0m")
        s.WriteString("\n")

        // Blank line separator between command prompt and panes
        s.WriteString("\n")

        // Calculate max visible for both panes
        // title=1 + toolbar=1 + command=1 + separator=1 + panes=maxVisible + separator=1 + status=2 = m.height
        // Therefore: maxVisible = m.height - 7 (total pane height INCLUDING borders)
        maxVisible := m.height - 7

        // Content area is maxVisible - 2 (accounting for top/bottom borders)
        contentHeight := maxVisible - 2

        // Get left pane content - use contentHeight so content fits within the box
        var leftContent string
        switch m.displayMode </span>{
        case modeList:<span class="cov0" title="0">
                leftContent = m.renderListView(contentHeight)</span>
        case modeGrid:<span class="cov0" title="0">
                leftContent = m.renderGridView(contentHeight)</span>
        case modeDetail:<span class="cov0" title="0">
                leftContent = m.renderDetailView(contentHeight)</span>
        case modeTree:<span class="cov0" title="0">
                leftContent = m.renderTreeView(contentHeight)</span>
        default:<span class="cov0" title="0">
                leftContent = m.renderListView(contentHeight)</span>
        }

        // Get right pane content (just the preview, no title)
        <span class="cov0" title="0">rightContent := ""
        if m.preview.loaded </span><span class="cov0" title="0">{
                rightContent = m.renderPreview(contentHeight)
        }</span> else<span class="cov0" title="0"> {
                emptyStyle := lipgloss.NewStyle().
                        Foreground(lipgloss.Color("241")).
                        Italic(true)
                rightContent = emptyStyle.Render("No preview available\n\nSelect a file to preview") + "\033[0m"
        }</span>

        // Create styled boxes for left and right panes using Lipgloss
        // Highlight the focused pane with a brighter border color
        <span class="cov0" title="0">leftBorderColor := lipgloss.AdaptiveColor{Light: "#999999", Dark: "#585858"}  // dim gray
        rightBorderColor := lipgloss.AdaptiveColor{Light: "#999999", Dark: "#585858"} // dim gray
        if m.focusedPane == leftPane </span><span class="cov0" title="0">{
                leftBorderColor = lipgloss.AdaptiveColor{Light: "#0087d7", Dark: "#00d7ff"} // bright blue for focused pane
        }</span> else<span class="cov0" title="0"> {
                rightBorderColor = lipgloss.AdaptiveColor{Light: "#0087d7", Dark: "#00d7ff"} // bright blue for focused pane
        }</span>

        // Use fixed Width/Height for consistent borders
        // Content is constrained to contentHeight lines to fit within the box
        <span class="cov0" title="0">leftPaneStyle := lipgloss.NewStyle().
                Width(m.leftWidth - 2).   // -2 for left/right borders
                Height(contentHeight).    // Content area height (borders added by Lipgloss)
                Border(lipgloss.RoundedBorder()).
                BorderForeground(leftBorderColor)

        rightPaneStyle := lipgloss.NewStyle().
                Width(m.rightWidth - 2).  // -2 for left/right borders
                Height(contentHeight).    // Content area height (borders added by Lipgloss)
                Border(lipgloss.RoundedBorder()).
                BorderForeground(rightBorderColor)

        // Apply styles to content
        leftPaneRendered := leftPaneStyle.Render(leftContent)
        rightPaneRendered := rightPaneStyle.Render(rightContent)

        // Join panes horizontally
        panes := lipgloss.JoinHorizontal(lipgloss.Top, leftPaneRendered, rightPaneRendered)
        s.WriteString(panes)
        s.WriteString("\n")

        // Status bar (full width)
        // File counts
        dirCount, fileCount := 0, 0
        for _, f := range m.files </span><span class="cov0" title="0">{
                if f.name == ".." </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if f.isDir </span><span class="cov0" title="0">{
                        dirCount++
                }</span> else<span class="cov0" title="0"> {
                        fileCount++
                }</span>
        }

        <span class="cov0" title="0">itemsInfo := fmt.Sprintf("%d folders, %d files", dirCount, fileCount)
        hiddenIndicator := ""
        if m.showHidden </span><span class="cov0" title="0">{
                hiddenIndicator = " • hidden"
        }</span>

        <span class="cov0" title="0">favoritesIndicator := ""
        if m.showFavoritesOnly </span><span class="cov0" title="0">{
                favoritesIndicator = " • ⭐ favorites only"
        }</span>

        <span class="cov0" title="0">promptsIndicator := ""
        if m.showPromptsOnly </span><span class="cov0" title="0">{
                promptsIndicator = " • 📝 prompts only"
        }</span>

        // Show focused pane info in status bar
        <span class="cov0" title="0">focusInfo := ""
        if m.focusedPane == leftPane </span><span class="cov0" title="0">{
                focusInfo = " • [LEFT focused]"
        }</span> else<span class="cov0" title="0"> {
                focusInfo = " • [RIGHT focused]"
        }</span>

        // Help hint
        <span class="cov0" title="0">helpHint := " • F1: help"

        // Selected file info
        var selectedInfo string
        if currentFile := m.getCurrentFile(); currentFile != nil </span><span class="cov0" title="0">{
                if currentFile.isDir </span><span class="cov0" title="0">{
                        // Special handling for ".." to show parent directory name
                        if currentFile.name == ".." </span><span class="cov0" title="0">{
                                parentPath := filepath.Dir(m.currentPath)
                                parentName := filepath.Base(parentPath)
                                if parentName == "/" || parentName == "." </span><span class="cov0" title="0">{
                                        parentName = "root"
                                }</span>
                                <span class="cov0" title="0">selectedInfo = fmt.Sprintf("Selected: .. (go up to %s)", parentName)</span>
                        } else<span class="cov0" title="0"> {
                                selectedInfo = fmt.Sprintf("Selected: %s (folder)", currentFile.name)
                        }</span>
                } else<span class="cov0" title="0"> {
                        fileType := getFileType(*currentFile)
                        selectedInfo = fmt.Sprintf("Selected: %s (%s, %s, %s)",
                                currentFile.name,
                                fileType,
                                formatFileSize(currentFile.size),
                                formatModTime(currentFile.modTime))
                }</span>
        }

        // Split status into two lines to prevent truncation
        // Line 1: Counts, indicators, view mode, focus, help
        <span class="cov0" title="0">statusLine1 := fmt.Sprintf("%s%s%s%s • %s%s%s", itemsInfo, hiddenIndicator, favoritesIndicator, promptsIndicator, m.displayMode.String(), focusInfo, helpHint)
        s.WriteString(statusStyle.Render(statusLine1))
        s.WriteString("\033[0m") // Reset ANSI codes
        s.WriteString("\n")

        // Line 2: Selected file info
        statusLine2 := selectedInfo
        s.WriteString(statusStyle.Render(statusLine2))
        s.WriteString("\033[0m") // Reset ANSI codes

        return s.String()</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package main

// Module: trash.go
// Purpose: Trash/Recycle bin functionality for safe file deletion
// Responsibilities:
// - Moving files to trash instead of permanent deletion
// - Tracking trash metadata (original path, deletion time)
// - Restoring files from trash
// - Emptying trash (permanent deletion)
// - Listing trash contents

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "sort"
        "time"
)

// trashItem represents a deleted item in the trash
type trashItem struct {
        OriginalPath string    `json:"original_path"` // Full path before deletion
        TrashedPath  string    `json:"trashed_path"`  // Path in trash directory
        DeletedAt    time.Time `json:"deleted_at"`    // When it was deleted
        OriginalName string    `json:"original_name"` // Original filename
        IsDir        bool      `json:"is_dir"`        // Is it a directory?
        Size         int64     `json:"size"`          // File/dir size in bytes
}

// getTrashDir returns the path to the trash directory
func getTrashDir() (string, error) <span class="cov8" title="1">{
        home, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">trashDir := filepath.Join(home, ".config", "tfe", "trash")

        // Create trash directory if it doesn't exist
        if err := os.MkdirAll(trashDir, 0755); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return trashDir, nil</span>
}

// getTrashMetadataPath returns the path to the trash metadata file
func getTrashMetadataPath() (string, error) <span class="cov8" title="1">{
        home, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">configDir := filepath.Join(home, ".config", "tfe")
        if err := os.MkdirAll(configDir, 0755); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return filepath.Join(configDir, "trash.json"), nil</span>
}

// loadTrashMetadata loads the trash metadata from disk
func loadTrashMetadata() ([]trashItem, error) <span class="cov8" title="1">{
        metadataPath, err := getTrashMetadataPath()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // If file doesn't exist, return empty list
        <span class="cov8" title="1">if _, err := os.Stat(metadataPath); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return []trashItem{}, nil
        }</span>

        <span class="cov8" title="1">data, err := os.ReadFile(metadataPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var items []trashItem
        if err := json.Unmarshal(data, &amp;items); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return items, nil</span>
}

// saveTrashMetadata saves the trash metadata to disk
func saveTrashMetadata(items []trashItem) error <span class="cov8" title="1">{
        metadataPath, err := getTrashMetadataPath()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">data, err := json.MarshalIndent(items, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return os.WriteFile(metadataPath, data, 0644)</span>
}

// moveToTrash moves a file or directory to the trash
func moveToTrash(path string) error <span class="cov8" title="1">{
        // Get file info
        info, err := os.Stat(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to stat file: %w", err)
        }</span>

        // Get trash directory
        <span class="cov8" title="1">trashDir, err := getTrashDir()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get trash directory: %w", err)
        }</span>

        // Generate unique name in trash (timestamp + original name)
        <span class="cov8" title="1">timestamp := time.Now().Format("20060102_150405")
        originalName := filepath.Base(path)
        trashedName := fmt.Sprintf("%s_%s", timestamp, originalName)
        trashedPath := filepath.Join(trashDir, trashedName)

        // Handle name collisions (rare but possible if deleting multiple files per second)
        counter := 1
        for </span><span class="cov8" title="1">{
                if _, err := os.Stat(trashedPath); os.IsNotExist(err) </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">trashedName = fmt.Sprintf("%s_%s_%d", timestamp, originalName, counter)
                trashedPath = filepath.Join(trashDir, trashedName)
                counter++</span>
        }

        // Move the file/directory to trash
        <span class="cov8" title="1">if err := os.Rename(path, trashedPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to move to trash: %w", err)
        }</span>

        // Load existing trash metadata
        <span class="cov8" title="1">items, err := loadTrashMetadata()
        if err != nil </span><span class="cov0" title="0">{
                // If metadata load fails, try to restore the file
                os.Rename(trashedPath, path)
                return fmt.Errorf("failed to load trash metadata: %w", err)
        }</span>

        // Add new item to metadata
        <span class="cov8" title="1">newItem := trashItem{
                OriginalPath: path,
                TrashedPath:  trashedPath,
                DeletedAt:    time.Now(),
                OriginalName: originalName,
                IsDir:        info.IsDir(),
                Size:         info.Size(),
        }
        items = append(items, newItem)

        // Save updated metadata
        if err := saveTrashMetadata(items); err != nil </span><span class="cov0" title="0">{
                // If metadata save fails, try to restore the file
                os.Rename(trashedPath, path)
                return fmt.Errorf("failed to save trash metadata: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// restoreFromTrash restores a file from trash to its original location
func restoreFromTrash(trashedPath string) error <span class="cov8" title="1">{
        // Load trash metadata
        items, err := loadTrashMetadata()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load trash metadata: %w", err)
        }</span>

        // Find the item in metadata
        <span class="cov8" title="1">itemIndex := -1
        var item trashItem
        for i, it := range items </span><span class="cov8" title="1">{
                if it.TrashedPath == trashedPath </span><span class="cov8" title="1">{
                        itemIndex = i
                        item = it
                        break</span>
                }
        }

        <span class="cov8" title="1">if itemIndex == -1 </span><span class="cov0" title="0">{
                return fmt.Errorf("item not found in trash metadata")
        }</span>

        // Check if original path still exists
        <span class="cov8" title="1">if _, err := os.Stat(item.OriginalPath); err == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("cannot restore: file already exists at original location")
        }</span>

        // Ensure parent directory exists
        <span class="cov8" title="1">parentDir := filepath.Dir(item.OriginalPath)
        if err := os.MkdirAll(parentDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create parent directory: %w", err)
        }</span>

        // Restore the file
        <span class="cov8" title="1">if err := os.Rename(trashedPath, item.OriginalPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to restore file: %w", err)
        }</span>

        // Remove from metadata
        <span class="cov8" title="1">items = append(items[:itemIndex], items[itemIndex+1:]...)
        if err := saveTrashMetadata(items); err != nil </span><span class="cov0" title="0">{
                // File is already restored, just log the metadata error
                return fmt.Errorf("file restored but failed to update metadata: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// emptyTrash permanently deletes all items in the trash
func emptyTrash() error <span class="cov8" title="1">{
        // Load trash metadata
        items, err := loadTrashMetadata()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load trash metadata: %w", err)
        }</span>

        // Delete all trashed files/directories
        <span class="cov8" title="1">var errors []string
        for _, item := range items </span><span class="cov8" title="1">{
                if err := os.RemoveAll(item.TrashedPath); err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Sprintf("%s: %v", item.OriginalName, err))
                }</span>
        }

        // Clear metadata
        <span class="cov8" title="1">if err := saveTrashMetadata([]trashItem{}); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to clear trash metadata: %w", err)
        }</span>

        <span class="cov8" title="1">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("some items failed to delete: %v", errors)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// getTrashItems returns all items currently in the trash, sorted by deletion time (newest first)
func getTrashItems() ([]trashItem, error) <span class="cov8" title="1">{
        items, err := loadTrashMetadata()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Sort by deletion time (newest first)
        <span class="cov8" title="1">sort.Slice(items, func(i, j int) bool </span><span class="cov8" title="1">{
                return items[i].DeletedAt.After(items[j].DeletedAt)
        }</span>)

        <span class="cov8" title="1">return items, nil</span>
}

// getTrashSize returns the total size of all items in trash
func getTrashSize() (int64, error) <span class="cov8" title="1">{
        items, err := loadTrashMetadata()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">var totalSize int64
        for _, item := range items </span><span class="cov8" title="1">{
                totalSize += item.Size
        }</span>

        <span class="cov8" title="1">return totalSize, nil</span>
}

// cleanupOldTrash removes items from trash older than the specified duration
func cleanupOldTrash(olderThan time.Duration) (int, error) <span class="cov8" title="1">{
        items, err := loadTrashMetadata()
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to load trash metadata: %w", err)
        }</span>

        <span class="cov8" title="1">cutoffTime := time.Now().Add(-olderThan)
        var keptItems []trashItem
        removedCount := 0

        for _, item := range items </span><span class="cov8" title="1">{
                if item.DeletedAt.Before(cutoffTime) </span><span class="cov8" title="1">{
                        // Remove old item
                        os.RemoveAll(item.TrashedPath)
                        removedCount++
                }</span> else<span class="cov8" title="1"> {
                        // Keep recent item
                        keptItems = append(keptItems, item)
                }</span>
        }

        // Save updated metadata
        <span class="cov8" title="1">if err := saveTrashMetadata(keptItems); err != nil </span><span class="cov0" title="0">{
                return removedCount, fmt.Errorf("removed %d items but failed to update metadata: %w", removedCount, err)
        }</span>

        <span class="cov8" title="1">return removedCount, nil</span>
}

// convertTrashItemsToFileItems converts trash items to fileItems for display
func convertTrashItemsToFileItems(items []trashItem) []fileItem <span class="cov8" title="1">{
        fileItems := make([]fileItem, 0, len(items))

        for _, item := range items </span><span class="cov8" title="1">{
                // Get current file info from trashed path
                info, err := os.Stat(item.TrashedPath)
                if err != nil </span><span class="cov0" title="0">{
                        // File no longer exists in trash, skip it
                        continue</span>
                }

                // Create fileItem with original name and info
                <span class="cov8" title="1">fileItem := fileItem{
                        name:    item.OriginalName + " (from " + filepath.Dir(item.OriginalPath) + ")",
                        path:    item.TrashedPath, // Use trashed path for operations
                        isDir:   item.IsDir,
                        size:    item.Size,
                        modTime: item.DeletedAt, // Show deletion time instead of modtime
                        mode:    info.Mode(),
                }
                fileItems = append(fileItems, fileItem)</span>
        }

        <span class="cov8" title="1">return fileItems</span>
}

// permanentlyDelete permanently deletes a single item from trash
func permanentlyDeleteFromTrash(trashedPath string) error <span class="cov8" title="1">{
        // Load trash metadata
        items, err := loadTrashMetadata()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load trash metadata: %w", err)
        }</span>

        // Find the item in metadata
        <span class="cov8" title="1">itemIndex := -1
        for i, item := range items </span><span class="cov8" title="1">{
                if item.TrashedPath == trashedPath </span><span class="cov8" title="1">{
                        itemIndex = i
                        break</span>
                }
        }

        <span class="cov8" title="1">if itemIndex == -1 </span><span class="cov0" title="0">{
                return fmt.Errorf("item not found in trash metadata")
        }</span>

        // Permanently delete the file/directory
        <span class="cov8" title="1">if err := os.RemoveAll(trashedPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete: %w", err)
        }</span>

        // Remove from metadata
        <span class="cov8" title="1">items = append(items[:itemIndex], items[itemIndex+1:]...)
        if err := saveTrashMetadata(items); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("deleted but failed to update metadata: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package main

import (
        "os"
        "time"

        "github.com/charmbracelet/bubbles/spinner"
)

// displayMode represents different view modes for displaying files
type displayMode int

const (
        modeList displayMode = iota
        modeGrid
        modeDetail
        modeTree
)

func (d displayMode) String() string <span class="cov0" title="0">{
        switch d </span>{
        case modeList:<span class="cov0" title="0">
                return "List"</span>
        case modeGrid:<span class="cov0" title="0">
                return "Grid"</span>
        case modeDetail:<span class="cov0" title="0">
                return "Detail"</span>
        case modeTree:<span class="cov0" title="0">
                return "Tree"</span>
        default:<span class="cov0" title="0">
                return "Unknown"</span>
        }
}

// viewMode represents the layout mode (single, dual-pane, or full preview)
type viewMode int

const (
        viewSinglePane viewMode = iota
        viewDualPane
        viewFullPreview
)

func (v viewMode) String() string <span class="cov0" title="0">{
        switch v </span>{
        case viewSinglePane:<span class="cov0" title="0">
                return "Single"</span>
        case viewDualPane:<span class="cov0" title="0">
                return "Dual-Pane"</span>
        case viewFullPreview:<span class="cov0" title="0">
                return "Full Preview"</span>
        default:<span class="cov0" title="0">
                return "Unknown"</span>
        }
}

// paneType represents which pane is focused in dual-pane mode
type paneType int

const (
        leftPane paneType = iota
        rightPane
)

// fileItem represents a file or directory in the file browser
type fileItem struct {
        name    string
        path    string
        isDir   bool
        size    int64
        modTime time.Time
        mode    os.FileMode
}

// previewModel holds preview pane state
type previewModel struct {
        filePath   string
        fileName   string
        content    []string // Lines of the file
        scrollPos  int      // Current scroll position
        maxPreview int      // Max lines to load (prevent huge files)
        loaded     bool
        isBinary   bool
        tooLarge            bool
        fileSize            int64
        isMarkdown          bool // Whether the file is markdown
        isSyntaxHighlighted bool // Whether syntax highlighting was applied
        // Caching for performance
        cachedWrappedLines    []string // Cached wrapped text lines
        cachedRenderedContent string   // Cached Glamour-rendered markdown
        cachedLineCount       int      // Cached total line count after wrapping
        cachedWidth           int      // Width the cache was computed for
        cacheValid            bool     // Whether cache is valid
        // Prompt template (for prompt files)
        isPrompt       bool            // Whether the file is a prompt template
        promptTemplate *promptTemplate // Parsed prompt template
}

// promptTemplate represents a parsed prompt with metadata and template
type promptTemplate struct {
        name        string
        description string
        source      string   // "global", "command", "agent", "local"
        variables   []string // List of {{VAR}} placeholders found
        template    string   // The template text with {{placeholders}}
        raw         string   // Original file content
}

// inputFieldType represents the type of input field for variable entry
type inputFieldType int

const (
        fieldTypeShort inputFieldType = iota // Short text input (single line)
        fieldTypeLong                         // Long text input (shows truncated)
        fieldTypeFile                         // File path (supports file picker)
)

// promptInputField represents a fillable field for a prompt template variable
type promptInputField struct {
        name         string         // Variable name (e.g., "file", "priority")
        value        string         // User's input (full content, no limit)
        defaultValue string         // Auto-filled default value
        fieldType    inputFieldType // Type of field (short/long/file)
        displayWidth int            // Available width for display
        color        string         // Color for highlighting in preview (e.g., "39", "220")
}

// getDisplayValue returns the value to display in the input field
// For long content, shows trailing end with [...] prefix and char count
func (f *promptInputField) getDisplayValue() string <span class="cov0" title="0">{
        // Use current value if filled, otherwise use default
        content := f.value
        if content == "" </span><span class="cov0" title="0">{
                content = f.defaultValue
        }</span>

        // Calculate max display width (reserve space for brackets and char count)
        <span class="cov0" title="0">maxDisplay := f.displayWidth - 20
        if maxDisplay &lt; 20 </span><span class="cov0" title="0">{
                maxDisplay = 20
        }</span>

        // If content fits, show it all
        <span class="cov0" title="0">if len(content) &lt;= maxDisplay </span><span class="cov0" title="0">{
                return content
        }</span>

        // Long content - show trailing end with ellipsis and char count
        <span class="cov0" title="0">suffix := content[len(content)-maxDisplay:]
        return suffix</span> // We'll add [...] and (X chars) in the rendering code
}

// getCharCountDisplay returns a formatted character count string
func (f *promptInputField) getCharCountDisplay() string <span class="cov0" title="0">{
        length := len(f.value)
        if length == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">formatted := formatCharCount(length)
        if formatted == "" </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return " (" + formatted + ")"</span>
}

// formatCharCount formats character count in human-readable form
func formatCharCount(count int) string <span class="cov0" title="0">{
        if count &lt; 1000 </span><span class="cov0" title="0">{
                return ""
        }</span> else<span class="cov0" title="0"> if count &lt; 10000 </span><span class="cov0" title="0">{
                // Show as "1.2k chars"
                major := count / 1000
                minor := (count % 1000) / 100
                return string(rune('0'+major)) + "." + string(rune('0'+minor)) + "k chars"
        }</span>
        // Show as "12k chars"
        <span class="cov0" title="0">return string(rune('0'+count/1000)) + "k chars"</span>
}

// hasContent returns whether the field has user-entered content
func (f *promptInputField) hasContent() bool <span class="cov0" title="0">{
        return f.value != ""
}</span>

// model represents the main application state
type model struct {
        currentPath string
        files       []fileItem
        cursor      int
        height      int
        width       int
        showHidden  bool
        displayMode displayMode
        gridColumns int
        sortBy      string // "name", "size", "modified" for detail view
        sortAsc     bool   // Sort ascending or descending
        // Preview-related fields
        viewMode    viewMode
        preview     previewModel
        leftWidth   int // Width of left pane in dual-pane mode
        rightWidth  int // Width of right pane in dual-pane mode
        focusedPane paneType // Which pane has focus in dual-pane mode
        // Double-click detection
        lastClickTime  time.Time
        lastClickIndex int
        // Command prompt (always visible)
        commandInput   string
        commandHistory []string
        historyPos     int
        commandFocused bool // Whether command prompt has input focus
        // Loading spinner
        spinner spinner.Model
        loading bool
        // Favorites system
        favorites         map[string]bool // Path -&gt; favorited
        showFavoritesOnly bool            // Filter to show only favorites
        // Prompts system
        showPromptsOnly bool // Filter to show only prompt files (.yaml, .md, .txt)
        // Trash/Recycle bin system
        showTrashOnly bool        // Filter to show trash contents
        trashItems    []trashItem // Cached trash items when viewing trash
        // Prompt input fields (fillable variables)
        promptInputFields      []promptInputField // Input fields for prompt variables
        focusedInputField      int                // Index of currently focused input field
        inputFieldsActive      bool               // Whether input fields are active/shown
        filePickerMode         bool               // Whether file picker mode is active (F3)
        filePickerRestorePath  string             // Path to restore preview after file picker
        filePickerRestorePrompts bool             // Whether to restore prompts filter after file picker
        // Tree view expansion
        expandedDirs map[string]bool // Path -&gt; expanded state
        treeItems    []treeItem       // Cached tree items for tree view
        // Context menu (right-click menu)
        contextMenuOpen   bool
        contextMenuX      int
        contextMenuY      int
        contextMenuFile   *fileItem
        contextMenuCursor int
        // Dialog system
        dialog        dialogModel
        showDialog    bool
        statusMessage string    // Temporary status message
        statusIsError bool      // Whether status message is an error
        statusTime    time.Time // When status was shown
        // Fuzzy search
        fuzzySearchActive bool // Whether fuzzy search is active
        // Directory search (/ key)
        searchMode       bool   // Whether search mode is active
        searchQuery      string // Current search query
        filteredIndices  []int  // Indices of files matching search
}

// treeItem represents an item in the tree view with depth information
type treeItem struct {
        file        fileItem
        depth       int
        isLast      bool
        parentLasts []bool // Track which parent levels are last items
}

// editorFinishedMsg is sent when external editor exits
type editorFinishedMsg struct{ err error }

// markdownRenderedMsg is sent when markdown rendering completes
type markdownRenderedMsg struct{}

// fuzzySearchResultMsg is sent when fuzzy search completes
type fuzzySearchResultMsg struct {
        selected string // Selected file path
        err      error
}

// dialogType represents different types of dialogs
type dialogType int

const (
        dialogNone dialogType = iota
        dialogInput   // Text input dialog (F7 directory name)
        dialogConfirm // Yes/No confirmation (F8 delete)
        dialogMessage // Status messages (success/error)
)

// dialogModel holds dialog state
type dialogModel struct {
        dialogType dialogType
        title      string
        message    string
        input      string // For text input dialogs
        confirmed  bool   // User confirmed action
        isError    bool   // For message dialogs (red vs green)
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package main

import (
        "regexp"

        "github.com/charmbracelet/bubbles/spinner"
        tea "github.com/charmbracelet/bubbletea"
)

// Module: update.go
// Purpose: Main update dispatcher and initialization
// Responsibilities:
// - Bubbletea initialization (Init)
// - Main message dispatcher (Update)
// - Window resize handling
// - Editor/command finished message handling
// - Spinner tick handling
// - Helper function: isSpecialKey() for detecting non-printable keys

func (m model) Init() tea.Cmd <span class="cov0" title="0">{
        return m.spinner.Tick
}</span>

// stripANSI removes ANSI escape codes from a string
// This prevents pasted styled text from corrupting the command line
func stripANSI(s string) string <span class="cov0" title="0">{
        // Match all common ANSI escape sequences:
        // - CSI sequences: ESC [ ... (letter or @)
        // - OSC sequences: ESC ] ... (BEL or ST)
        // - Other escape sequences: ESC followed by various characters
        ansiRegex := regexp.MustCompile(`\x1b(\[[0-9;?]*[a-zA-Z@]|\][^\x07\x1b]*(\x07|\x1b\\)|[&gt;=&lt;&gt;()#])`)
        cleaned := ansiRegex.ReplaceAllString(s, "")

        // Also strip terminal response sequences that may appear without ESC prefix
        // These can leak in when terminal responds to queries (e.g., color capability checks)
        // Patterns: ";rgb:xxxx/xxxx", "1;rgb:xxxx/xxxx/xxxx", "0;rgb:...", numeric response codes
        // Match anywhere in the string, not just exact matches
        responseRegex := regexp.MustCompile(`;?rgb:[0-9a-fA-F/]+|\d+;rgb:[0-9a-fA-F/]+|\d+;\d+(?:;\d+)*`)
        cleaned = responseRegex.ReplaceAllString(cleaned, "")

        return cleaned
}</span>

// isSpecialKey checks if a key string represents a special (non-printable) key
// that should not be added to command input
func isSpecialKey(key string) bool <span class="cov0" title="0">{
        specialKeys := []string{
                "up", "down", "left", "right",
                "home", "end", "pageup", "pagedown", "pgup", "pgdn",
                "delete", "insert",
                "backspace", "enter", "return", "tab", "esc", "escape",
                "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "f10", "f11", "f12",
                "ctrl+c", "ctrl+h", "ctrl+d", "ctrl+z",
                "alt+", "ctrl+", // Prefixes for modifier combinations
                "shift+",
        }

        // Check exact matches
        for _, special := range specialKeys </span><span class="cov0" title="0">{
                if key == special </span><span class="cov0" title="0">{
                        return true
                }</span>
                // Check if key starts with modifier prefix (like "ctrl+a", "alt+x")
                <span class="cov0" title="0">if len(special) &gt; 0 &amp;&amp; special[len(special)-1] == '+' &amp;&amp; len(key) &gt; len(special) </span><span class="cov0" title="0">{
                        if key[:len(special)] == special </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }

        <span class="cov0" title="0">return false</span>
}

// Update is the main message dispatcher
func (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        // Update tree items cache if in tree mode (before processing events)
        if m.displayMode == modeTree </span><span class="cov0" title="0">{
                m.updateTreeItems()
        }</span>

        <span class="cov0" title="0">switch msg := msg.(type) </span>{
        case tea.KeyMsg:<span class="cov0" title="0">
                // Dispatch to keyboard event handler
                return m.handleKeyEvent(msg)</span>

        case tea.MouseMsg:<span class="cov0" title="0">
                // Dispatch to mouse event handler
                return m.handleMouseEvent(msg)</span>

        case tea.WindowSizeMsg:<span class="cov0" title="0">
                // Handle window resize
                m.height = msg.Height
                m.width = msg.Width
                m.calculateGridLayout()  // Recalculate grid columns on resize
                m.calculateLayout()      // Recalculate pane layout on resize
                m.populatePreviewCache()</span> // Repopulate cache with new width

        case spinner.TickMsg:<span class="cov0" title="0">
                // Update spinner animation
                var cmd tea.Cmd
                m.spinner, cmd = m.spinner.Update(msg)
                return m, cmd</span>

        case editorFinishedMsg:<span class="cov0" title="0">
                // Editor has closed, we're back in TFE
                // Refresh file list in case file was modified
                m.loadFiles()
                // Force a refresh and re-enable mouse support (external editors disable it)
                return m, tea.Batch(
                        tea.ClearScreen,
                        tea.EnableMouseCellMotion,
                )</span>

        case commandFinishedMsg:<span class="cov0" title="0">
                // Command has finished, we're back in TFE
                // Refresh file list in case command modified files
                m.loadFiles()
                // Force a refresh and re-enable mouse support (shell commands may disable it)
                return m, tea.Batch(
                        tea.ClearScreen,
                        tea.EnableMouseCellMotion,
                )</span>

        case fuzzySearchResultMsg:<span class="cov0" title="0">
                // Fuzzy search completed
                m.fuzzySearchActive = false
                if msg.err == nil &amp;&amp; msg.selected != "" </span><span class="cov0" title="0">{
                        m.navigateToFuzzyResult(msg.selected)
                }</span>
                // Force a refresh and re-enable mouse support
                <span class="cov0" title="0">return m, tea.Batch(
                        tea.ClearScreen,
                        tea.EnableMouseCellMotion,
                )</span>

        case markdownRenderedMsg:<span class="cov0" title="0">
                // Markdown rendering completed in background
                // Just return to trigger a re-render with the cached content
                return m, nil</span>

        case browserOpenedMsg:<span class="cov0" title="0">
                // Browser opened (or failed to open)
                if msg.success </span><span class="cov0" title="0">{
                        m.setStatusMessage("✓ Opened in browser", false)
                }</span> else<span class="cov0" title="0"> {
                        m.setStatusMessage("Failed to open in browser: "+msg.err.Error(), true)
                }</span>
                <span class="cov0" title="0">return m, nil</span>
        }

        <span class="cov0" title="0">return m, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package main

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"

        tea "github.com/charmbracelet/bubbletea"
)

// Module: update_keyboard.go
// Purpose: Keyboard event handling for TFE
// Responsibilities:
// - Processing all keyboard input events
// - Preview mode key handling
// - Dialog input processing
// - Context menu keyboard navigation
// - Command prompt input
// - File browser keyboard shortcuts

// handleKeyEvent processes all keyboard input
func (m model) handleKeyEvent(msg tea.KeyMsg) (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        // Filter out terminal response sequences (color queries, etc.)
        // These are not real keypresses but terminal responses that leak through
        // Examples: "1;rgb:0000/00", "11;rgb:0000/0000/0000", "b:0000/00"
        key := msg.String()
        if strings.Contains(key, "rgb:") ||
           (strings.Contains(key, ":") &amp;&amp; strings.Contains(key, "/")) </span><span class="cov0" title="0">{
                // Ignore terminal response sequences
                return m, nil
        }</span>

        // If fuzzy search is active, don't process any keyboard events
        // (go-fzf handles its own input)
        <span class="cov0" title="0">if m.fuzzySearchActive </span><span class="cov0" title="0">{
                return m, nil
        }</span>

        // Handle input field editing FIRST (works in both dual-pane and full preview)
        // This must come before preview mode and dialog handling
        <span class="cov0" title="0">if m.inputFieldsActive &amp;&amp; len(m.promptInputFields) &gt; 0 </span><span class="cov0" title="0">{
                switch msg.String() </span>{
                case "tab":<span class="cov0" title="0">
                        // Navigate to next field
                        m.focusedInputField++
                        if m.focusedInputField &gt;= len(m.promptInputFields) </span><span class="cov0" title="0">{
                                m.focusedInputField = 0 // Wrap around
                        }</span>
                        <span class="cov0" title="0">return m, nil</span>

                case "shift+tab":<span class="cov0" title="0">
                        // Navigate to previous field
                        m.focusedInputField--
                        if m.focusedInputField &lt; 0 </span><span class="cov0" title="0">{
                                m.focusedInputField = len(m.promptInputFields) - 1 // Wrap around
                        }</span>
                        <span class="cov0" title="0">return m, nil</span>

                case "backspace":<span class="cov0" title="0">
                        // Delete last character from focused field
                        if m.focusedInputField &gt;= 0 &amp;&amp; m.focusedInputField &lt; len(m.promptInputFields) </span><span class="cov0" title="0">{
                                field := &amp;m.promptInputFields[m.focusedInputField]
                                if len(field.value) &gt; 0 </span><span class="cov0" title="0">{
                                        field.value = field.value[:len(field.value)-1]
                                }</span>
                        }
                        <span class="cov0" title="0">return m, nil</span>

                case "ctrl+u":<span class="cov0" title="0">
                        // Clear entire field
                        if m.focusedInputField &gt;= 0 &amp;&amp; m.focusedInputField &lt; len(m.promptInputFields) </span><span class="cov0" title="0">{
                                m.promptInputFields[m.focusedInputField].value = ""
                        }</span>
                        <span class="cov0" title="0">return m, nil</span>

                case "f3":<span class="cov0" title="0">
                        // Activate file picker mode - exit to file browser to select a file
                        m.filePickerMode = true
                        m.filePickerRestorePath = m.preview.filePath // Store preview path to restore later
                        m.filePickerRestorePrompts = m.showPromptsOnly // Store prompts filter state
                        m.showPromptsOnly = false // Disable prompts filter to show all files
                        m.viewMode = viewSinglePane // Exit preview mode
                        m.loadFiles() // Reload files without prompts filter
                        m.setStatusMessage("📁 File Picker: Navigate and press Enter to select file (Esc to cancel)", false)
                        return m, nil</span>

                case "enter":<span class="cov0" title="0">
                        // Move to next field on Enter
                        m.focusedInputField++
                        if m.focusedInputField &gt;= len(m.promptInputFields) </span><span class="cov0" title="0">{
                                m.focusedInputField = 0 // Wrap around
                        }</span>
                        <span class="cov0" title="0">return m, nil</span>

                default:<span class="cov0" title="0">
                        // Handle regular character input
                        keyStr := msg.String()

                        // Filter out function keys and special keys
                        if !isSpecialKey(keyStr) &amp;&amp; len(keyStr) &gt; 0 </span><span class="cov0" title="0">{
                                // Detect paste (multiple characters at once)
                                isPaste := len(keyStr) &gt; 1

                                if m.focusedInputField &gt;= 0 &amp;&amp; m.focusedInputField &lt; len(m.promptInputFields) </span><span class="cov0" title="0">{
                                        field := &amp;m.promptInputFields[m.focusedInputField]

                                        // Add the input to the field value
                                        field.value += keyStr

                                        // If it's a paste, show status message
                                        if isPaste </span><span class="cov0" title="0">{
                                                charCount := len(keyStr)
                                                m.setStatusMessage(fmt.Sprintf("✓ Pasted %d characters", charCount), false)
                                        }</span>
                                }
                                <span class="cov0" title="0">return m, nil</span>
                        }
                }
        }

        // Handle preview mode keys
        <span class="cov0" title="0">if m.viewMode == viewFullPreview </span><span class="cov0" title="0">{
                switch msg.String() </span>{
                case "f10", "ctrl+c", "esc":<span class="cov0" title="0">
                        // Exit preview mode (F10 replaces q)
                        m.viewMode = viewSinglePane
                        m.calculateLayout()
                        m.populatePreviewCache() // Refresh cache with new width
                        // Clear any stray command input that might have captured terminal responses
                        m.commandInput = ""
                        m.commandFocused = false
                        // Re-enable mouse when exiting preview
                        return m, tea.EnableMouseCellMotion</span>

                case "f4":<span class="cov0" title="0">
                        // Edit file in external editor from preview (F4 replaces e/E)
                        if m.preview.loaded &amp;&amp; m.preview.filePath != "" </span><span class="cov0" title="0">{
                                editor := getAvailableEditor()
                                if editor == "" </span><span class="cov0" title="0">{
                                        m.setStatusMessage("No editor available (tried micro, nano, vim, vi)", true)
                                        return m, nil
                                }</span>
                                <span class="cov0" title="0">if editorAvailable("micro") </span><span class="cov0" title="0">{
                                        editor = "micro"
                                }</span>
                                <span class="cov0" title="0">return m, openEditor(editor, m.preview.filePath)</span>
                        }

                case "n", "N":<span class="cov0" title="0">
                        // Edit file in nano from preview
                        if m.preview.loaded &amp;&amp; m.preview.filePath != "" &amp;&amp; editorAvailable("nano") </span><span class="cov0" title="0">{
                                return m, openEditor("nano", m.preview.filePath)
                        }</span>

                case "f5":<span class="cov0" title="0">
                        // Copy rendered prompt (if prompt) or file path (regular file)
                        if m.preview.loaded &amp;&amp; m.preview.filePath != "" </span><span class="cov0" title="0">{
                                // If this is a prompt, copy the rendered template
                                if m.preview.isPrompt &amp;&amp; m.preview.promptTemplate != nil </span><span class="cov0" title="0">{
                                        // Get variables (use filled fields if active, otherwise context defaults)
                                        var vars map[string]string
                                        if m.inputFieldsActive &amp;&amp; len(m.promptInputFields) &gt; 0 </span><span class="cov0" title="0">{
                                                vars = getFilledVariables(m.promptInputFields, &amp;m)
                                        }</span> else<span class="cov0" title="0"> {
                                                vars = getContextVariables(&amp;m)
                                        }</span>

                                        // Render the template with variables substituted
                                        <span class="cov0" title="0">rendered := renderPromptTemplate(m.preview.promptTemplate, vars)

                                        // Copy to clipboard
                                        if err := copyToClipboard(rendered); err != nil </span><span class="cov0" title="0">{
                                                m.setStatusMessage(fmt.Sprintf("Failed to copy prompt: %s", err), true)
                                        }</span> else<span class="cov0" title="0"> {
                                                m.setStatusMessage("✓ Prompt copied to clipboard", false)
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        // Regular file: copy path
                                        if err := copyToClipboard(m.preview.filePath); err != nil </span><span class="cov0" title="0">{
                                                m.setStatusMessage(fmt.Sprintf("Failed to copy to clipboard: %s", err), true)
                                        }</span> else<span class="cov0" title="0"> {
                                                m.setStatusMessage("Path copied to clipboard", false)
                                        }</span>
                                }
                        }

                case "up", "k":<span class="cov0" title="0">
                        // Scroll preview up
                        if m.preview.scrollPos &gt; 0 </span><span class="cov0" title="0">{
                                m.preview.scrollPos--
                        }</span>

                case "down", "j":<span class="cov0" title="0">
                        // Scroll preview down
                        totalLines := m.getWrappedLineCount()
                        maxScroll := totalLines - (m.height - 6)
                        if maxScroll &lt; 0 </span><span class="cov0" title="0">{
                                maxScroll = 0
                        }</span>
                        <span class="cov0" title="0">if m.preview.scrollPos &lt; maxScroll </span><span class="cov0" title="0">{
                                m.preview.scrollPos++
                        }</span>

                case "pageup", "pgup":<span class="cov0" title="0">
                        m.preview.scrollPos -= m.height - 6
                        if m.preview.scrollPos &lt; 0 </span><span class="cov0" title="0">{
                                m.preview.scrollPos = 0
                        }</span>

                case "pagedown", "pgdn", "pgdown":<span class="cov0" title="0">
                        totalLines := m.getWrappedLineCount()
                        maxScroll := totalLines - (m.height - 6)
                        if maxScroll &lt; 0 </span><span class="cov0" title="0">{
                                maxScroll = 0
                        }</span>
                        <span class="cov0" title="0">m.preview.scrollPos += m.height - 6
                        if m.preview.scrollPos &gt; maxScroll </span><span class="cov0" title="0">{
                                m.preview.scrollPos = maxScroll
                        }</span>
                }
                <span class="cov0" title="0">return m, nil</span>
        }

        // Handle dialog input if dialog is open
        <span class="cov0" title="0">if m.showDialog </span><span class="cov0" title="0">{
                switch m.dialog.dialogType </span>{
                case dialogInput:<span class="cov0" title="0">
                        // Handle text input dialog
                        switch msg.String() </span>{
                        case "esc":<span class="cov0" title="0">
                                // Cancel dialog
                                m.showDialog = false
                                m.dialog = dialogModel{}
                                return m, tea.ClearScreen</span>

                        case "enter":<span class="cov0" title="0">
                                // Confirm input
                                if m.dialog.title == "Create Directory" </span><span class="cov0" title="0">{
                                        // Handle F7 directory creation
                                        if err := m.createDirectory(m.dialog.input); err != nil </span><span class="cov0" title="0">{
                                                m.setStatusMessage(fmt.Sprintf("Error: %s", err), true)
                                        }</span> else<span class="cov0" title="0"> {
                                                m.setStatusMessage(fmt.Sprintf("Created directory: %s", m.dialog.input), false)
                                                m.loadFiles()
                                                // Move cursor to newly created directory
                                                for i, f := range m.files </span><span class="cov0" title="0">{
                                                        if f.name == m.dialog.input </span><span class="cov0" title="0">{
                                                                m.cursor = i
                                                                break</span>
                                                        }
                                                }
                                        }
                                } else<span class="cov0" title="0"> if m.dialog.title == "Create File" </span><span class="cov0" title="0">{
                                        // Handle file creation
                                        filepath := filepath.Join(m.currentPath, m.dialog.input)
                                        file, err := os.Create(filepath)
                                        if err != nil </span><span class="cov0" title="0">{
                                                m.setStatusMessage(fmt.Sprintf("Error: %s", err), true)
                                        }</span> else<span class="cov0" title="0"> {
                                                // Always close the file handle
                                                defer file.Close()

                                                m.setStatusMessage(fmt.Sprintf("Created file: %s", m.dialog.input), false)
                                                m.loadFiles()

                                                // Open in editor
                                                editor := getAvailableEditor()
                                                if editor == "" </span><span class="cov0" title="0">{
                                                        m.setStatusMessage("File created, but no editor available", true)
                                                }</span> else<span class="cov0" title="0"> {
                                                        m.showDialog = false
                                                        m.dialog = dialogModel{}
                                                        return m, openEditor(editor, filepath)
                                                }</span>
                                        }
                                }
                                <span class="cov0" title="0">m.showDialog = false
                                m.dialog = dialogModel{}
                                return m, tea.ClearScreen</span>

                        case "backspace":<span class="cov0" title="0">
                                // Delete last character
                                if len(m.dialog.input) &gt; 0 </span><span class="cov0" title="0">{
                                        m.dialog.input = m.dialog.input[:len(m.dialog.input)-1]
                                }</span>
                                <span class="cov0" title="0">return m, nil</span>

                        default:<span class="cov0" title="0">
                                // Add printable characters to input
                                // Use msg.Runes to avoid brackets from msg.String() on paste events
                                text := string(msg.Runes)
                                if len(text) &gt; 0 </span><span class="cov0" title="0">{
                                        // Check if all characters are printable
                                        isPrintable := true
                                        for _, r := range msg.Runes </span><span class="cov0" title="0">{
                                                if r &lt; 32 || r &gt; 126 </span><span class="cov0" title="0">{
                                                        isPrintable = false
                                                        break</span>
                                                }
                                        }
                                        <span class="cov0" title="0">if isPrintable </span><span class="cov0" title="0">{
                                                m.dialog.input += text
                                        }</span>
                                }
                                <span class="cov0" title="0">return m, nil</span>
                        }

                case dialogConfirm:<span class="cov0" title="0">
                        // Handle confirmation dialog
                        switch msg.String() </span>{
                        case "esc", "n", "N":<span class="cov0" title="0">
                                // Cancel dialog
                                m.showDialog = false
                                m.dialog = dialogModel{}
                                return m, tea.ClearScreen</span>

                        case "y", "Y":<span class="cov0" title="0">
                                // Confirm action
                                if m.dialog.title == "Permanently Delete" </span><span class="cov0" title="0">{
                                        // Permanently delete item from trash
                                        if m.contextMenuFile != nil </span><span class="cov0" title="0">{
                                                if err := permanentlyDeleteFromTrash(m.contextMenuFile.path); err != nil </span><span class="cov0" title="0">{
                                                        m.setStatusMessage(fmt.Sprintf("Error: %s", err), true)
                                                }</span> else<span class="cov0" title="0"> {
                                                        m.setStatusMessage("Item permanently deleted", false)
                                                        m.loadFiles() // Refresh trash view
                                                }</span>
                                                <span class="cov0" title="0">m.contextMenuFile = nil
                                                m.contextMenuOpen = false</span>
                                        }
                                } else<span class="cov0" title="0"> if m.dialog.title == "Empty Trash" </span><span class="cov0" title="0">{
                                        // Empty entire trash
                                        if err := emptyTrash(); err != nil </span><span class="cov0" title="0">{
                                                m.setStatusMessage(fmt.Sprintf("Error emptying trash: %s", err), true)
                                        }</span> else<span class="cov0" title="0"> {
                                                m.setStatusMessage("Trash emptied successfully", false)
                                                m.loadFiles() // Refresh trash view
                                        }</span>
                                } else<span class="cov0" title="0"> if m.dialog.title == "Move to Trash" </span><span class="cov0" title="0">{
                                        // Move item to trash (from context menu)
                                        if m.contextMenuFile != nil </span><span class="cov0" title="0">{
                                                if err := m.deleteFileOrDir(m.contextMenuFile.path, m.contextMenuFile.isDir); err != nil </span><span class="cov0" title="0">{
                                                        m.setStatusMessage(fmt.Sprintf("Error: %s", err), true)
                                                }</span> else<span class="cov0" title="0"> {
                                                        m.setStatusMessage(fmt.Sprintf("Moved to trash: %s", m.contextMenuFile.name), false)
                                                        m.loadFiles()
                                                }</span>
                                                <span class="cov0" title="0">m.contextMenuFile = nil
                                                m.contextMenuOpen = false</span>
                                        }
                                } else<span class="cov0" title="0"> if m.dialog.title == "Delete file" || m.dialog.title == "Delete directory" </span><span class="cov0" title="0">{
                                        // Handle F8 deletion
                                        if m.contextMenuFile != nil </span><span class="cov0" title="0">{
                                                // Delete from context menu
                                                if err := m.deleteFileOrDir(m.contextMenuFile.path, m.contextMenuFile.isDir); err != nil </span><span class="cov0" title="0">{
                                                        m.setStatusMessage(fmt.Sprintf("Error: %s", err), true)
                                                }</span> else<span class="cov0" title="0"> {
                                                        itemType := "file"
                                                        if m.contextMenuFile.isDir </span><span class="cov0" title="0">{
                                                                itemType = "directory"
                                                        }</span>
                                                        <span class="cov0" title="0">m.setStatusMessage(fmt.Sprintf("Deleted %s: %s", itemType, m.contextMenuFile.name), false)
                                                        m.loadFiles()
                                                        // Adjust cursor if needed
                                                        if m.cursor &gt;= len(m.files) </span><span class="cov0" title="0">{
                                                                m.cursor = len(m.files) - 1
                                                                if m.cursor &lt; 0 </span><span class="cov0" title="0">{
                                                                        m.cursor = 0
                                                                }</span>
                                                        }
                                                }
                                                <span class="cov0" title="0">m.contextMenuFile = nil
                                                m.contextMenuOpen = false</span>
                                        } else<span class="cov0" title="0"> if currentFile := m.getCurrentFile(); currentFile != nil </span><span class="cov0" title="0">{
                                                // Delete from F8 key
                                                if err := m.deleteFileOrDir(currentFile.path, currentFile.isDir); err != nil </span><span class="cov0" title="0">{
                                                        m.setStatusMessage(fmt.Sprintf("Error: %s", err), true)
                                                }</span> else<span class="cov0" title="0"> {
                                                        itemType := "file"
                                                        if currentFile.isDir </span><span class="cov0" title="0">{
                                                                itemType = "directory"
                                                        }</span>
                                                        <span class="cov0" title="0">m.setStatusMessage(fmt.Sprintf("Deleted %s: %s", itemType, currentFile.name), false)
                                                        m.loadFiles()
                                                        // Adjust cursor if needed
                                                        if m.cursor &gt;= len(m.files) </span><span class="cov0" title="0">{
                                                                m.cursor = len(m.files) - 1
                                                                if m.cursor &lt; 0 </span><span class="cov0" title="0">{
                                                                        m.cursor = 0
                                                                }</span>
                                                        }
                                                }
                                        }
                                }
                                <span class="cov0" title="0">m.showDialog = false
                                m.dialog = dialogModel{}
                                return m, tea.ClearScreen</span>
                        }
                        <span class="cov0" title="0">return m, nil</span>
                }
        }

        // Handle context menu input if menu is open
        <span class="cov0" title="0">if m.contextMenuOpen </span><span class="cov0" title="0">{
                switch msg.String() </span>{
                case "esc", "q":<span class="cov0" title="0">
                        // Close context menu
                        m.contextMenuOpen = false
                        return m, nil</span>

                case "up", "k":<span class="cov0" title="0">
                        // Navigate up in menu, skipping separators
                        menuItems := m.getContextMenuItems()
                        for </span><span class="cov0" title="0">{
                                if m.contextMenuCursor &gt; 0 </span><span class="cov0" title="0">{
                                        m.contextMenuCursor--
                                }</span> else<span class="cov0" title="0"> {
                                        break</span>
                                }
                                // Stop if we're not on a separator
                                <span class="cov0" title="0">if menuItems[m.contextMenuCursor].action != "separator" </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">return m, nil</span>

                case "down", "j":<span class="cov0" title="0">
                        // Navigate down in menu, skipping separators
                        menuItems := m.getContextMenuItems()
                        for </span><span class="cov0" title="0">{
                                if m.contextMenuCursor &lt; len(menuItems)-1 </span><span class="cov0" title="0">{
                                        m.contextMenuCursor++
                                }</span> else<span class="cov0" title="0"> {
                                        break</span>
                                }
                                // Stop if we're not on a separator
                                <span class="cov0" title="0">if menuItems[m.contextMenuCursor].action != "separator" </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">return m, nil</span>

                case "enter":<span class="cov0" title="0">
                        // Execute selected menu action
                        return m.executeContextMenuAction()</span>
                }
                <span class="cov0" title="0">return m, nil</span>
        }

        // Handle search mode input (/ key for directory search)
        <span class="cov0" title="0">if m.searchMode </span><span class="cov0" title="0">{
                switch msg.String() </span>{
                case "esc":<span class="cov0" title="0">
                        // Exit search mode
                        m.searchMode = false
                        m.searchQuery = ""
                        m.filteredIndices = nil
                        m.cursor = 0 // Reset cursor
                        return m, nil</span>

                case "backspace":<span class="cov0" title="0">
                        // Delete last character from search query
                        if len(m.searchQuery) &gt; 0 </span><span class="cov0" title="0">{
                                m.searchQuery = m.searchQuery[:len(m.searchQuery)-1]
                                // Update filtered results
                                m.filteredIndices = m.filterFilesBySearch(m.searchQuery)
                                // Reset cursor if out of bounds
                                if m.cursor &gt;= len(m.filteredIndices) </span><span class="cov0" title="0">{
                                        m.cursor = 0
                                }</span>
                        }
                        <span class="cov0" title="0">return m, nil</span>

                case "enter":<span class="cov0" title="0">
                        // Accept search and exit search mode (keep filter active)
                        m.searchMode = false
                        return m, nil</span>

                default:<span class="cov0" title="0">
                        // Add printable characters to search query
                        text := string(msg.Runes)
                        if len(text) &gt; 0 &amp;&amp; !isSpecialKey(msg.String()) </span><span class="cov0" title="0">{
                                // Check if it's printable text
                                isPrintable := true
                                for _, r := range msg.Runes </span><span class="cov0" title="0">{
                                        if r &lt; 32 || r == 127 </span><span class="cov0" title="0">{ // Control characters
                                                isPrintable = false
                                                break</span>
                                        }
                                }
                                <span class="cov0" title="0">if isPrintable </span><span class="cov0" title="0">{
                                        m.searchQuery += text
                                        // Update filtered results
                                        m.filteredIndices = m.filterFilesBySearch(m.searchQuery)
                                        // Reset cursor if out of bounds
                                        if m.cursor &gt;= len(m.filteredIndices) </span><span class="cov0" title="0">{
                                                m.cursor = 0
                                        }</span>
                                }
                        }
                        <span class="cov0" title="0">return m, nil</span>
                }
        }

        // Handle file picker mode (F3 from input fields)
        <span class="cov0" title="0">if m.filePickerMode </span><span class="cov0" title="0">{
                switch msg.String() </span>{
                case "esc":<span class="cov0" title="0">
                        // Cancel file picker and return to preview mode
                        m.filePickerMode = false
                        m.showPromptsOnly = m.filePickerRestorePrompts // Restore prompts filter
                        m.loadFiles() // Reload files with restored filter
                        m.viewMode = viewFullPreview
                        m.inputFieldsActive = true // Re-enable input fields
                        // Reload the original preview
                        if m.filePickerRestorePath != "" </span><span class="cov0" title="0">{
                                m.loadPreview(m.filePickerRestorePath)
                                m.populatePreviewCache()
                        }</span>
                        <span class="cov0" title="0">m.setStatusMessage("File picker cancelled", false)
                        return m, nil</span>

                case "enter":<span class="cov0" title="0">
                        // Get current file (handles tree mode correctly)
                        selectedFile := m.getCurrentFile()
                        if selectedFile != nil </span><span class="cov0" title="0">{
                                if selectedFile.isDir </span><span class="cov0" title="0">{
                                        // It's a directory - navigate into it (consistent across all views)
                                        m.currentPath = selectedFile.path
                                        m.cursor = 0
                                        m.loadFiles()
                                        return m, nil
                                }</span> else<span class="cov0" title="0"> {
                                        // It's a file - select it and populate the input field
                                        // IMPORTANT: Set the value AFTER reloading preview to avoid field recreation overwriting it
                                        selectedPath := selectedFile.path
                                        selectedName := selectedFile.name

                                        // Return to preview mode
                                        m.filePickerMode = false
                                        m.showPromptsOnly = m.filePickerRestorePrompts // Restore prompts filter
                                        m.loadFiles() // Reload files with restored filter
                                        m.viewMode = viewFullPreview
                                        m.inputFieldsActive = true // Re-enable input fields

                                        // Reload the original preview (this recreates input fields)
                                        if m.filePickerRestorePath != "" </span><span class="cov0" title="0">{
                                                m.loadPreview(m.filePickerRestorePath)
                                                m.populatePreviewCache()
                                        }</span>

                                        // NOW set the value after fields have been recreated
                                        <span class="cov0" title="0">if m.focusedInputField &gt;= 0 &amp;&amp; m.focusedInputField &lt; len(m.promptInputFields) </span><span class="cov0" title="0">{
                                                m.promptInputFields[m.focusedInputField].value = selectedPath
                                                m.setStatusMessage(fmt.Sprintf("✓ Selected: %s", selectedName), false)
                                        }</span>

                                        <span class="cov0" title="0">return m, nil</span>
                                }
                        }
                }
                // For all other keys in file picker mode, fall through to normal navigation
        }

        // Handle command prompt input (focus-based: only active when commandFocused)
        // Special keys that interact with command prompt
        <span class="cov0" title="0">switch msg.String() </span>{
        case "enter":<span class="cov0" title="0">
                // Execute command if command prompt is focused and has input
                if m.commandFocused &amp;&amp; m.commandInput != "" </span><span class="cov0" title="0">{
                        cmd := m.commandInput
                        m.addToHistory(cmd)
                        m.commandInput = ""
                        m.commandFocused = false // Exit command mode after executing
                        // Check for exit/quit commands
                        cmdLower := strings.ToLower(strings.TrimSpace(cmd))
                        if cmdLower == "exit" || cmdLower == "quit" </span><span class="cov0" title="0">{
                                return m, tea.Quit
                        }</span>
                        <span class="cov0" title="0">return m, runCommand(cmd, m.currentPath)</span>
                }
                // If not in command mode or no input, handle Enter for file navigation (below)

        case "backspace":<span class="cov0" title="0">
                // Delete last character from command if focused and has input
                if m.commandFocused &amp;&amp; len(m.commandInput) &gt; 0 </span><span class="cov0" title="0">{
                        m.commandInput = m.commandInput[:len(m.commandInput)-1]
                        return m, nil
                }</span>
                // If no command input, backspace does nothing

        case "esc":<span class="cov0" title="0">
                // Exit command mode if focused
                if m.commandFocused </span><span class="cov0" title="0">{
                        m.commandInput = ""
                        m.commandFocused = false
                        return m, nil
                }</span>
                // If there's leftover command input (but not focused), clear it
                <span class="cov0" title="0">if m.commandInput != "" </span><span class="cov0" title="0">{
                        m.commandInput = ""
                        return m, nil
                }</span>
                // If no command input, handle Esc for dual-pane exit (below)

        case ":":<span class="cov0" title="0">
                // Enter command mode (vim-style)
                if !m.commandFocused </span><span class="cov0" title="0">{
                        m.commandFocused = true
                        m.commandInput = ""
                        return m, nil
                }</span>
                // If already in command mode, add the colon to input
        }

        // Handle typing/pasting while command prompt is focused
        // Only capture input when commandFocused is true
        <span class="cov0" title="0">if m.commandFocused </span><span class="cov0" title="0">{
                // Use msg.Runes to get raw text (Bubble Tea handles escape sequences for us)
                // This avoids the brackets that msg.String() adds around paste events
                text := string(msg.Runes)

                // Only process if not a special key
                if len(text) &gt; 0 &amp;&amp; !isSpecialKey(msg.String()) </span><span class="cov0" title="0">{
                        // Check if it's printable text
                        isPrintable := true
                        for _, r := range msg.Runes </span><span class="cov0" title="0">{
                                if r &lt; 32 || r == 127 </span><span class="cov0" title="0">{ // Control characters
                                        isPrintable = false
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if isPrintable </span><span class="cov0" title="0">{
                                // Strip ANSI codes to prevent pasted styled text from corrupting command line
                                m.commandInput += stripANSI(text)
                                m.historyPos = len(m.commandHistory)
                                return m, nil
                        }</span>
                }
        }

        // Regular file browser keys
        <span class="cov0" title="0">switch msg.String() </span>{
        case "ctrl+p":<span class="cov0" title="0">
                // Ctrl+P: Fuzzy file search
                m.fuzzySearchActive = true
                return m, m.launchFuzzySearch()</span>

        case "/":<span class="cov0" title="0">
                // /: Enter directory search mode (filter files by name)
                m.searchMode = true
                m.searchQuery = ""
                m.filteredIndices = m.filterFilesBySearch("")
                return m, nil</span>

        case "f10", "ctrl+c":<span class="cov0" title="0">
                // F10: Quit (replaces q)
                return m, tea.Quit</span>

        case "esc":<span class="cov0" title="0">
                // Context-aware ESC behavior:
                // 1. Exit dual-pane mode if active
                // 2. Otherwise, go to parent directory (Windows-style back navigation)
                if m.viewMode == viewDualPane </span><span class="cov0" title="0">{
                        m.viewMode = viewSinglePane
                        m.calculateLayout()
                        m.populatePreviewCache() // Refresh cache with new width
                }</span> else<span class="cov0" title="0"> if m.currentPath != "/" </span><span class="cov0" title="0">{
                        // Go up one level
                        m.currentPath = filepath.Dir(m.currentPath)
                        m.cursor = 0
                        m.loadFiles()
                }</span>

        case "up":<span class="cov0" title="0">
                // If in command mode, navigate command history
                if m.commandFocused &amp;&amp; len(m.commandHistory) &gt; 0 </span><span class="cov0" title="0">{
                        m.commandInput = m.getPreviousCommand()
                        return m, nil
                }</span>
                // Otherwise fall through to file navigation
                <span class="cov0" title="0">fallthrough</span>
        case "k":<span class="cov0" title="0">
                if m.viewMode == viewDualPane </span><span class="cov0" title="0">{
                        // In dual-pane mode, check which pane is focused
                        if m.focusedPane == leftPane </span><span class="cov0" title="0">{
                                // Scroll file list
                                if m.cursor &gt; 0 </span><span class="cov0" title="0">{
                                        m.cursor--
                                        // Update preview if file selected
                                        if currentFile := m.getCurrentFile(); currentFile != nil &amp;&amp; !currentFile.isDir </span><span class="cov0" title="0">{
                                                m.loadPreview(currentFile.path)
                                                m.populatePreviewCache() // Populate cache with dual-pane width
                                        }</span>
                                }
                        } else<span class="cov0" title="0"> {
                                // Scroll preview up
                                if m.preview.scrollPos &gt; 0 </span><span class="cov0" title="0">{
                                        m.preview.scrollPos--
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Single-pane mode: just move cursor
                        if m.cursor &gt; 0 </span><span class="cov0" title="0">{
                                m.cursor--
                        }</span>
                }

        case "down":<span class="cov0" title="0">
                // If in command mode, navigate command history
                if m.commandFocused &amp;&amp; len(m.commandHistory) &gt; 0 </span><span class="cov0" title="0">{
                        m.commandInput = m.getNextCommand()
                        return m, nil
                }</span>
                // Otherwise fall through to file navigation
                <span class="cov0" title="0">fallthrough</span>
        case "j":<span class="cov0" title="0">
                if m.viewMode == viewDualPane </span><span class="cov0" title="0">{
                        // In dual-pane mode, check which pane is focused
                        if m.focusedPane == leftPane </span><span class="cov0" title="0">{
                                // Scroll file list
                                maxCursor := m.getMaxCursor()
                                if m.cursor &lt; maxCursor </span><span class="cov0" title="0">{
                                        m.cursor++
                                        // Update preview if file selected
                                        if currentFile := m.getCurrentFile(); currentFile != nil &amp;&amp; !currentFile.isDir </span><span class="cov0" title="0">{
                                                m.loadPreview(currentFile.path)
                                                m.populatePreviewCache() // Populate cache with dual-pane width
                                        }</span>
                                }
                        } else<span class="cov0" title="0"> {
                                // Scroll preview down
                                // Calculate visible lines: m.height - 5 (header) - 2 (preview title) = m.height - 7
                                visibleLines := m.height - 7
                                totalLines := m.getWrappedLineCount()
                                maxScroll := totalLines - visibleLines
                                if maxScroll &lt; 0 </span><span class="cov0" title="0">{
                                        maxScroll = 0
                                }</span>
                                <span class="cov0" title="0">if m.preview.scrollPos &lt; maxScroll </span><span class="cov0" title="0">{
                                        m.preview.scrollPos++
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Single-pane mode: just move cursor
                        maxCursor := m.getMaxCursor()
                        if m.cursor &lt; maxCursor </span><span class="cov0" title="0">{
                                m.cursor++
                        }</span>
                }

        case "enter":<span class="cov0" title="0">
                if currentFile := m.getCurrentFile(); currentFile != nil </span><span class="cov0" title="0">{
                        // Check if this is the prompts setup helper
                        if m.showPromptsOnly &amp;&amp; strings.HasPrefix(currentFile.name, "💡 Setup:") </span><span class="cov0" title="0">{
                                // Create ~/.prompts/ folder
                                if err := os.MkdirAll(currentFile.path, 0755); err != nil </span><span class="cov0" title="0">{
                                        m.setStatusMessage(fmt.Sprintf("Failed to create folder: %s", err), true)
                                }</span> else<span class="cov0" title="0"> {
                                        m.setStatusMessage("✓ Created ~/.prompts/ folder! Add .prompty, .yaml, .md, or .txt files here.", false)
                                        // Reload files to show the new folder instead of the helper
                                        m.loadFiles()
                                }</span>
                                <span class="cov0" title="0">return m, nil</span>
                        }

                        // If in favorites mode, check if we need to navigate to a different directory
                        <span class="cov0" title="0">if m.showFavoritesOnly &amp;&amp; currentFile.name != ".." </span><span class="cov0" title="0">{
                                // Check if favorite is in a different location than current path
                                fileDir := filepath.Dir(currentFile.path)
                                if currentFile.isDir </span><span class="cov0" title="0">{
                                        // Navigate to the favorited directory
                                        m.currentPath = currentFile.path
                                        m.cursor = 0
                                        m.showFavoritesOnly = false // Exit favorites mode
                                        m.loadFiles()
                                }</span> else<span class="cov0" title="0"> if fileDir != m.currentPath </span><span class="cov0" title="0">{
                                        // Navigate to the file's parent directory and select it
                                        m.currentPath = fileDir
                                        m.showFavoritesOnly = false // Exit favorites mode
                                        m.loadFiles()
                                        // Find and select the file
                                        for i, f := range m.files </span><span class="cov0" title="0">{
                                                if f.path == currentFile.path </span><span class="cov0" title="0">{
                                                        m.cursor = i
                                                        break</span>
                                                }
                                        }
                                } else<span class="cov0" title="0"> {
                                        // File is in current directory, just preview it
                                        m.loadPreview(currentFile.path)
                                        m.viewMode = viewFullPreview
                                        m.searchMode = false // Disable search mode in preview
                                        m.calculateLayout() // Update widths for full-screen
                                        // Populate cache synchronously for full preview (user expects instant display)
                                        m.populatePreviewCache()
                                        return m, nil
                                }</span>
                        } else<span class="cov0" title="0"> if currentFile.isDir </span><span class="cov0" title="0">{
                                // Navigate into directory (consistent across all views)
                                // Arrow keys (←/→) handle tree expansion/collapse
                                m.currentPath = currentFile.path
                                m.cursor = 0
                                m.loadFiles()
                        }</span> else<span class="cov0" title="0"> {
                                // Enter full-screen preview (regardless of current mode)
                                m.loadPreview(currentFile.path)
                                m.viewMode = viewFullPreview
                                m.calculateLayout() // Update widths for full-screen
                                // Populate cache synchronously for full preview (user expects instant display)
                                m.populatePreviewCache()
                                return m, nil
                        }</span>
                }

        case "tab":<span class="cov0" title="0">
                // Priority 1: If input fields are active, navigate between fields
                if m.inputFieldsActive &amp;&amp; len(m.promptInputFields) &gt; 0 </span><span class="cov0" title="0">{
                        m.focusedInputField++
                        if m.focusedInputField &gt;= len(m.promptInputFields) </span><span class="cov0" title="0">{
                                m.focusedInputField = 0 // Wrap around
                        }</span>
                        <span class="cov0" title="0">return m, nil</span>
                }

                // Priority 2: In dual-pane mode: cycle focus between left and right pane
                // Priority 3: In single-pane mode: enter dual-pane mode
                <span class="cov0" title="0">if m.viewMode == viewDualPane </span><span class="cov0" title="0">{
                        // Cycle through: left → right → left
                        if m.focusedPane == leftPane </span><span class="cov0" title="0">{
                                m.focusedPane = rightPane
                        }</span> else<span class="cov0" title="0"> {
                                m.focusedPane = leftPane
                        }</span>
                } else<span class="cov0" title="0"> if m.viewMode == viewSinglePane </span><span class="cov0" title="0">{
                        // Check if current display mode supports dual-pane
                        if !m.isDualPaneCompatible() </span><span class="cov0" title="0">{
                                m.setStatusMessage("Dual-pane mode requires List or Tree view (press 1 or 4)", true)
                                return m, nil
                        }</span>
                        // Enter dual-pane mode
                        <span class="cov0" title="0">m.viewMode = viewDualPane
                        m.focusedPane = leftPane
                        m.calculateLayout()
                        // Load preview of current file
                        if currentFile := m.getCurrentFile(); currentFile != nil &amp;&amp; !currentFile.isDir </span><span class="cov0" title="0">{
                                m.loadPreview(currentFile.path)
                                m.populatePreviewCache() // Populate cache with dual-pane width
                        }</span>
                }

        case " ":<span class="cov0" title="0">
                // Space: toggle dual-pane mode on/off
                if m.viewMode == viewSinglePane </span><span class="cov0" title="0">{
                        // Check if current display mode supports dual-pane
                        if !m.isDualPaneCompatible() </span><span class="cov0" title="0">{
                                m.setStatusMessage("Dual-pane mode requires List or Tree view (press 1 or 4)", true)
                                return m, nil
                        }</span>
                        <span class="cov0" title="0">m.viewMode = viewDualPane
                        m.focusedPane = leftPane
                        m.calculateLayout()
                        // Load preview of current file
                        if currentFile := m.getCurrentFile(); currentFile != nil &amp;&amp; !currentFile.isDir </span><span class="cov0" title="0">{
                                m.loadPreview(currentFile.path)
                                m.populatePreviewCache() // Populate cache with dual-pane width
                        }</span>
                } else<span class="cov0" title="0"> if m.viewMode == viewDualPane </span><span class="cov0" title="0">{
                        m.viewMode = viewSinglePane
                        m.calculateLayout()
                        m.populatePreviewCache() // Refresh cache with new width
                }</span>

        case "f3":<span class="cov0" title="0">
                // F3: Open in browser (images/HTML) or full-screen preview
                if currentFile := m.getCurrentFile(); currentFile != nil &amp;&amp; !currentFile.isDir </span><span class="cov0" title="0">{
                        // Check if this is an image or HTML file
                        if isBrowserFile(currentFile.path) </span><span class="cov0" title="0">{
                                // Open in browser
                                return m, openInBrowser(currentFile.path)
                        }</span> else<span class="cov0" title="0"> {
                                // Open in full-screen preview
                                m.loadPreview(currentFile.path)
                                m.viewMode = viewFullPreview
                                m.calculateLayout() // Update widths for full-screen
                                m.populatePreviewCache() // Repopulate cache with correct width
                                // Clear screen for clean rendering
                                return m, tea.ClearScreen
                        }</span>
                }

        case "pageup", "pgup":<span class="cov0" title="0">
                // Page up in dual-pane mode (only works when right pane focused)
                if m.viewMode == viewDualPane &amp;&amp; m.focusedPane == rightPane </span><span class="cov0" title="0">{
                        visibleLines := m.height - 7
                        m.preview.scrollPos -= visibleLines
                        if m.preview.scrollPos &lt; 0 </span><span class="cov0" title="0">{
                                m.preview.scrollPos = 0
                        }</span>
                        <span class="cov0" title="0">return m, nil</span>
                }

        case "pagedown", "pgdn", "pgdown":<span class="cov0" title="0">
                // Page down in dual-pane mode (only works when right pane focused)
                if m.viewMode == viewDualPane &amp;&amp; m.focusedPane == rightPane </span><span class="cov0" title="0">{
                        // Calculate visible lines: m.height - 5 (header) - 2 (preview title) = m.height - 7
                        visibleLines := m.height - 7
                        totalLines := m.getWrappedLineCount()
                        maxScroll := totalLines - visibleLines
                        if maxScroll &lt; 0 </span><span class="cov0" title="0">{
                                maxScroll = 0
                        }</span>
                        <span class="cov0" title="0">m.preview.scrollPos += visibleLines
                        if m.preview.scrollPos &gt; maxScroll </span><span class="cov0" title="0">{
                                m.preview.scrollPos = maxScroll
                        }</span>
                        <span class="cov0" title="0">return m, nil</span>
                }

        case "left":<span class="cov0" title="0">
                // In tree mode: collapse folder or go to parent
                // In other modes: go to parent directory
                if m.displayMode == modeTree </span><span class="cov0" title="0">{
                        if currentFile := m.getCurrentFile(); currentFile != nil </span><span class="cov0" title="0">{
                                if currentFile.isDir &amp;&amp; currentFile.name != ".." </span><span class="cov0" title="0">{
                                        // If directory is expanded, collapse it
                                        if m.expandedDirs[currentFile.path] </span><span class="cov0" title="0">{
                                                m.expandedDirs[currentFile.path] = false
                                        }</span> else<span class="cov0" title="0"> {
                                                // Already collapsed, go to parent
                                                if m.currentPath != "/" </span><span class="cov0" title="0">{
                                                        m.currentPath = filepath.Dir(m.currentPath)
                                                        m.cursor = 0
                                                        m.loadFiles()
                                                }</span>
                                        }
                                } else<span class="cov0" title="0"> {
                                        // Not a directory or is "..", go to parent
                                        if m.currentPath != "/" </span><span class="cov0" title="0">{
                                                m.currentPath = filepath.Dir(m.currentPath)
                                                m.cursor = 0
                                                m.loadFiles()
                                        }</span>
                                }
                        }
                } else<span class="cov0" title="0"> {
                        // Non-tree modes: go to parent directory
                        if m.currentPath != "/" </span><span class="cov0" title="0">{
                                m.currentPath = filepath.Dir(m.currentPath)
                                m.cursor = 0
                                m.loadFiles()
                        }</span>
                }

        case "h":<span class="cov0" title="0">
                // 'h' always goes to parent (vim-style)
                if m.currentPath != "/" </span><span class="cov0" title="0">{
                        m.currentPath = filepath.Dir(m.currentPath)
                        m.cursor = 0
                        m.loadFiles()
                }</span>

        case "right":<span class="cov0" title="0">
                // In tree mode: expand folder or navigate into it
                // In other modes: navigate into selected directory
                if currentFile := m.getCurrentFile(); currentFile != nil &amp;&amp; currentFile.isDir &amp;&amp; currentFile.name != ".." </span><span class="cov0" title="0">{
                        if m.displayMode == modeTree </span><span class="cov0" title="0">{
                                // If directory is collapsed, expand it
                                if !m.expandedDirs[currentFile.path] </span><span class="cov0" title="0">{
                                        m.expandedDirs[currentFile.path] = true
                                }</span> else<span class="cov0" title="0"> {
                                        // Already expanded, navigate into it
                                        m.currentPath = currentFile.path
                                        m.cursor = 0
                                        m.loadFiles()
                                }</span>
                        } else<span class="cov0" title="0"> {
                                // Non-tree modes: navigate into directory
                                m.currentPath = currentFile.path
                                m.cursor = 0
                                m.loadFiles()
                        }</span>
                }

        case "l":<span class="cov0" title="0">
                // 'l' always navigates into directory (vim-style)
                if currentFile := m.getCurrentFile(); currentFile != nil &amp;&amp; currentFile.isDir </span><span class="cov0" title="0">{
                        m.currentPath = currentFile.path
                        m.cursor = 0
                        m.loadFiles()
                }</span>

        case ".", "ctrl+h":<span class="cov0" title="0">
                // Toggle hidden files
                m.showHidden = !m.showHidden
                m.loadFiles()</span>

        case "f9":<span class="cov0" title="0">
                // F9: Cycle through display modes (replaces v)
                m.displayMode = (m.displayMode + 1) % 4
                // Auto-exit dual-pane if switching to incompatible mode
                if m.viewMode == viewDualPane &amp;&amp; !m.isDualPaneCompatible() </span><span class="cov0" title="0">{
                        m.viewMode = viewSinglePane
                        m.calculateLayout()
                        m.populatePreviewCache()
                }</span>

        case "1":<span class="cov0" title="0">
                // Switch to list view
                m.displayMode = modeList</span>

        case "2":<span class="cov0" title="0">
                // Switch to grid view
                m.displayMode = modeGrid
                // Auto-exit dual-pane (grid view needs full width)
                if m.viewMode == viewDualPane </span><span class="cov0" title="0">{
                        m.viewMode = viewSinglePane
                        m.calculateLayout()
                        m.populatePreviewCache()
                }</span>

        case "3":<span class="cov0" title="0">
                // Switch to detail view
                m.displayMode = modeDetail
                // Auto-exit dual-pane (detail view needs full width)
                if m.viewMode == viewDualPane </span><span class="cov0" title="0">{
                        m.viewMode = viewSinglePane
                        m.calculateLayout()
                        m.populatePreviewCache()
                }</span>

        case "4":<span class="cov0" title="0">
                // Switch to tree view
                m.displayMode = modeTree</span>

        case "f4":<span class="cov0" title="0">
                // F4: Edit file in external editor (replaces e/E)
                if currentFile := m.getCurrentFile(); currentFile != nil &amp;&amp; !currentFile.isDir </span><span class="cov0" title="0">{
                        editor := getAvailableEditor()
                        if editor == "" </span><span class="cov0" title="0">{
                                m.setStatusMessage("No editor available (tried micro, nano, vim, vi)", true)
                                return m, nil
                        }</span>
                        // Prefer micro if available, otherwise use whatever was found
                        <span class="cov0" title="0">if editorAvailable("micro") </span><span class="cov0" title="0">{
                                editor = "micro"
                        }</span>
                        <span class="cov0" title="0">return m, openEditor(editor, currentFile.path)</span>
                }

        case "n", "N":<span class="cov0" title="0">
                // Edit file in nano specifically
                if currentFile := m.getCurrentFile(); currentFile != nil &amp;&amp; !currentFile.isDir </span><span class="cov0" title="0">{
                        if editorAvailable("nano") </span><span class="cov0" title="0">{
                                return m, openEditor("nano", currentFile.path)
                        }</span>
                }

        case "f5":<span class="cov0" title="0">
                // F5: Copy rendered prompt (in prompts mode) or file path (regular mode)
                if currentFile := m.getCurrentFile(); currentFile != nil </span><span class="cov0" title="0">{
                        // Special handling for prompts mode: copy rendered prompt
                        if m.showPromptsOnly &amp;&amp; !currentFile.isDir &amp;&amp; isPromptFile(*currentFile) </span><span class="cov0" title="0">{
                                if m.preview.isPrompt &amp;&amp; m.preview.promptTemplate != nil </span><span class="cov0" title="0">{
                                        // Get context variables
                                        contextVars := getContextVariables(&amp;m)
                                        // Render the template with variables substituted
                                        rendered := renderPromptTemplate(m.preview.promptTemplate, contextVars)

                                        // Copy to clipboard
                                        if err := copyToClipboard(rendered); err != nil </span><span class="cov0" title="0">{
                                                m.setStatusMessage(fmt.Sprintf("Failed to copy prompt: %s", err), true)
                                        }</span> else<span class="cov0" title="0"> {
                                                m.setStatusMessage("✓ Prompt copied to clipboard", false)
                                        }</span>
                                        <span class="cov0" title="0">return m, nil</span>
                                }
                        }

                        // Regular mode: copy file path
                        <span class="cov0" title="0">if err := copyToClipboard(currentFile.path); err != nil </span><span class="cov0" title="0">{
                                m.setStatusMessage(fmt.Sprintf("Failed to copy to clipboard: %s", err), true)
                        }</span> else<span class="cov0" title="0"> {
                                m.setStatusMessage("Path copied to clipboard", false)
                        }</span>
                }

        // Note: 's' key removed to allow typing 's' in command prompt
        // To toggle favorites, use F2 (context menu) or right-click → "☆ Add Favorite"

        case "f6":<span class="cov0" title="0">
                // F6: Toggle favorites filter (replaces b/B)
                m.showFavoritesOnly = !m.showFavoritesOnly</span>

        case "f11":<span class="cov0" title="0">
                // F11: Toggle prompts filter (show only .yaml, .md, .txt files)
                m.showPromptsOnly = !m.showPromptsOnly

                // Auto-expand ~/.prompts when filter is turned on
                if m.showPromptsOnly </span><span class="cov0" title="0">{
                        if homeDir, err := os.UserHomeDir(); err == nil </span><span class="cov0" title="0">{
                                globalPromptsDir := filepath.Join(homeDir, ".prompts")
                                // Check if ~/.prompts exists
                                if info, err := os.Stat(globalPromptsDir); err == nil &amp;&amp; info.IsDir() </span><span class="cov0" title="0">{
                                        // Expand the ~/.prompts directory
                                        m.expandedDirs[globalPromptsDir] = true
                                }</span> else<span class="cov0" title="0"> {
                                        // ~/.prompts doesn't exist - show helpful message
                                        m.setStatusMessage("💡 Tip: Create ~/.prompts/ folder for global prompts (see helper below)", false)
                                }</span>
                        }
                }

                // If currently viewing a prompt file, create/clear input fields
                <span class="cov0" title="0">if m.preview.isPrompt &amp;&amp; m.preview.promptTemplate != nil </span><span class="cov0" title="0">{
                        if m.showPromptsOnly </span><span class="cov0" title="0">{
                                // Entering prompts mode - create input fields
                                m.promptInputFields = createInputFields(m.preview.promptTemplate, &amp;m)
                                m.inputFieldsActive = len(m.promptInputFields) &gt; 0
                                m.focusedInputField = 0
                        }</span> else<span class="cov0" title="0"> {
                                // Exiting prompts mode - clear input fields
                                m.promptInputFields = nil
                                m.inputFieldsActive = false
                                m.focusedInputField = 0
                        }</span>
                }

        case "f12":<span class="cov0" title="0">
                // F12: Toggle trash/recycle bin view
                m.showTrashOnly = !m.showTrashOnly
                m.showFavoritesOnly = false // Disable favorites filter
                m.showPromptsOnly = false   // Disable prompts filter
                m.cursor = 0

                if m.showTrashOnly </span><span class="cov0" title="0">{
                        // Default to detail view for trash
                        m.displayMode = modeDetail
                }</span>

        case "f1":<span class="cov0" title="0">
                // F1: Show hotkeys reference (replaces ?)
                hotkeysPath := filepath.Join(filepath.Dir(m.currentPath), "HOTKEYS.md")
                // Try to find HOTKEYS.md in the TFE directory
                // First check if it exists in current directory
                if _, err := os.Stat(hotkeysPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        // Try executable directory
                        if exePath, err := os.Executable(); err == nil </span><span class="cov0" title="0">{
                                hotkeysPath = filepath.Join(filepath.Dir(exePath), "HOTKEYS.md")
                        }</span>
                }
                // Load and show the hotkeys file if it exists
                <span class="cov0" title="0">if _, err := os.Stat(hotkeysPath); err == nil </span><span class="cov0" title="0">{
                        m.loadPreview(hotkeysPath)
                        m.viewMode = viewFullPreview
                        m.searchMode = false // Disable search mode in preview
                        m.calculateLayout() // Update widths for full-screen
                        m.populatePreviewCache() // Repopulate cache with correct width
                        // Clear screen for clean rendering
                        return m, tea.ClearScreen
                }</span>

        case "f2":<span class="cov0" title="0">
                // F2: Open context menu at cursor position (keyboard alternative to right-click)
                if currentFile := m.getCurrentFile(); currentFile != nil </span><span class="cov0" title="0">{
                        // Calculate menu position based on cursor
                        headerOffset := 5 // Account for borders (title + toolbar + command + separator + border)
                        if m.displayMode == modeDetail </span><span class="cov0" title="0">{
                                headerOffset = 6 // Detail view has header at line 5, content starts at 6 (separator removed)
                        }</span>

                        // Calculate visible range to account for scrolling
                        <span class="cov0" title="0">maxVisible := m.height - 7 // Match rendering calculation
                        if m.displayMode == modeDetail </span><span class="cov0" title="0">{
                                maxVisible -= 1 // Account for detail header only (separator removed)
                        }</span>
                        <span class="cov0" title="0">start, _ := m.getVisibleRange(maxVisible)

                        // Calculate Y position relative to visible cursor position
                        menuY := headerOffset + (m.cursor - start)
                        menuX := 10 // Left margin for menu (increased for border visibility)

                        // Open menu
                        m.contextMenuOpen = true
                        m.contextMenuX = menuX
                        m.contextMenuY = menuY
                        m.contextMenuFile = currentFile
                        m.contextMenuCursor = 0</span>
                }

        case "f7":<span class="cov0" title="0">
                // F7: Create directory
                m.dialog = dialogModel{
                        dialogType: dialogInput,
                        title:      "Create Directory",
                        message:    "Enter directory name:",
                        input:      "",
                }
                m.showDialog = true
                return m, tea.ClearScreen</span>

        case "f8":<span class="cov0" title="0">
                // F8: Delete file/folder
                if len(m.files) == 0 || m.cursor &gt;= len(m.files) </span><span class="cov0" title="0">{
                        return m, nil
                }</span>

                <span class="cov0" title="0">currentFile := m.getCurrentFile()
                if currentFile == nil || currentFile.name == ".." </span><span class="cov0" title="0">{
                        return m, nil // Can't delete parent
                }</span>

                // Show confirmation dialog
                <span class="cov0" title="0">fileType := "file"
                if currentFile.isDir </span><span class="cov0" title="0">{
                        fileType = "directory"
                }</span>
                <span class="cov0" title="0">m.dialog = dialogModel{
                        dialogType: dialogConfirm,
                        title:      "Delete " + fileType,
                        message:    fmt.Sprintf("Delete '%s'?\nThis cannot be undone.", currentFile.name),
                }
                m.showDialog = true
                return m, tea.ClearScreen</span>

        // Default case removed - command input is now focus-based (press : to enter command mode)
        // This prevents stray characters (including terminal response sequences) from leaking into command prompt
        }

        <span class="cov0" title="0">return m, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package main

import (
        "fmt"
        "os"
        "path/filepath"
        "time"

        tea "github.com/charmbracelet/bubbletea"
)

// Module: update_mouse.go
// Purpose: Mouse event handling for TFE
// Responsibilities:
// - Processing all mouse input events
// - Left/right click handling
// - Double-click detection
// - Context menu mouse interaction
// - Mouse wheel scrolling
// - Clickable UI elements

// handleMouseEvent processes all mouse input
func (m model) handleMouseEvent(msg tea.MouseMsg) (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        // If fuzzy search is active, don't process any mouse events
        // (go-fzf handles its own input)
        if m.fuzzySearchActive </span><span class="cov0" title="0">{
                return m, nil
        }</span>

        // Handle mouse wheel scrolling in full-screen preview mode
        <span class="cov0" title="0">if m.viewMode == viewFullPreview </span><span class="cov0" title="0">{
                switch msg.Button </span>{
                case tea.MouseButtonWheelUp:<span class="cov0" title="0">
                        // Scroll 3 lines per wheel tick for smoother scrolling
                        m.preview.scrollPos -= 3
                        if m.preview.scrollPos &lt; 0 </span><span class="cov0" title="0">{
                                m.preview.scrollPos = 0
                        }</span>
                case tea.MouseButtonWheelDown:<span class="cov0" title="0">
                        totalLines := m.getWrappedLineCount()
                        maxScroll := totalLines - (m.height - 6)
                        if maxScroll &lt; 0 </span><span class="cov0" title="0">{
                                maxScroll = 0
                        }</span>
                        // Scroll 3 lines per wheel tick for smoother scrolling
                        <span class="cov0" title="0">m.preview.scrollPos += 3
                        if m.preview.scrollPos &gt; maxScroll </span><span class="cov0" title="0">{
                                m.preview.scrollPos = maxScroll
                        }</span>
                }
                <span class="cov0" title="0">return m, nil</span>
        }

        // In dual-pane mode, detect which pane was clicked to switch focus
        <span class="cov0" title="0">if m.viewMode == viewDualPane &amp;&amp; msg.Action == tea.MouseActionRelease &amp;&amp; msg.Button == tea.MouseButtonLeft </span><span class="cov0" title="0">{
                // Check if click is in left or right pane (not in header or status bar)
                // Header is 4 lines total (title, path, command, separator)
                if msg.Y &gt;= 4 &amp;&amp; msg.Y &lt; m.height-1 </span><span class="cov0" title="0">{ // Skip header (4 lines) and status bar (1 line)
                        if msg.X &lt; m.leftWidth </span><span class="cov0" title="0">{
                                m.focusedPane = leftPane
                        }</span> else<span class="cov0" title="0"> if msg.X &gt; m.leftWidth </span><span class="cov0" title="0">{ // Account for separator
                                m.focusedPane = rightPane
                        }</span>
                }
        }

        <span class="cov0" title="0">switch msg.Button </span>{
        case tea.MouseButtonLeft:<span class="cov0" title="0">
                if msg.Action == tea.MouseActionRelease </span><span class="cov0" title="0">{
                        // Check for toolbar button clicks (Y=1)
                        // Toolbar: [🏠] [⭐/✨] [&gt;_] [🔍] [📝] [🗑️]
                        // Note: Emojis render as 2 characters wide in terminals
                        if msg.Y == 1 </span><span class="cov0" title="0">{
                                // Home button [🏠] (X=0-4: [ + emoji(2) + ] + space)
                                if msg.X &gt;= 0 &amp;&amp; msg.X &lt;= 4 </span><span class="cov0" title="0">{
                                        // Navigate to home directory
                                        homeDir, err := os.UserHomeDir()
                                        if err == nil </span><span class="cov0" title="0">{
                                                m.currentPath = homeDir
                                                m.cursor = 0
                                                m.loadFiles()
                                        }</span>
                                        <span class="cov0" title="0">return m, nil</span>
                                }
                                // Star button [⭐/✨] (X=5-9: [ + emoji(2) + ] + space)
                                <span class="cov0" title="0">if msg.X &gt;= 5 &amp;&amp; msg.X &lt;= 9 </span><span class="cov0" title="0">{
                                        // Toggle favorites filter (like F6)
                                        m.showFavoritesOnly = !m.showFavoritesOnly
                                        m.cursor = 0
                                        if m.showFavoritesOnly </span><span class="cov0" title="0">{
                                                m.loadFiles()
                                        }</span>
                                        <span class="cov0" title="0">return m, nil</span>
                                }
                                // Terminal button [&gt;_] (X=10-14: [ + &gt;_(2) + ] + space)
                                <span class="cov0" title="0">if msg.X &gt;= 10 &amp;&amp; msg.X &lt;= 14 </span><span class="cov0" title="0">{
                                        // Toggle command mode focus
                                        m.commandFocused = !m.commandFocused
                                        if !m.commandFocused </span><span class="cov0" title="0">{
                                                // Clear command input when exiting command mode via click
                                                m.commandInput = ""
                                        }</span>
                                        <span class="cov0" title="0">return m, nil</span>
                                }
                                // Fuzzy search button [🔍] (X=15-19: [ + emoji(2) + ])
                                <span class="cov0" title="0">if msg.X &gt;= 15 &amp;&amp; msg.X &lt;= 19 </span><span class="cov0" title="0">{
                                        // Launch fuzzy search
                                        m.fuzzySearchActive = true
                                        return m, m.launchFuzzySearch()
                                }</span>
                                // Prompts filter button [📝] or [✨📝] (X=20-29 or beyond for active state)
                                <span class="cov0" title="0">if msg.X &gt;= 20 &amp;&amp; msg.X &lt;= 29 </span><span class="cov0" title="0">{
                                        // Toggle prompts filter
                                        m.showPromptsOnly = !m.showPromptsOnly

                                        // Auto-expand ~/.prompts when filter is turned on
                                        if m.showPromptsOnly </span><span class="cov0" title="0">{
                                                if homeDir, err := os.UserHomeDir(); err == nil </span><span class="cov0" title="0">{
                                                        globalPromptsDir := filepath.Join(homeDir, ".prompts")
                                                        // Check if ~/.prompts exists
                                                        if info, err := os.Stat(globalPromptsDir); err == nil &amp;&amp; info.IsDir() </span><span class="cov0" title="0">{
                                                                // Expand the ~/.prompts directory
                                                                m.expandedDirs[globalPromptsDir] = true
                                                        }</span>
                                                }
                                        }
                                        <span class="cov0" title="0">return m, nil</span>
                                }
                                // Trash button [🗑️] or [♻️] (X=30-34: [ + emoji(2) + ])
                                <span class="cov0" title="0">if msg.X &gt;= 30 &amp;&amp; msg.X &lt;= 34 </span><span class="cov0" title="0">{
                                        // Toggle trash view
                                        m.showTrashOnly = !m.showTrashOnly
                                        m.showFavoritesOnly = false // Disable favorites filter
                                        m.showPromptsOnly = false   // Disable prompts filter
                                        m.cursor = 0

                                        if m.showTrashOnly </span><span class="cov0" title="0">{
                                                // Load trash items and convert to fileItems for display
                                                // Default to detail view for trash
                                                m.displayMode = modeDetail
                                                m.loadFiles()
                                        }</span> else<span class="cov0" title="0"> {
                                                // Exit trash view, reload normal files
                                                m.loadFiles()
                                        }</span>
                                        <span class="cov0" title="0">return m, nil</span>
                                }
                        }

                        // Handle context menu clicks if menu is open
                        <span class="cov0" title="0">if m.contextMenuOpen </span><span class="cov0" title="0">{
                                // Calculate menu bounds
                                menuItems := m.getContextMenuItems()
                                menuHeight := len(menuItems) + 2 // items + top/bottom border
                                // Calculate menu width from items
                                maxWidth := 0
                                for _, item := range menuItems </span><span class="cov0" title="0">{
                                        width := visualWidth(item.label)
                                        if width &gt; maxWidth </span><span class="cov0" title="0">{
                                                maxWidth = width
                                        }</span>
                                }
                                <span class="cov0" title="0">menuWidth := maxWidth + 4 + 2 // padding + borders

                                // Check if click is within menu bounds
                                if msg.X &gt;= m.contextMenuX &amp;&amp; msg.X &lt;= m.contextMenuX+menuWidth &amp;&amp;
                                        msg.Y &gt;= m.contextMenuY &amp;&amp; msg.Y &lt;= m.contextMenuY+menuHeight </span><span class="cov0" title="0">{
                                        // Click is inside menu - calculate which item was clicked
                                        clickedItemIndex := msg.Y - m.contextMenuY - 1 // -1 for top border
                                        if clickedItemIndex &gt;= 0 &amp;&amp; clickedItemIndex &lt; len(menuItems) </span><span class="cov0" title="0">{
                                                // Update cursor and execute the clicked item
                                                m.contextMenuCursor = clickedItemIndex
                                                return m.executeContextMenuAction()
                                        }</span>
                                }

                                // Click is outside menu - close it
                                <span class="cov0" title="0">m.contextMenuOpen = false
                                return m, nil</span>
                        }

                        // In dual-pane mode, only process file clicks if within left pane
                        <span class="cov0" title="0">if m.viewMode == viewDualPane &amp;&amp; msg.X &gt;= m.leftWidth </span><span class="cov0" title="0">{
                                // Click is in right pane or beyond - don't select files
                                break</span>
                        }

                        // Handle column header clicks in detail view (for sorting)
                        // Both modes: header at Y=5 (both have top borders now)
                        <span class="cov0" title="0">detailHeaderY := 5

                        if m.displayMode == modeDetail &amp;&amp; msg.Y == detailHeaderY </span><span class="cov0" title="0">{
                                // Adjust X for left border (both modes have borders now)
                                adjustedX := msg.X - 2 // Account for left border

                                // Calculate which column was clicked based on X position
                                // Header format (regular): "%-30s  %-10s  %-12s  %-15s" with 2-space left padding
                                // Columns: Name (2-32), Size (34-44), Modified (46-58), Type (60-75)
                                // Header format (favorites): "%-25s  %-10s  %-12s  %-25s" with 2-space left padding
                                // Columns: Name (2-27), Size (29-39), Modified (41-53), Location (55-80)

                                var newSortBy string
                                if m.showFavoritesOnly </span><span class="cov0" title="0">{
                                        // Favorites mode column ranges
                                        if adjustedX &gt;= 2 &amp;&amp; adjustedX &lt;= 27 </span><span class="cov0" title="0">{
                                                newSortBy = "name"
                                        }</span> else<span class="cov0" title="0"> if adjustedX &gt;= 29 &amp;&amp; adjustedX &lt;= 39 </span><span class="cov0" title="0">{
                                                newSortBy = "size"
                                        }</span> else<span class="cov0" title="0"> if adjustedX &gt;= 41 &amp;&amp; adjustedX &lt;= 53 </span><span class="cov0" title="0">{
                                                newSortBy = "modified"
                                        }</span> else<span class="cov0" title="0"> if adjustedX &gt;= 55 &amp;&amp; adjustedX &lt;= 80 </span><span class="cov0" title="0">{
                                                // Location column - not sortable yet, ignore
                                                break</span>
                                        }
                                } else<span class="cov0" title="0"> {
                                        // Regular mode column ranges
                                        if adjustedX &gt;= 2 &amp;&amp; adjustedX &lt;= 32 </span><span class="cov0" title="0">{
                                                newSortBy = "name"
                                        }</span> else<span class="cov0" title="0"> if adjustedX &gt;= 34 &amp;&amp; adjustedX &lt;= 44 </span><span class="cov0" title="0">{
                                                newSortBy = "size"
                                        }</span> else<span class="cov0" title="0"> if adjustedX &gt;= 46 &amp;&amp; adjustedX &lt;= 58 </span><span class="cov0" title="0">{
                                                newSortBy = "modified"
                                        }</span> else<span class="cov0" title="0"> if adjustedX &gt;= 60 &amp;&amp; adjustedX &lt;= 75 </span><span class="cov0" title="0">{
                                                newSortBy = "type"
                                        }</span>
                                }

                                // Apply sorting if a valid column was clicked
                                <span class="cov0" title="0">if newSortBy != "" </span><span class="cov0" title="0">{
                                        if m.sortBy == newSortBy </span><span class="cov0" title="0">{
                                                // Same column - toggle sort direction
                                                m.sortAsc = !m.sortAsc
                                        }</span> else<span class="cov0" title="0"> {
                                                // Different column - set new sort, default to ascending
                                                m.sortBy = newSortBy
                                                m.sortAsc = true
                                        }</span>

                                        // Re-sort files and maintain cursor position if possible
                                        <span class="cov0" title="0">currentFile := m.getCurrentFile()
                                        m.sortFiles()

                                        // Try to keep cursor on the same file after sorting
                                        if currentFile != nil </span><span class="cov0" title="0">{
                                                for i, file := range m.files </span><span class="cov0" title="0">{
                                                        if file.path == currentFile.path </span><span class="cov0" title="0">{
                                                                m.cursor = i
                                                                break</span>
                                                        }
                                                }
                                        }

                                        <span class="cov0" title="0">return m, nil</span>
                                }
                        }

                        // Calculate which item was clicked (accounting for header lines and scrolling)
                        // Both modes: title(0) + toolbar(1) + command(2) + separator(3) = 4 lines
                        // Both modes now have bordered boxes, so top border adds 1 more line
                        // File content starts at line 5 in both single-pane and dual-pane
                        <span class="cov0" title="0">headerOffset := 5 // +1 for top border of the box (both modes have borders now)
                        if m.displayMode == modeDetail </span><span class="cov0" title="0">{
                                headerOffset += 1 // Add 1 for detail view's header only (separator removed)
                        }</span>

                        // Calculate visible range to account for scrolling
                        // Must match view.go and render_preview.go calculations
                        <span class="cov0" title="0">var maxVisible int
                        var contentHeight int

                        if m.viewMode == viewDualPane </span><span class="cov0" title="0">{
                                // Dual-pane: maxVisible = m.height - 7 (total pane height INCLUDING borders)
                                // See render_preview.go:845
                                maxVisible = m.height - 7
                                contentHeight = maxVisible - 2 // Content area inside borders
                        }</span> else<span class="cov0" title="0"> {
                                // Single-pane: maxVisible = m.height - 9 (total box height INCLUDING borders)
                                // See view.go:154
                                maxVisible = m.height - 9
                                contentHeight = maxVisible - 2 // Content area inside borders
                        }</span>

                        <span class="cov0" title="0">maxVisible = contentHeight // Use contentHeight for consistency with rendering
                        if m.displayMode == modeDetail </span><span class="cov0" title="0">{
                                maxVisible -= 1 // Account for detail header only
                        }</span>

                        // Get filtered files for click detection (respects favorites filter)
                        // This must match what's actually rendered on screen
                        <span class="cov0" title="0">var displayedFiles []fileItem
                        if m.displayMode == modeTree </span><span class="cov0" title="0">{
                                // Tree mode uses treeItems, not filtered files
                                displayedFiles = nil // Will use m.treeItems instead
                        }</span> else<span class="cov0" title="0"> {
                                displayedFiles = m.getFilteredFiles()
                        }</span>

                        <span class="cov0" title="0">var clickedIndex int
                        var clickedLine int

                        // Grid view requires calculating both row and column from X,Y coordinates
                        if m.displayMode == modeGrid </span><span class="cov0" title="0">{
                                // Calculate which row was clicked
                                clickedRow := msg.Y - headerOffset

                                // Adjust X coordinate for left border (both modes have borders now)
                                adjustedX := msg.X - 2 // Account for left border
                                if adjustedX &lt; 0 </span><span class="cov0" title="0">{
                                        adjustedX = 0
                                }</span>

                                // Calculate which column was clicked
                                // Each grid cell: icon(2) + fav_indicator(2) + name(12) + padding(2) = 18 chars
                                <span class="cov0" title="0">cellWidth := 18
                                clickedCol := adjustedX / cellWidth
                                if clickedCol &gt;= m.gridColumns </span><span class="cov0" title="0">{
                                        clickedCol = m.gridColumns - 1
                                }</span>

                                // Calculate visible row range (grid mode uses rows, not items)
                                <span class="cov0" title="0">totalItems := len(displayedFiles)
                                rows := (totalItems + m.gridColumns - 1) / m.gridColumns

                                startRow := 0
                                endRow := rows
                                if rows &gt; maxVisible </span><span class="cov0" title="0">{
                                        cursorRow := m.cursor / m.gridColumns
                                        startRow = cursorRow - maxVisible/2
                                        if startRow &lt; 0 </span><span class="cov0" title="0">{
                                                startRow = 0
                                        }</span>
                                        <span class="cov0" title="0">endRow = startRow + maxVisible
                                        if endRow &gt; rows </span><span class="cov0" title="0">{
                                                endRow = rows
                                                startRow = endRow - maxVisible
                                                if startRow &lt; 0 </span><span class="cov0" title="0">{
                                                        startRow = 0
                                                }</span>
                                        }
                                }

                                // Convert click to item index
                                <span class="cov0" title="0">actualRow := startRow + clickedRow
                                clickedIndex = actualRow*m.gridColumns + clickedCol

                                // Validate the clicked index is within bounds
                                if clickedRow &lt; 0 || actualRow &gt;= endRow || clickedIndex &gt;= len(displayedFiles) </span><span class="cov0" title="0">{
                                        clickedIndex = -1
                                }</span>
                        } else<span class="cov0" title="0"> {
                                // List, Detail, and Tree modes: one item per line
                                // In tree mode, use tree items instead of files
                                var totalItems int
                                if m.displayMode == modeTree </span><span class="cov0" title="0">{
                                        totalItems = len(m.treeItems)
                                }</span> else<span class="cov0" title="0"> {
                                        totalItems = len(displayedFiles)
                                }</span>

                                // Calculate visible range based on cursor and totalItems
                                <span class="cov0" title="0">start := 0
                                end := totalItems
                                if totalItems &gt; maxVisible </span><span class="cov0" title="0">{
                                        start = m.cursor - maxVisible/2
                                        if start &lt; 0 </span><span class="cov0" title="0">{
                                                start = 0
                                        }</span>
                                        <span class="cov0" title="0">end = start + maxVisible
                                        if end &gt; totalItems </span><span class="cov0" title="0">{
                                                end = totalItems
                                                start = end - maxVisible
                                                if start &lt; 0 </span><span class="cov0" title="0">{
                                                        start = 0
                                                }</span>
                                        }
                                }

                                <span class="cov0" title="0">clickedLine = msg.Y - headerOffset
                                clickedIndex = start + clickedLine

                                // Validate bounds
                                if clickedLine &lt; 0 || clickedIndex &gt;= end || clickedIndex &gt;= totalItems </span><span class="cov0" title="0">{
                                        clickedIndex = -1
                                }</span>
                        }

                        // Check bounds based on display mode
                        <span class="cov0" title="0">var validIndex bool
                        if m.displayMode == modeTree </span><span class="cov0" title="0">{
                                validIndex = clickedIndex &gt;= 0 &amp;&amp; clickedIndex &lt; len(m.treeItems)
                        }</span> else<span class="cov0" title="0"> {
                                validIndex = clickedIndex &gt;= 0 &amp;&amp; clickedIndex &lt; len(displayedFiles)
                        }</span>

                        <span class="cov0" title="0">if validIndex </span><span class="cov0" title="0">{
                                now := time.Now()

                                // Check for double-click: same item clicked within 500ms
                                const doubleClickThreshold = 500 * time.Millisecond
                                isDoubleClick := clickedIndex == m.lastClickIndex &amp;&amp;
                                        now.Sub(m.lastClickTime) &lt; doubleClickThreshold

                                // Get the file item based on display mode
                                var clickedFile fileItem
                                if m.displayMode == modeTree </span><span class="cov0" title="0">{
                                        clickedFile = m.treeItems[clickedIndex].file
                                }</span> else<span class="cov0" title="0"> {
                                        clickedFile = displayedFiles[clickedIndex]
                                }</span>

                                <span class="cov0" title="0">if isDoubleClick </span><span class="cov0" title="0">{
                                        // In file picker mode, double-click on file should select it
                                        if m.filePickerMode &amp;&amp; !clickedFile.isDir </span><span class="cov0" title="0">{
                                                // IMPORTANT: Set the value AFTER reloading preview to avoid field recreation overwriting it
                                                selectedPath := clickedFile.path
                                                selectedName := clickedFile.name

                                                // Return to preview mode
                                                m.filePickerMode = false
                                                m.showPromptsOnly = m.filePickerRestorePrompts // Restore prompts filter
                                                m.loadFiles()                                   // Reload files with restored filter
                                                m.viewMode = viewFullPreview
                                                m.inputFieldsActive = true // Re-enable input fields

                                                // Reload the original preview (this recreates input fields)
                                                if m.filePickerRestorePath != "" </span><span class="cov0" title="0">{
                                                        m.loadPreview(m.filePickerRestorePath)
                                                        m.populatePreviewCache()
                                                }</span>

                                                // NOW set the value after fields have been recreated
                                                <span class="cov0" title="0">if m.focusedInputField &gt;= 0 &amp;&amp; m.focusedInputField &lt; len(m.promptInputFields) </span><span class="cov0" title="0">{
                                                        m.promptInputFields[m.focusedInputField].value = selectedPath
                                                        m.setStatusMessage(fmt.Sprintf("✓ Selected: %s", selectedName), false)
                                                }</span>

                                                <span class="cov0" title="0">m.lastClickIndex = -1
                                                m.lastClickTime = time.Time{}
                                                return m, tea.ClearScreen</span>
                                        }

                                        // Double-click: navigate or full-screen preview
                                        <span class="cov0" title="0">if clickedFile.isDir </span><span class="cov0" title="0">{
                                                m.currentPath = clickedFile.path
                                                m.cursor = 0
                                                m.loadFiles()
                                        }</span> else<span class="cov0" title="0"> if !m.filePickerMode </span><span class="cov0" title="0">{
                                                // Enter full-screen preview (only if NOT in file picker mode)
                                                m.loadPreview(clickedFile.path)
                                                m.viewMode = viewFullPreview
                                                m.calculateLayout() // Update widths for full-screen
                                                m.populatePreviewCache() // Repopulate cache with correct width
                                                // Reset click tracking after double-click
                                                m.lastClickIndex = -1
                                                m.lastClickTime = time.Time{}
                                                // Clear screen for clean rendering
                                                return m, tea.ClearScreen
                                        }</span>
                                        // Reset click tracking after double-click (for directory navigation)
                                        <span class="cov0" title="0">m.lastClickIndex = -1
                                        m.lastClickTime = time.Time{}</span>
                                } else<span class="cov0" title="0"> {
                                        // Single-click: just select and update preview in dual-pane
                                        m.cursor = clickedIndex
                                        m.lastClickIndex = clickedIndex
                                        m.lastClickTime = now

                                        // Update preview in dual-pane mode
                                        if m.viewMode == viewDualPane &amp;&amp; !clickedFile.isDir </span><span class="cov0" title="0">{
                                                m.loadPreview(clickedFile.path)
                                                m.populatePreviewCache() // Populate cache with dual-pane width
                                        }</span>
                                }
                        }
                }

        case tea.MouseButtonRight:<span class="cov0" title="0">
                // Right-click: open context menu
                if msg.Action == tea.MouseActionRelease </span><span class="cov0" title="0">{
                        // Close any existing menu first to prevent phantoms
                        if m.contextMenuOpen </span><span class="cov0" title="0">{
                                m.contextMenuOpen = false
                        }</span>

                        // Don't open menu in preview mode or if in right pane
                        <span class="cov0" title="0">if m.viewMode == viewFullPreview </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">if m.viewMode == viewDualPane &amp;&amp; msg.X &gt;= m.leftWidth </span><span class="cov0" title="0">{
                                break</span>
                        }

                        // Calculate which item was right-clicked
                        // Both modes have top borders now, so content starts at line 5
                        <span class="cov0" title="0">headerOffset := 5 // +1 for top border (both modes have borders now)
                        if m.displayMode == modeDetail </span><span class="cov0" title="0">{
                                headerOffset += 1 // Add 1 for detail view's header only (separator removed)
                        }</span>

                        // Must match view.go and render_preview.go calculations (same as left-click handler)
                        <span class="cov0" title="0">var maxVisible int
                        var contentHeight int

                        if m.viewMode == viewDualPane </span><span class="cov0" title="0">{
                                // Dual-pane: maxVisible = m.height - 7 (total pane height INCLUDING borders)
                                maxVisible = m.height - 7
                                contentHeight = maxVisible - 2
                        }</span> else<span class="cov0" title="0"> {
                                // Single-pane: maxVisible = m.height - 9 (total box height INCLUDING borders)
                                maxVisible = m.height - 9
                                contentHeight = maxVisible - 2
                        }</span>

                        <span class="cov0" title="0">maxVisible = contentHeight
                        if m.displayMode == modeDetail </span><span class="cov0" title="0">{
                                maxVisible -= 1 // Account for detail header only
                        }</span>

                        // Get filtered files for right-click detection (respects favorites filter)
                        <span class="cov0" title="0">var displayedFiles []fileItem
                        if m.displayMode == modeTree </span><span class="cov0" title="0">{
                                displayedFiles = nil // Tree mode uses treeItems
                        }</span> else<span class="cov0" title="0"> {
                                displayedFiles = m.getFilteredFiles()
                        }</span>

                        <span class="cov0" title="0">var clickedIndex int

                        // Grid view: calculate row and column
                        if m.displayMode == modeGrid </span><span class="cov0" title="0">{
                                clickedRow := msg.Y - headerOffset

                                // Adjust X coordinate for left border (both modes have borders now)
                                adjustedX := msg.X - 2 // Account for left border
                                if adjustedX &lt; 0 </span><span class="cov0" title="0">{
                                        adjustedX = 0
                                }</span>

                                // Each grid cell: icon(2) + fav_indicator(2) + name(12) + padding(2) = 18 chars
                                <span class="cov0" title="0">cellWidth := 18
                                clickedCol := adjustedX / cellWidth
                                if clickedCol &gt;= m.gridColumns </span><span class="cov0" title="0">{
                                        clickedCol = m.gridColumns - 1
                                }</span>

                                <span class="cov0" title="0">totalItems := len(displayedFiles)
                                rows := (totalItems + m.gridColumns - 1) / m.gridColumns

                                startRow := 0
                                endRow := rows
                                if rows &gt; maxVisible </span><span class="cov0" title="0">{
                                        cursorRow := m.cursor / m.gridColumns
                                        startRow = cursorRow - maxVisible/2
                                        if startRow &lt; 0 </span><span class="cov0" title="0">{
                                                startRow = 0
                                        }</span>
                                        <span class="cov0" title="0">endRow = startRow + maxVisible
                                        if endRow &gt; rows </span><span class="cov0" title="0">{
                                                endRow = rows
                                                startRow = endRow - maxVisible
                                                if startRow &lt; 0 </span><span class="cov0" title="0">{
                                                        startRow = 0
                                                }</span>
                                        }
                                }

                                <span class="cov0" title="0">actualRow := startRow + clickedRow
                                clickedIndex = actualRow*m.gridColumns + clickedCol

                                if clickedRow &lt; 0 || actualRow &gt;= endRow || clickedIndex &gt;= len(displayedFiles) </span><span class="cov0" title="0">{
                                        clickedIndex = -1
                                }</span>
                        } else<span class="cov0" title="0"> {
                                // List, Detail, Tree modes: one item per line
                                // In tree mode, use tree items instead of files
                                var totalItems int
                                if m.displayMode == modeTree </span><span class="cov0" title="0">{
                                        totalItems = len(m.treeItems)
                                }</span> else<span class="cov0" title="0"> {
                                        totalItems = len(displayedFiles)
                                }</span>

                                // Calculate visible range based on cursor and totalItems
                                <span class="cov0" title="0">start := 0
                                end := totalItems
                                if totalItems &gt; maxVisible </span><span class="cov0" title="0">{
                                        start = m.cursor - maxVisible/2
                                        if start &lt; 0 </span><span class="cov0" title="0">{
                                                start = 0
                                        }</span>
                                        <span class="cov0" title="0">end = start + maxVisible
                                        if end &gt; totalItems </span><span class="cov0" title="0">{
                                                end = totalItems
                                                start = end - maxVisible
                                                if start &lt; 0 </span><span class="cov0" title="0">{
                                                        start = 0
                                                }</span>
                                        }
                                }

                                <span class="cov0" title="0">clickedLine := msg.Y - headerOffset
                                clickedIndex = start + clickedLine

                                if clickedLine &lt; 0 || clickedIndex &gt;= end || clickedIndex &gt;= totalItems </span><span class="cov0" title="0">{
                                        clickedIndex = -1
                                }</span>
                        }

                        // Open context menu if a valid file was clicked
                        <span class="cov0" title="0">var validIndex bool
                        if m.displayMode == modeTree </span><span class="cov0" title="0">{
                                validIndex = clickedIndex &gt;= 0 &amp;&amp; clickedIndex &lt; len(m.treeItems)
                        }</span> else<span class="cov0" title="0"> {
                                validIndex = clickedIndex &gt;= 0 &amp;&amp; clickedIndex &lt; len(displayedFiles)
                        }</span>

                        <span class="cov0" title="0">if validIndex </span><span class="cov0" title="0">{
                                m.contextMenuOpen = true
                                // Ensure menu has enough left margin for border to show
                                m.contextMenuX = msg.X
                                if m.contextMenuX &lt; 2 </span><span class="cov0" title="0">{
                                        m.contextMenuX = 2
                                }</span>
                                <span class="cov0" title="0">m.contextMenuY = msg.Y

                                // Clear command input to remove any unwanted paste from terminal's right-click paste
                                // (Many terminals paste clipboard on right-click before sending the click event)
                                m.commandInput = ""

                                // Get the file item based on display mode
                                if m.displayMode == modeTree </span><span class="cov0" title="0">{
                                        file := m.treeItems[clickedIndex].file
                                        m.contextMenuFile = &amp;file
                                }</span> else<span class="cov0" title="0"> {
                                        m.contextMenuFile = &amp;displayedFiles[clickedIndex]
                                }</span>
                                <span class="cov0" title="0">m.contextMenuCursor = 0</span>
                        }
                }

        case tea.MouseButtonWheelUp:<span class="cov0" title="0">
                // If context menu is open, scroll the menu
                if m.contextMenuOpen </span><span class="cov0" title="0">{
                        if m.contextMenuCursor &gt; 0 </span><span class="cov0" title="0">{
                                m.contextMenuCursor--
                        }</span>
                        <span class="cov0" title="0">return m, nil</span>
                }

                <span class="cov0" title="0">if m.viewMode == viewDualPane &amp;&amp; m.focusedPane == rightPane </span><span class="cov0" title="0">{
                        // Scroll preview up when right pane focused (3 lines per tick)
                        m.preview.scrollPos -= 3
                        if m.preview.scrollPos &lt; 0 </span><span class="cov0" title="0">{
                                m.preview.scrollPos = 0
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Scroll file list
                        if m.cursor &gt; 0 </span><span class="cov0" title="0">{
                                m.cursor--
                                // Update preview in dual-pane mode
                                if m.viewMode == viewDualPane </span><span class="cov0" title="0">{
                                        if currentFile := m.getCurrentFile(); currentFile != nil &amp;&amp; !currentFile.isDir </span><span class="cov0" title="0">{
                                                m.loadPreview(currentFile.path)
                                                m.populatePreviewCache() // Populate cache with dual-pane width
                                        }</span>
                                }
                        }
                }

        case tea.MouseButtonWheelDown:<span class="cov0" title="0">
                // If context menu is open, scroll the menu
                if m.contextMenuOpen </span><span class="cov0" title="0">{
                        menuItems := m.getContextMenuItems()
                        if m.contextMenuCursor &lt; len(menuItems)-1 </span><span class="cov0" title="0">{
                                m.contextMenuCursor++
                        }</span>
                        <span class="cov0" title="0">return m, nil</span>
                }

                <span class="cov0" title="0">if m.viewMode == viewDualPane &amp;&amp; m.focusedPane == rightPane </span><span class="cov0" title="0">{
                        // Scroll preview down when right pane focused (3 lines per tick)
                        visibleLines := m.height - 7
                        totalLines := m.getWrappedLineCount()
                        maxScroll := totalLines - visibleLines
                        if maxScroll &lt; 0 </span><span class="cov0" title="0">{
                                maxScroll = 0
                        }</span>
                        <span class="cov0" title="0">m.preview.scrollPos += 3
                        if m.preview.scrollPos &gt; maxScroll </span><span class="cov0" title="0">{
                                m.preview.scrollPos = maxScroll
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Scroll file list
                        maxCursor := m.getMaxCursor()
                        if m.cursor &lt; maxCursor </span><span class="cov0" title="0">{
                                m.cursor++
                                // Update preview in dual-pane mode
                                if m.viewMode == viewDualPane </span><span class="cov0" title="0">{
                                        if currentFile := m.getCurrentFile(); currentFile != nil &amp;&amp; !currentFile.isDir </span><span class="cov0" title="0">{
                                                m.loadPreview(currentFile.path)
                                                m.populatePreviewCache() // Populate cache with dual-pane width
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">return m, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package main

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/charmbracelet/lipgloss"
)

func (m model) View() string <span class="cov0" title="0">{
        // If fuzzy search is active, return empty string
        // (go-fzf handles its own rendering)
        if m.fuzzySearchActive </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">var baseView string

        // Dispatch to appropriate view based on viewMode
        switch m.viewMode </span>{
        case viewFullPreview:<span class="cov0" title="0">
                baseView = m.renderFullPreview()</span>
        case viewDualPane:<span class="cov0" title="0">
                baseView = m.renderDualPane()</span>
        default:<span class="cov0" title="0">
                // Single-pane mode (original view)
                baseView = m.renderSinglePane()</span>
        }

        // Overlay context menu if open
        <span class="cov0" title="0">if m.contextMenuOpen </span><span class="cov0" title="0">{
                menu := m.renderContextMenu()
                baseView = m.overlayContextMenu(baseView, menu)
        }</span>

        // Overlay dialog if open
        <span class="cov0" title="0">if m.showDialog </span><span class="cov0" title="0">{
                dialog := m.renderDialog()
                baseView = m.overlayDialog(baseView, dialog)
        }</span>

        <span class="cov0" title="0">return baseView</span>
}

// renderSinglePane renders the original single-pane file browser
func (m model) renderSinglePane() string <span class="cov0" title="0">{
        var s strings.Builder

        // Title with mode indicator and GitHub link
        titleText := "(T)erminal (F)ile (E)xplorer"
        if m.commandFocused </span><span class="cov0" title="0">{
                titleText += " [Command Mode]"
        }</span>
        <span class="cov0" title="0">if m.filePickerMode </span><span class="cov0" title="0">{
                titleText += " [📁 File Picker]"
        }</span>

        // Create GitHub link (OSC 8 hyperlink format)
        <span class="cov0" title="0">githubURL := "https://github.com/GGPrompts/TFE"
        githubLink := fmt.Sprintf("\033]8;;%s\033\\%s\033]8;;\033\\", githubURL, githubURL)

        // Calculate spacing to right-align GitHub link
        githubText := githubURL // Display text
        availableWidth := m.width - len(titleText) - len(githubText) - 2
        if availableWidth &lt; 1 </span><span class="cov0" title="0">{
                availableWidth = 1
        }</span>
        <span class="cov0" title="0">spacing := strings.Repeat(" ", availableWidth)

        // Render title on left, GitHub link on right
        title := titleStyle.Render(titleText) + spacing + titleStyle.Render(githubLink)
        s.WriteString(title)
        s.WriteString("\033[0m") // Reset ANSI codes
        s.WriteString("\n")

        // Toolbar buttons
        homeButtonStyle := lipgloss.NewStyle().
                Foreground(lipgloss.Color("39")).
                Bold(true)

        // Home button (highlight if in home directory)
        homeDir, _ := os.UserHomeDir()
        if m.currentPath == homeDir </span><span class="cov0" title="0">{
                // Active: gray background (in home directory)
                activeHomeStyle := lipgloss.NewStyle().
                        Foreground(lipgloss.Color("39")).
                        Bold(true).
                        Background(lipgloss.Color("237"))
                s.WriteString(activeHomeStyle.Render("[🏠]"))
        }</span> else<span class="cov0" title="0"> {
                // Inactive: normal styling
                s.WriteString(homeButtonStyle.Render("[🏠]"))
        }</span>
        <span class="cov0" title="0">s.WriteString(" ")

        // Favorites filter toggle button
        starIcon := "⭐"
        if m.showFavoritesOnly </span><span class="cov0" title="0">{
                starIcon = "✨" // Different icon when filter is active
        }</span>
        <span class="cov0" title="0">s.WriteString(homeButtonStyle.Render("[" + starIcon + "]"))
        s.WriteString(" ")

        // Command mode toggle button with green &gt;_ and blue brackets
        if m.commandFocused </span><span class="cov0" title="0">{
                // Active: gray background
                bracketStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("39")).Bold(true).Background(lipgloss.Color("237"))
                termStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("46")).Bold(true).Background(lipgloss.Color("237"))
                s.WriteString(bracketStyle.Render("["))
                s.WriteString(termStyle.Render("&gt;_"))
                s.WriteString(bracketStyle.Render("]"))
        }</span> else<span class="cov0" title="0"> {
                // Inactive: normal styling
                bracketStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("39")).Bold(true)
                termStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("46")).Bold(true)
                s.WriteString(bracketStyle.Render("["))
                s.WriteString(termStyle.Render("&gt;_"))
                s.WriteString(bracketStyle.Render("]"))
        }</span>
        <span class="cov0" title="0">s.WriteString(" ")

        // Fuzzy search button
        s.WriteString(homeButtonStyle.Render("[🔍]"))
        s.WriteString(" ")

        // Prompts filter toggle button
        if m.showPromptsOnly </span><span class="cov0" title="0">{
                // Active: gray background (like command mode)
                activeStyle := lipgloss.NewStyle().
                        Foreground(lipgloss.Color("39")).
                        Bold(true).
                        Background(lipgloss.Color("237"))
                s.WriteString(activeStyle.Render("[📝]"))
        }</span> else<span class="cov0" title="0"> {
                // Inactive: normal styling
                s.WriteString(homeButtonStyle.Render("[📝]"))
        }</span>
        <span class="cov0" title="0">s.WriteString(" ")

        // Trash/Recycle bin button
        trashIcon := "🗑️"
        if m.showTrashOnly </span><span class="cov0" title="0">{
                trashIcon = "♻️" // Recycle icon when viewing trash
        }</span>
        <span class="cov0" title="0">s.WriteString(homeButtonStyle.Render("[" + trashIcon + "]"))

        s.WriteString("\033[0m") // Reset ANSI codes
        s.WriteString("\n")

        // Command prompt with path (terminal-style)
        promptPrefix := lipgloss.NewStyle().Foreground(lipgloss.Color("39")).Bold(true).Render("$ ")
        pathPromptStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("39")).Bold(true)
        inputStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("252"))

        s.WriteString(promptPrefix)
        s.WriteString(pathPromptStyle.Render(getDisplayPath(m.currentPath)))
        s.WriteString(" ")
        s.WriteString(inputStyle.Render(m.commandInput))

        // Show cursor only when command mode is active
        if m.commandFocused </span><span class="cov0" title="0">{
                cursorStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("39")).Bold(true)
                s.WriteString(cursorStyle.Render("█"))
        }</span>
        // Explicitly reset styling after cursor to prevent ANSI code leakage
        <span class="cov0" title="0">s.WriteString("\033[0m")
        s.WriteString("\n")

        // Separator line between command prompt and file tree
        s.WriteString("\n")

        // File list - render based on current display mode
        // Calculate maxVisible to fit within terminal height:
        // title=1 + toolbar=1 + command=1 + separator=1 + filelist=maxVisible + spacer=1 + status=2 = m.height
        // Account for border (2 lines for top/bottom)
        // Therefore: maxVisible = m.height - 9 (total box height INCLUDING borders)
        maxVisible := m.height - 9

        // Content area is maxVisible - 2 (accounting for top/bottom borders)
        contentHeight := maxVisible - 2

        // Get file list content - use contentHeight so content fits within the box
        var fileListContent string
        switch m.displayMode </span>{
        case modeList:<span class="cov0" title="0">
                fileListContent = m.renderListView(contentHeight)</span>
        case modeGrid:<span class="cov0" title="0">
                fileListContent = m.renderGridView(contentHeight)</span>
        case modeDetail:<span class="cov0" title="0">
                fileListContent = m.renderDetailView(contentHeight)</span>
        case modeTree:<span class="cov0" title="0">
                fileListContent = m.renderTreeView(contentHeight)</span>
        default:<span class="cov0" title="0">
                fileListContent = m.renderListView(contentHeight)</span>
        }

        // Wrap content in a bordered box with fixed dimensions
        // Content is constrained to contentHeight lines to fit within the box
        <span class="cov0" title="0">fileListStyle := lipgloss.NewStyle().
                Width(m.width - 6).       // Leave margin for padding
                Height(contentHeight).    // Content area height (borders added by Lipgloss)
                Border(lipgloss.RoundedBorder()).
                BorderForeground(lipgloss.AdaptiveColor{
                        Light: "#0087d7", // Dark blue border for light
                        Dark:  "#5fd7ff",  // Bright cyan border for dark
                })

        s.WriteString(fileListStyle.Render(fileListContent))
        s.WriteString("\n")

        // Check if we should show status message (auto-dismiss after 3s)
        if m.statusMessage != "" &amp;&amp; time.Since(m.statusTime) &lt; 3*time.Second </span><span class="cov0" title="0">{
                msgStyle := lipgloss.NewStyle().
                        Background(lipgloss.Color("28")). // Green
                        Foreground(lipgloss.Color("0")).
                        Bold(true).
                        Padding(0, 1)

                if m.statusIsError </span><span class="cov0" title="0">{
                        msgStyle = msgStyle.Background(lipgloss.Color("196")) // Red
                }</span>

                <span class="cov0" title="0">s.WriteString(msgStyle.Render(m.statusMessage))
                s.WriteString("\033[0m") // Reset ANSI codes
                s.WriteString("\n") // Add blank line to maintain 2-line height
                s.WriteString(" ")</span> // Empty second line for consistent layout
        } else<span class="cov0" title="0"> if m.searchMode || m.searchQuery != "" </span><span class="cov0" title="0">{
                // Show search status
                searchStyle := lipgloss.NewStyle().
                        Background(lipgloss.Color("33")). // Blue background
                        Foreground(lipgloss.Color("255")). // Bright white for high contrast
                        Bold(true).
                        Padding(0, 1)

                // Calculate match count (exclude parent directory "..")
                matchCount := len(m.filteredIndices)
                if matchCount &gt; 0 </span><span class="cov0" title="0">{
                        matchCount-- // Exclude ".." which is always included
                }</span>

                <span class="cov0" title="0">var searchStatus string
                if m.searchMode </span><span class="cov0" title="0">{
                        // Active search mode with cursor
                        searchStatus = fmt.Sprintf("Search: %s█ (%d matches)", m.searchQuery, matchCount)
                }</span> else<span class="cov0" title="0"> {
                        // Search accepted (filter active but not in input mode)
                        searchStatus = fmt.Sprintf("Filtered: %s (%d matches)", m.searchQuery, matchCount)
                }</span>

                <span class="cov0" title="0">s.WriteString(searchStyle.Render(searchStatus))
                s.WriteString("\033[0m") // Reset ANSI codes
                s.WriteString("\n") // Add blank line to maintain 2-line height
                s.WriteString(" ")</span> // Empty second line for consistent layout
        } else<span class="cov0" title="0"> {
                // Regular status bar
                // Count directories and files
                dirCount, fileCount := 0, 0
                for _, f := range m.files </span><span class="cov0" title="0">{
                        if f.name == ".." </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">if f.isDir </span><span class="cov0" title="0">{
                                dirCount++
                        }</span> else<span class="cov0" title="0"> {
                                fileCount++
                        }</span>
                }

                // Selected file info
                <span class="cov0" title="0">var selectedInfo string
                if currentFile := m.getCurrentFile(); currentFile != nil </span><span class="cov0" title="0">{
                        if currentFile.isDir </span><span class="cov0" title="0">{
                                // Special handling for ".." to show parent directory name
                                if currentFile.name == ".." </span><span class="cov0" title="0">{
                                        parentPath := filepath.Dir(m.currentPath)
                                        parentName := filepath.Base(parentPath)
                                        if parentName == "/" || parentName == "." </span><span class="cov0" title="0">{
                                                parentName = "root"
                                        }</span>
                                        <span class="cov0" title="0">selectedInfo = fmt.Sprintf("Selected: .. (go up to %s)", parentName)</span>
                                } else<span class="cov0" title="0"> {
                                        selectedInfo = fmt.Sprintf("Selected: %s (folder)", currentFile.name)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                fileType := getFileType(*currentFile)
                                selectedInfo = fmt.Sprintf("Selected: %s (%s, %s, %s)",
                                        currentFile.name,
                                        fileType,
                                        formatFileSize(currentFile.size),
                                        formatModTime(currentFile.modTime))
                        }</span>
                }

                <span class="cov0" title="0">itemsInfo := fmt.Sprintf("%d items", len(m.files))
                if dirCount &gt; 0 || fileCount &gt; 0 </span><span class="cov0" title="0">{
                        itemsInfo = fmt.Sprintf("%d folders, %d files", dirCount, fileCount)
                }</span>

                <span class="cov0" title="0">hiddenIndicator := ""
                if m.showHidden </span><span class="cov0" title="0">{
                        hiddenIndicator = " • showing hidden"
                }</span>

                <span class="cov0" title="0">favoritesIndicator := ""
                if m.showFavoritesOnly </span><span class="cov0" title="0">{
                        favoritesIndicator = " • ⭐ favorites only"
                }</span>

                <span class="cov0" title="0">promptsIndicator := ""
                if m.showPromptsOnly </span><span class="cov0" title="0">{
                        promptsIndicator = " • 📝 prompts only"
                }</span>

                // View mode indicator
                <span class="cov0" title="0">viewModeText := fmt.Sprintf(" • view: %s", m.displayMode.String())

                // Help hint
                helpHint := " • F1: help"

                // Split status into two lines to prevent truncation
                // Line 1: Counts, indicators, view mode, help
                statusLine1 := fmt.Sprintf("%s%s%s%s%s%s", itemsInfo, hiddenIndicator, favoritesIndicator, promptsIndicator, viewModeText, helpHint)
                s.WriteString(statusStyle.Render(statusLine1))
                s.WriteString("\033[0m") // Reset ANSI codes
                s.WriteString("\n")

                // Line 2: Selected file info
                statusLine2 := selectedInfo
                s.WriteString(statusStyle.Render(statusLine2))
                s.WriteString("\033[0m")</span> // Reset ANSI codes
        }

        <span class="cov0" title="0">return s.String()</span>
}

// overlayContextMenu embeds the context menu into the base view at the correct position
// This approach works with Bubble Tea's diff-based rendering without needing tea.ClearScreen
func (m model) overlayContextMenu(baseView, menuContent string) string <span class="cov0" title="0">{
        x, y := m.contextMenuX, m.contextMenuY

        // Ensure menu stays on screen with proper margins
        if x &lt; 1 </span><span class="cov0" title="0">{
                x = 1
        }</span>
        <span class="cov0" title="0">if x &gt; m.width-25 </span><span class="cov0" title="0">{
                x = m.width - 25
        }</span>
        <span class="cov0" title="0">if y &lt; 1 </span><span class="cov0" title="0">{
                y = 1
        }</span>
        <span class="cov0" title="0">if y &gt; m.height-10 </span><span class="cov0" title="0">{
                y = m.height - 10
        }</span>

        // Split both views into lines
        <span class="cov0" title="0">baseLines := strings.Split(baseView, "\n")
        menuLines := strings.Split(strings.TrimSpace(menuContent), "\n")

        // Ensure we have enough base lines
        for len(baseLines) &lt; m.height </span><span class="cov0" title="0">{
                baseLines = append(baseLines, "")
        }</span>

        // Overlay each menu line onto the base view
        <span class="cov0" title="0">for i, menuLine := range menuLines </span><span class="cov0" title="0">{
                targetLine := y + i
                if targetLine &lt; 0 || targetLine &gt;= len(baseLines) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">baseLine := baseLines[targetLine]

                // We need to overlay menuLine at visual column x
                // Use a string builder to construct the new line
                var newLine strings.Builder

                // Get the part of baseLine before position x
                // We need to handle ANSI codes properly
                visualPos := 0
                bytePos := 0
                inAnsi := false
                baseRunes := []rune(baseLine)

                // Scan through base line until we reach visual position x
                for bytePos &lt; len(baseRunes) &amp;&amp; visualPos &lt; x </span><span class="cov0" title="0">{
                        if baseRunes[bytePos] == '\033' </span><span class="cov0" title="0">{
                                inAnsi = true
                        }</span>

                        <span class="cov0" title="0">if inAnsi </span><span class="cov0" title="0">{
                                if baseRunes[bytePos] &gt;= 'A' &amp;&amp; baseRunes[bytePos] &lt;= 'Z' ||
                                        baseRunes[bytePos] &gt;= 'a' &amp;&amp; baseRunes[bytePos] &lt;= 'z' </span><span class="cov0" title="0">{
                                        inAnsi = false
                                }</span>
                        } else<span class="cov0" title="0"> {
                                visualPos++
                        }</span>
                        <span class="cov0" title="0">bytePos++</span>
                }

                // Add the left part of the base line (up to position x)
                <span class="cov0" title="0">if bytePos &gt; 0 &amp;&amp; bytePos &lt;= len(baseRunes) </span><span class="cov0" title="0">{
                        newLine.WriteString(string(baseRunes[:bytePos]))
                }</span>

                // Pad with spaces if needed to reach position x
                <span class="cov0" title="0">for visualPos &lt; x </span><span class="cov0" title="0">{
                        newLine.WriteRune(' ')
                        visualPos++
                }</span>

                // Add the menu line
                <span class="cov0" title="0">newLine.WriteString(menuLine)

                baseLines[targetLine] = newLine.String()</span>
        }

        <span class="cov0" title="0">return strings.Join(baseLines, "\n")</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
